
bin/Debug/ctrl.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002d40  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000014  00800060  00002d40  00002dd4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000344  00800074  00800074  00002de8  2**0
                  ALLOC
  3 .stab         00006e70  00000000  00000000  00002de8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000058b0  00000000  00000000  00009c58  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 18 03 	jmp	0x630	; 0x630 <__vector_6>
      1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d4 e0       	ldi	r29, 0x04	; 4
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e0 e4       	ldi	r30, 0x40	; 64
      68:	fd e2       	ldi	r31, 0x2D	; 45
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a4 37       	cpi	r26, 0x74	; 116
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	13 e0       	ldi	r17, 0x03	; 3
      78:	a4 e7       	ldi	r26, 0x74	; 116
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a8 3b       	cpi	r26, 0xB8	; 184
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 f3 14 	call	0x29e6	; 0x29e6 <main>
      8a:	0c 94 9e 16 	jmp	0x2d3c	; 0x2d3c <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	cd b7       	in	r28, 0x3d	; 61
      98:	de b7       	in	r29, 0x3e	; 62
      9a:	28 97       	sbiw	r28, 0x08	; 8
      9c:	0f b6       	in	r0, 0x3f	; 63
      9e:	f8 94       	cli
      a0:	de bf       	out	0x3e, r29	; 62
      a2:	0f be       	out	0x3f, r0	; 63
      a4:	cd bf       	out	0x3d, r28	; 61
      a6:	9c 83       	std	Y+4, r25	; 0x04
      a8:	8b 83       	std	Y+3, r24	; 0x03
      aa:	7e 83       	std	Y+6, r23	; 0x06
      ac:	6d 83       	std	Y+5, r22	; 0x05
      ae:	58 87       	std	Y+8, r21	; 0x08
      b0:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
      b2:	eb 81       	ldd	r30, Y+3	; 0x03
      b4:	fc 81       	ldd	r31, Y+4	; 0x04
      b6:	81 e1       	ldi	r24, 0x11	; 17
      b8:	80 83       	st	Z, r24
	pxTopOfStack--;
      ba:	8b 81       	ldd	r24, Y+3	; 0x03
      bc:	9c 81       	ldd	r25, Y+4	; 0x04
      be:	01 97       	sbiw	r24, 0x01	; 1
      c0:	9c 83       	std	Y+4, r25	; 0x04
      c2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
      c4:	eb 81       	ldd	r30, Y+3	; 0x03
      c6:	fc 81       	ldd	r31, Y+4	; 0x04
      c8:	82 e2       	ldi	r24, 0x22	; 34
      ca:	80 83       	st	Z, r24
	pxTopOfStack--;
      cc:	8b 81       	ldd	r24, Y+3	; 0x03
      ce:	9c 81       	ldd	r25, Y+4	; 0x04
      d0:	01 97       	sbiw	r24, 0x01	; 1
      d2:	9c 83       	std	Y+4, r25	; 0x04
      d4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
      d6:	eb 81       	ldd	r30, Y+3	; 0x03
      d8:	fc 81       	ldd	r31, Y+4	; 0x04
      da:	83 e3       	ldi	r24, 0x33	; 51
      dc:	80 83       	st	Z, r24
	pxTopOfStack--;
      de:	8b 81       	ldd	r24, Y+3	; 0x03
      e0:	9c 81       	ldd	r25, Y+4	; 0x04
      e2:	01 97       	sbiw	r24, 0x01	; 1
      e4:	9c 83       	std	Y+4, r25	; 0x04
      e6:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
      e8:	8d 81       	ldd	r24, Y+5	; 0x05
      ea:	9e 81       	ldd	r25, Y+6	; 0x06
      ec:	9a 83       	std	Y+2, r25	; 0x02
      ee:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
      f0:	89 81       	ldd	r24, Y+1	; 0x01
      f2:	eb 81       	ldd	r30, Y+3	; 0x03
      f4:	fc 81       	ldd	r31, Y+4	; 0x04
      f6:	80 83       	st	Z, r24
	pxTopOfStack--;
      f8:	8b 81       	ldd	r24, Y+3	; 0x03
      fa:	9c 81       	ldd	r25, Y+4	; 0x04
      fc:	01 97       	sbiw	r24, 0x01	; 1
      fe:	9c 83       	std	Y+4, r25	; 0x04
     100:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     102:	89 81       	ldd	r24, Y+1	; 0x01
     104:	9a 81       	ldd	r25, Y+2	; 0x02
     106:	89 2f       	mov	r24, r25
     108:	99 27       	eor	r25, r25
     10a:	9a 83       	std	Y+2, r25	; 0x02
     10c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     10e:	89 81       	ldd	r24, Y+1	; 0x01
     110:	eb 81       	ldd	r30, Y+3	; 0x03
     112:	fc 81       	ldd	r31, Y+4	; 0x04
     114:	80 83       	st	Z, r24
	pxTopOfStack--;
     116:	8b 81       	ldd	r24, Y+3	; 0x03
     118:	9c 81       	ldd	r25, Y+4	; 0x04
     11a:	01 97       	sbiw	r24, 0x01	; 1
     11c:	9c 83       	std	Y+4, r25	; 0x04
     11e:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
     120:	eb 81       	ldd	r30, Y+3	; 0x03
     122:	fc 81       	ldd	r31, Y+4	; 0x04
     124:	10 82       	st	Z, r1
	pxTopOfStack--;
     126:	8b 81       	ldd	r24, Y+3	; 0x03
     128:	9c 81       	ldd	r25, Y+4	; 0x04
     12a:	01 97       	sbiw	r24, 0x01	; 1
     12c:	9c 83       	std	Y+4, r25	; 0x04
     12e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     130:	eb 81       	ldd	r30, Y+3	; 0x03
     132:	fc 81       	ldd	r31, Y+4	; 0x04
     134:	80 e8       	ldi	r24, 0x80	; 128
     136:	80 83       	st	Z, r24
	pxTopOfStack--;
     138:	8b 81       	ldd	r24, Y+3	; 0x03
     13a:	9c 81       	ldd	r25, Y+4	; 0x04
     13c:	01 97       	sbiw	r24, 0x01	; 1
     13e:	9c 83       	std	Y+4, r25	; 0x04
     140:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
     142:	eb 81       	ldd	r30, Y+3	; 0x03
     144:	fc 81       	ldd	r31, Y+4	; 0x04
     146:	10 82       	st	Z, r1
	pxTopOfStack--;
     148:	8b 81       	ldd	r24, Y+3	; 0x03
     14a:	9c 81       	ldd	r25, Y+4	; 0x04
     14c:	01 97       	sbiw	r24, 0x01	; 1
     14e:	9c 83       	std	Y+4, r25	; 0x04
     150:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
     152:	eb 81       	ldd	r30, Y+3	; 0x03
     154:	fc 81       	ldd	r31, Y+4	; 0x04
     156:	82 e0       	ldi	r24, 0x02	; 2
     158:	80 83       	st	Z, r24
	pxTopOfStack--;
     15a:	8b 81       	ldd	r24, Y+3	; 0x03
     15c:	9c 81       	ldd	r25, Y+4	; 0x04
     15e:	01 97       	sbiw	r24, 0x01	; 1
     160:	9c 83       	std	Y+4, r25	; 0x04
     162:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
     164:	eb 81       	ldd	r30, Y+3	; 0x03
     166:	fc 81       	ldd	r31, Y+4	; 0x04
     168:	83 e0       	ldi	r24, 0x03	; 3
     16a:	80 83       	st	Z, r24
	pxTopOfStack--;
     16c:	8b 81       	ldd	r24, Y+3	; 0x03
     16e:	9c 81       	ldd	r25, Y+4	; 0x04
     170:	01 97       	sbiw	r24, 0x01	; 1
     172:	9c 83       	std	Y+4, r25	; 0x04
     174:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
     176:	eb 81       	ldd	r30, Y+3	; 0x03
     178:	fc 81       	ldd	r31, Y+4	; 0x04
     17a:	84 e0       	ldi	r24, 0x04	; 4
     17c:	80 83       	st	Z, r24
	pxTopOfStack--;
     17e:	8b 81       	ldd	r24, Y+3	; 0x03
     180:	9c 81       	ldd	r25, Y+4	; 0x04
     182:	01 97       	sbiw	r24, 0x01	; 1
     184:	9c 83       	std	Y+4, r25	; 0x04
     186:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
     188:	eb 81       	ldd	r30, Y+3	; 0x03
     18a:	fc 81       	ldd	r31, Y+4	; 0x04
     18c:	85 e0       	ldi	r24, 0x05	; 5
     18e:	80 83       	st	Z, r24
	pxTopOfStack--;
     190:	8b 81       	ldd	r24, Y+3	; 0x03
     192:	9c 81       	ldd	r25, Y+4	; 0x04
     194:	01 97       	sbiw	r24, 0x01	; 1
     196:	9c 83       	std	Y+4, r25	; 0x04
     198:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
     19a:	eb 81       	ldd	r30, Y+3	; 0x03
     19c:	fc 81       	ldd	r31, Y+4	; 0x04
     19e:	86 e0       	ldi	r24, 0x06	; 6
     1a0:	80 83       	st	Z, r24
	pxTopOfStack--;
     1a2:	8b 81       	ldd	r24, Y+3	; 0x03
     1a4:	9c 81       	ldd	r25, Y+4	; 0x04
     1a6:	01 97       	sbiw	r24, 0x01	; 1
     1a8:	9c 83       	std	Y+4, r25	; 0x04
     1aa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
     1ac:	eb 81       	ldd	r30, Y+3	; 0x03
     1ae:	fc 81       	ldd	r31, Y+4	; 0x04
     1b0:	87 e0       	ldi	r24, 0x07	; 7
     1b2:	80 83       	st	Z, r24
	pxTopOfStack--;
     1b4:	8b 81       	ldd	r24, Y+3	; 0x03
     1b6:	9c 81       	ldd	r25, Y+4	; 0x04
     1b8:	01 97       	sbiw	r24, 0x01	; 1
     1ba:	9c 83       	std	Y+4, r25	; 0x04
     1bc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
     1be:	eb 81       	ldd	r30, Y+3	; 0x03
     1c0:	fc 81       	ldd	r31, Y+4	; 0x04
     1c2:	88 e0       	ldi	r24, 0x08	; 8
     1c4:	80 83       	st	Z, r24
	pxTopOfStack--;
     1c6:	8b 81       	ldd	r24, Y+3	; 0x03
     1c8:	9c 81       	ldd	r25, Y+4	; 0x04
     1ca:	01 97       	sbiw	r24, 0x01	; 1
     1cc:	9c 83       	std	Y+4, r25	; 0x04
     1ce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
     1d0:	eb 81       	ldd	r30, Y+3	; 0x03
     1d2:	fc 81       	ldd	r31, Y+4	; 0x04
     1d4:	89 e0       	ldi	r24, 0x09	; 9
     1d6:	80 83       	st	Z, r24
	pxTopOfStack--;
     1d8:	8b 81       	ldd	r24, Y+3	; 0x03
     1da:	9c 81       	ldd	r25, Y+4	; 0x04
     1dc:	01 97       	sbiw	r24, 0x01	; 1
     1de:	9c 83       	std	Y+4, r25	; 0x04
     1e0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
     1e2:	eb 81       	ldd	r30, Y+3	; 0x03
     1e4:	fc 81       	ldd	r31, Y+4	; 0x04
     1e6:	80 e1       	ldi	r24, 0x10	; 16
     1e8:	80 83       	st	Z, r24
	pxTopOfStack--;
     1ea:	8b 81       	ldd	r24, Y+3	; 0x03
     1ec:	9c 81       	ldd	r25, Y+4	; 0x04
     1ee:	01 97       	sbiw	r24, 0x01	; 1
     1f0:	9c 83       	std	Y+4, r25	; 0x04
     1f2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
     1f4:	eb 81       	ldd	r30, Y+3	; 0x03
     1f6:	fc 81       	ldd	r31, Y+4	; 0x04
     1f8:	81 e1       	ldi	r24, 0x11	; 17
     1fa:	80 83       	st	Z, r24
	pxTopOfStack--;
     1fc:	8b 81       	ldd	r24, Y+3	; 0x03
     1fe:	9c 81       	ldd	r25, Y+4	; 0x04
     200:	01 97       	sbiw	r24, 0x01	; 1
     202:	9c 83       	std	Y+4, r25	; 0x04
     204:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
     206:	eb 81       	ldd	r30, Y+3	; 0x03
     208:	fc 81       	ldd	r31, Y+4	; 0x04
     20a:	82 e1       	ldi	r24, 0x12	; 18
     20c:	80 83       	st	Z, r24
	pxTopOfStack--;
     20e:	8b 81       	ldd	r24, Y+3	; 0x03
     210:	9c 81       	ldd	r25, Y+4	; 0x04
     212:	01 97       	sbiw	r24, 0x01	; 1
     214:	9c 83       	std	Y+4, r25	; 0x04
     216:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
     218:	eb 81       	ldd	r30, Y+3	; 0x03
     21a:	fc 81       	ldd	r31, Y+4	; 0x04
     21c:	83 e1       	ldi	r24, 0x13	; 19
     21e:	80 83       	st	Z, r24
	pxTopOfStack--;
     220:	8b 81       	ldd	r24, Y+3	; 0x03
     222:	9c 81       	ldd	r25, Y+4	; 0x04
     224:	01 97       	sbiw	r24, 0x01	; 1
     226:	9c 83       	std	Y+4, r25	; 0x04
     228:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
     22a:	eb 81       	ldd	r30, Y+3	; 0x03
     22c:	fc 81       	ldd	r31, Y+4	; 0x04
     22e:	84 e1       	ldi	r24, 0x14	; 20
     230:	80 83       	st	Z, r24
	pxTopOfStack--;
     232:	8b 81       	ldd	r24, Y+3	; 0x03
     234:	9c 81       	ldd	r25, Y+4	; 0x04
     236:	01 97       	sbiw	r24, 0x01	; 1
     238:	9c 83       	std	Y+4, r25	; 0x04
     23a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
     23c:	eb 81       	ldd	r30, Y+3	; 0x03
     23e:	fc 81       	ldd	r31, Y+4	; 0x04
     240:	85 e1       	ldi	r24, 0x15	; 21
     242:	80 83       	st	Z, r24
	pxTopOfStack--;
     244:	8b 81       	ldd	r24, Y+3	; 0x03
     246:	9c 81       	ldd	r25, Y+4	; 0x04
     248:	01 97       	sbiw	r24, 0x01	; 1
     24a:	9c 83       	std	Y+4, r25	; 0x04
     24c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
     24e:	eb 81       	ldd	r30, Y+3	; 0x03
     250:	fc 81       	ldd	r31, Y+4	; 0x04
     252:	86 e1       	ldi	r24, 0x16	; 22
     254:	80 83       	st	Z, r24
	pxTopOfStack--;
     256:	8b 81       	ldd	r24, Y+3	; 0x03
     258:	9c 81       	ldd	r25, Y+4	; 0x04
     25a:	01 97       	sbiw	r24, 0x01	; 1
     25c:	9c 83       	std	Y+4, r25	; 0x04
     25e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
     260:	eb 81       	ldd	r30, Y+3	; 0x03
     262:	fc 81       	ldd	r31, Y+4	; 0x04
     264:	87 e1       	ldi	r24, 0x17	; 23
     266:	80 83       	st	Z, r24
	pxTopOfStack--;
     268:	8b 81       	ldd	r24, Y+3	; 0x03
     26a:	9c 81       	ldd	r25, Y+4	; 0x04
     26c:	01 97       	sbiw	r24, 0x01	; 1
     26e:	9c 83       	std	Y+4, r25	; 0x04
     270:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
     272:	eb 81       	ldd	r30, Y+3	; 0x03
     274:	fc 81       	ldd	r31, Y+4	; 0x04
     276:	88 e1       	ldi	r24, 0x18	; 24
     278:	80 83       	st	Z, r24
	pxTopOfStack--;
     27a:	8b 81       	ldd	r24, Y+3	; 0x03
     27c:	9c 81       	ldd	r25, Y+4	; 0x04
     27e:	01 97       	sbiw	r24, 0x01	; 1
     280:	9c 83       	std	Y+4, r25	; 0x04
     282:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
     284:	eb 81       	ldd	r30, Y+3	; 0x03
     286:	fc 81       	ldd	r31, Y+4	; 0x04
     288:	89 e1       	ldi	r24, 0x19	; 25
     28a:	80 83       	st	Z, r24
	pxTopOfStack--;
     28c:	8b 81       	ldd	r24, Y+3	; 0x03
     28e:	9c 81       	ldd	r25, Y+4	; 0x04
     290:	01 97       	sbiw	r24, 0x01	; 1
     292:	9c 83       	std	Y+4, r25	; 0x04
     294:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
     296:	eb 81       	ldd	r30, Y+3	; 0x03
     298:	fc 81       	ldd	r31, Y+4	; 0x04
     29a:	80 e2       	ldi	r24, 0x20	; 32
     29c:	80 83       	st	Z, r24
	pxTopOfStack--;
     29e:	8b 81       	ldd	r24, Y+3	; 0x03
     2a0:	9c 81       	ldd	r25, Y+4	; 0x04
     2a2:	01 97       	sbiw	r24, 0x01	; 1
     2a4:	9c 83       	std	Y+4, r25	; 0x04
     2a6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
     2a8:	eb 81       	ldd	r30, Y+3	; 0x03
     2aa:	fc 81       	ldd	r31, Y+4	; 0x04
     2ac:	81 e2       	ldi	r24, 0x21	; 33
     2ae:	80 83       	st	Z, r24
	pxTopOfStack--;
     2b0:	8b 81       	ldd	r24, Y+3	; 0x03
     2b2:	9c 81       	ldd	r25, Y+4	; 0x04
     2b4:	01 97       	sbiw	r24, 0x01	; 1
     2b6:	9c 83       	std	Y+4, r25	; 0x04
     2b8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
     2ba:	eb 81       	ldd	r30, Y+3	; 0x03
     2bc:	fc 81       	ldd	r31, Y+4	; 0x04
     2be:	82 e2       	ldi	r24, 0x22	; 34
     2c0:	80 83       	st	Z, r24
	pxTopOfStack--;
     2c2:	8b 81       	ldd	r24, Y+3	; 0x03
     2c4:	9c 81       	ldd	r25, Y+4	; 0x04
     2c6:	01 97       	sbiw	r24, 0x01	; 1
     2c8:	9c 83       	std	Y+4, r25	; 0x04
     2ca:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
     2cc:	eb 81       	ldd	r30, Y+3	; 0x03
     2ce:	fc 81       	ldd	r31, Y+4	; 0x04
     2d0:	83 e2       	ldi	r24, 0x23	; 35
     2d2:	80 83       	st	Z, r24
	pxTopOfStack--;
     2d4:	8b 81       	ldd	r24, Y+3	; 0x03
     2d6:	9c 81       	ldd	r25, Y+4	; 0x04
     2d8:	01 97       	sbiw	r24, 0x01	; 1
     2da:	9c 83       	std	Y+4, r25	; 0x04
     2dc:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
     2de:	8f 81       	ldd	r24, Y+7	; 0x07
     2e0:	98 85       	ldd	r25, Y+8	; 0x08
     2e2:	9a 83       	std	Y+2, r25	; 0x02
     2e4:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     2e6:	89 81       	ldd	r24, Y+1	; 0x01
     2e8:	eb 81       	ldd	r30, Y+3	; 0x03
     2ea:	fc 81       	ldd	r31, Y+4	; 0x04
     2ec:	80 83       	st	Z, r24
	pxTopOfStack--;
     2ee:	8b 81       	ldd	r24, Y+3	; 0x03
     2f0:	9c 81       	ldd	r25, Y+4	; 0x04
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	9c 83       	std	Y+4, r25	; 0x04
     2f6:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     2f8:	89 81       	ldd	r24, Y+1	; 0x01
     2fa:	9a 81       	ldd	r25, Y+2	; 0x02
     2fc:	89 2f       	mov	r24, r25
     2fe:	99 27       	eor	r25, r25
     300:	9a 83       	std	Y+2, r25	; 0x02
     302:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     304:	89 81       	ldd	r24, Y+1	; 0x01
     306:	eb 81       	ldd	r30, Y+3	; 0x03
     308:	fc 81       	ldd	r31, Y+4	; 0x04
     30a:	80 83       	st	Z, r24
	pxTopOfStack--;
     30c:	8b 81       	ldd	r24, Y+3	; 0x03
     30e:	9c 81       	ldd	r25, Y+4	; 0x04
     310:	01 97       	sbiw	r24, 0x01	; 1
     312:	9c 83       	std	Y+4, r25	; 0x04
     314:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
     316:	eb 81       	ldd	r30, Y+3	; 0x03
     318:	fc 81       	ldd	r31, Y+4	; 0x04
     31a:	86 e2       	ldi	r24, 0x26	; 38
     31c:	80 83       	st	Z, r24
	pxTopOfStack--;
     31e:	8b 81       	ldd	r24, Y+3	; 0x03
     320:	9c 81       	ldd	r25, Y+4	; 0x04
     322:	01 97       	sbiw	r24, 0x01	; 1
     324:	9c 83       	std	Y+4, r25	; 0x04
     326:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
     328:	eb 81       	ldd	r30, Y+3	; 0x03
     32a:	fc 81       	ldd	r31, Y+4	; 0x04
     32c:	87 e2       	ldi	r24, 0x27	; 39
     32e:	80 83       	st	Z, r24
	pxTopOfStack--;
     330:	8b 81       	ldd	r24, Y+3	; 0x03
     332:	9c 81       	ldd	r25, Y+4	; 0x04
     334:	01 97       	sbiw	r24, 0x01	; 1
     336:	9c 83       	std	Y+4, r25	; 0x04
     338:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
     33a:	eb 81       	ldd	r30, Y+3	; 0x03
     33c:	fc 81       	ldd	r31, Y+4	; 0x04
     33e:	88 e2       	ldi	r24, 0x28	; 40
     340:	80 83       	st	Z, r24
	pxTopOfStack--;
     342:	8b 81       	ldd	r24, Y+3	; 0x03
     344:	9c 81       	ldd	r25, Y+4	; 0x04
     346:	01 97       	sbiw	r24, 0x01	; 1
     348:	9c 83       	std	Y+4, r25	; 0x04
     34a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
     34c:	eb 81       	ldd	r30, Y+3	; 0x03
     34e:	fc 81       	ldd	r31, Y+4	; 0x04
     350:	89 e2       	ldi	r24, 0x29	; 41
     352:	80 83       	st	Z, r24
	pxTopOfStack--;
     354:	8b 81       	ldd	r24, Y+3	; 0x03
     356:	9c 81       	ldd	r25, Y+4	; 0x04
     358:	01 97       	sbiw	r24, 0x01	; 1
     35a:	9c 83       	std	Y+4, r25	; 0x04
     35c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
     35e:	eb 81       	ldd	r30, Y+3	; 0x03
     360:	fc 81       	ldd	r31, Y+4	; 0x04
     362:	80 e3       	ldi	r24, 0x30	; 48
     364:	80 83       	st	Z, r24
	pxTopOfStack--;
     366:	8b 81       	ldd	r24, Y+3	; 0x03
     368:	9c 81       	ldd	r25, Y+4	; 0x04
     36a:	01 97       	sbiw	r24, 0x01	; 1
     36c:	9c 83       	std	Y+4, r25	; 0x04
     36e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
     370:	eb 81       	ldd	r30, Y+3	; 0x03
     372:	fc 81       	ldd	r31, Y+4	; 0x04
     374:	81 e3       	ldi	r24, 0x31	; 49
     376:	80 83       	st	Z, r24
	pxTopOfStack--;
     378:	8b 81       	ldd	r24, Y+3	; 0x03
     37a:	9c 81       	ldd	r25, Y+4	; 0x04
     37c:	01 97       	sbiw	r24, 0x01	; 1
     37e:	9c 83       	std	Y+4, r25	; 0x04
     380:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     382:	8b 81       	ldd	r24, Y+3	; 0x03
     384:	9c 81       	ldd	r25, Y+4	; 0x04
}
     386:	28 96       	adiw	r28, 0x08	; 8
     388:	0f b6       	in	r0, 0x3f	; 63
     38a:	f8 94       	cli
     38c:	de bf       	out	0x3e, r29	; 62
     38e:	0f be       	out	0x3f, r0	; 63
     390:	cd bf       	out	0x3d, r28	; 61
     392:	cf 91       	pop	r28
     394:	df 91       	pop	r29
     396:	08 95       	ret

00000398 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
     398:	df 93       	push	r29
     39a:	cf 93       	push	r28
     39c:	cd b7       	in	r28, 0x3d	; 61
     39e:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     3a0:	0e 94 bc 02 	call	0x578	; 0x578 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     3a4:	a0 91 ff 02 	lds	r26, 0x02FF
     3a8:	b0 91 00 03 	lds	r27, 0x0300
     3ac:	cd 91       	ld	r28, X+
     3ae:	cd bf       	out	0x3d, r28	; 61
     3b0:	dd 91       	ld	r29, X+
     3b2:	de bf       	out	0x3e, r29	; 62
     3b4:	ff 91       	pop	r31
     3b6:	ef 91       	pop	r30
     3b8:	df 91       	pop	r29
     3ba:	cf 91       	pop	r28
     3bc:	bf 91       	pop	r27
     3be:	af 91       	pop	r26
     3c0:	9f 91       	pop	r25
     3c2:	8f 91       	pop	r24
     3c4:	7f 91       	pop	r23
     3c6:	6f 91       	pop	r22
     3c8:	5f 91       	pop	r21
     3ca:	4f 91       	pop	r20
     3cc:	3f 91       	pop	r19
     3ce:	2f 91       	pop	r18
     3d0:	1f 91       	pop	r17
     3d2:	0f 91       	pop	r16
     3d4:	ff 90       	pop	r15
     3d6:	ef 90       	pop	r14
     3d8:	df 90       	pop	r13
     3da:	cf 90       	pop	r12
     3dc:	bf 90       	pop	r11
     3de:	af 90       	pop	r10
     3e0:	9f 90       	pop	r9
     3e2:	8f 90       	pop	r8
     3e4:	7f 90       	pop	r7
     3e6:	6f 90       	pop	r6
     3e8:	5f 90       	pop	r5
     3ea:	4f 90       	pop	r4
     3ec:	3f 90       	pop	r3
     3ee:	2f 90       	pop	r2
     3f0:	1f 90       	pop	r1
     3f2:	0f 90       	pop	r0
     3f4:	0f be       	out	0x3f, r0	; 63
     3f6:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     3f8:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
     3fa:	81 e0       	ldi	r24, 0x01	; 1
}
     3fc:	cf 91       	pop	r28
     3fe:	df 91       	pop	r29
     400:	08 95       	ret

00000402 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     402:	df 93       	push	r29
     404:	cf 93       	push	r28
     406:	cd b7       	in	r28, 0x3d	; 61
     408:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     40a:	cf 91       	pop	r28
     40c:	df 91       	pop	r29
     40e:	08 95       	ret

00000410 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     410:	0f 92       	push	r0
     412:	0f b6       	in	r0, 0x3f	; 63
     414:	f8 94       	cli
     416:	0f 92       	push	r0
     418:	1f 92       	push	r1
     41a:	11 24       	eor	r1, r1
     41c:	2f 92       	push	r2
     41e:	3f 92       	push	r3
     420:	4f 92       	push	r4
     422:	5f 92       	push	r5
     424:	6f 92       	push	r6
     426:	7f 92       	push	r7
     428:	8f 92       	push	r8
     42a:	9f 92       	push	r9
     42c:	af 92       	push	r10
     42e:	bf 92       	push	r11
     430:	cf 92       	push	r12
     432:	df 92       	push	r13
     434:	ef 92       	push	r14
     436:	ff 92       	push	r15
     438:	0f 93       	push	r16
     43a:	1f 93       	push	r17
     43c:	2f 93       	push	r18
     43e:	3f 93       	push	r19
     440:	4f 93       	push	r20
     442:	5f 93       	push	r21
     444:	6f 93       	push	r22
     446:	7f 93       	push	r23
     448:	8f 93       	push	r24
     44a:	9f 93       	push	r25
     44c:	af 93       	push	r26
     44e:	bf 93       	push	r27
     450:	cf 93       	push	r28
     452:	df 93       	push	r29
     454:	ef 93       	push	r30
     456:	ff 93       	push	r31
     458:	a0 91 ff 02 	lds	r26, 0x02FF
     45c:	b0 91 00 03 	lds	r27, 0x0300
     460:	0d b6       	in	r0, 0x3d	; 61
     462:	0d 92       	st	X+, r0
     464:	0e b6       	in	r0, 0x3e	; 62
     466:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     468:	0e 94 6a 10 	call	0x20d4	; 0x20d4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     46c:	a0 91 ff 02 	lds	r26, 0x02FF
     470:	b0 91 00 03 	lds	r27, 0x0300
     474:	cd 91       	ld	r28, X+
     476:	cd bf       	out	0x3d, r28	; 61
     478:	dd 91       	ld	r29, X+
     47a:	de bf       	out	0x3e, r29	; 62
     47c:	ff 91       	pop	r31
     47e:	ef 91       	pop	r30
     480:	df 91       	pop	r29
     482:	cf 91       	pop	r28
     484:	bf 91       	pop	r27
     486:	af 91       	pop	r26
     488:	9f 91       	pop	r25
     48a:	8f 91       	pop	r24
     48c:	7f 91       	pop	r23
     48e:	6f 91       	pop	r22
     490:	5f 91       	pop	r21
     492:	4f 91       	pop	r20
     494:	3f 91       	pop	r19
     496:	2f 91       	pop	r18
     498:	1f 91       	pop	r17
     49a:	0f 91       	pop	r16
     49c:	ff 90       	pop	r15
     49e:	ef 90       	pop	r14
     4a0:	df 90       	pop	r13
     4a2:	cf 90       	pop	r12
     4a4:	bf 90       	pop	r11
     4a6:	af 90       	pop	r10
     4a8:	9f 90       	pop	r9
     4aa:	8f 90       	pop	r8
     4ac:	7f 90       	pop	r7
     4ae:	6f 90       	pop	r6
     4b0:	5f 90       	pop	r5
     4b2:	4f 90       	pop	r4
     4b4:	3f 90       	pop	r3
     4b6:	2f 90       	pop	r2
     4b8:	1f 90       	pop	r1
     4ba:	0f 90       	pop	r0
     4bc:	0f be       	out	0x3f, r0	; 63
     4be:	0f 90       	pop	r0

	asm volatile ( "ret" );
     4c0:	08 95       	ret

000004c2 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     4c2:	0f 92       	push	r0
     4c4:	0f b6       	in	r0, 0x3f	; 63
     4c6:	f8 94       	cli
     4c8:	0f 92       	push	r0
     4ca:	1f 92       	push	r1
     4cc:	11 24       	eor	r1, r1
     4ce:	2f 92       	push	r2
     4d0:	3f 92       	push	r3
     4d2:	4f 92       	push	r4
     4d4:	5f 92       	push	r5
     4d6:	6f 92       	push	r6
     4d8:	7f 92       	push	r7
     4da:	8f 92       	push	r8
     4dc:	9f 92       	push	r9
     4de:	af 92       	push	r10
     4e0:	bf 92       	push	r11
     4e2:	cf 92       	push	r12
     4e4:	df 92       	push	r13
     4e6:	ef 92       	push	r14
     4e8:	ff 92       	push	r15
     4ea:	0f 93       	push	r16
     4ec:	1f 93       	push	r17
     4ee:	2f 93       	push	r18
     4f0:	3f 93       	push	r19
     4f2:	4f 93       	push	r20
     4f4:	5f 93       	push	r21
     4f6:	6f 93       	push	r22
     4f8:	7f 93       	push	r23
     4fa:	8f 93       	push	r24
     4fc:	9f 93       	push	r25
     4fe:	af 93       	push	r26
     500:	bf 93       	push	r27
     502:	cf 93       	push	r28
     504:	df 93       	push	r29
     506:	ef 93       	push	r30
     508:	ff 93       	push	r31
     50a:	a0 91 ff 02 	lds	r26, 0x02FF
     50e:	b0 91 00 03 	lds	r27, 0x0300
     512:	0d b6       	in	r0, 0x3d	; 61
     514:	0d 92       	st	X+, r0
     516:	0e b6       	in	r0, 0x3e	; 62
     518:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     51a:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <vTaskIncrementTick>
	vTaskSwitchContext();
     51e:	0e 94 6a 10 	call	0x20d4	; 0x20d4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     522:	a0 91 ff 02 	lds	r26, 0x02FF
     526:	b0 91 00 03 	lds	r27, 0x0300
     52a:	cd 91       	ld	r28, X+
     52c:	cd bf       	out	0x3d, r28	; 61
     52e:	dd 91       	ld	r29, X+
     530:	de bf       	out	0x3e, r29	; 62
     532:	ff 91       	pop	r31
     534:	ef 91       	pop	r30
     536:	df 91       	pop	r29
     538:	cf 91       	pop	r28
     53a:	bf 91       	pop	r27
     53c:	af 91       	pop	r26
     53e:	9f 91       	pop	r25
     540:	8f 91       	pop	r24
     542:	7f 91       	pop	r23
     544:	6f 91       	pop	r22
     546:	5f 91       	pop	r21
     548:	4f 91       	pop	r20
     54a:	3f 91       	pop	r19
     54c:	2f 91       	pop	r18
     54e:	1f 91       	pop	r17
     550:	0f 91       	pop	r16
     552:	ff 90       	pop	r15
     554:	ef 90       	pop	r14
     556:	df 90       	pop	r13
     558:	cf 90       	pop	r12
     55a:	bf 90       	pop	r11
     55c:	af 90       	pop	r10
     55e:	9f 90       	pop	r9
     560:	8f 90       	pop	r8
     562:	7f 90       	pop	r7
     564:	6f 90       	pop	r6
     566:	5f 90       	pop	r5
     568:	4f 90       	pop	r4
     56a:	3f 90       	pop	r3
     56c:	2f 90       	pop	r2
     56e:	1f 90       	pop	r1
     570:	0f 90       	pop	r0
     572:	0f be       	out	0x3f, r0	; 63
     574:	0f 90       	pop	r0

	asm volatile ( "ret" );
     576:	08 95       	ret

00000578 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
     578:	df 93       	push	r29
     57a:	cf 93       	push	r28
     57c:	00 d0       	rcall	.+0      	; 0x57e <prvSetupTimerInterrupt+0x6>
     57e:	00 d0       	rcall	.+0      	; 0x580 <prvSetupTimerInterrupt+0x8>
     580:	00 d0       	rcall	.+0      	; 0x582 <prvSetupTimerInterrupt+0xa>
     582:	cd b7       	in	r28, 0x3d	; 61
     584:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
     586:	80 ee       	ldi	r24, 0xE0	; 224
     588:	9e e2       	ldi	r25, 0x2E	; 46
     58a:	a0 e0       	ldi	r26, 0x00	; 0
     58c:	b0 e0       	ldi	r27, 0x00	; 0
     58e:	8b 83       	std	Y+3, r24	; 0x03
     590:	9c 83       	std	Y+4, r25	; 0x04
     592:	ad 83       	std	Y+5, r26	; 0x05
     594:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
     596:	8b 81       	ldd	r24, Y+3	; 0x03
     598:	9c 81       	ldd	r25, Y+4	; 0x04
     59a:	ad 81       	ldd	r26, Y+5	; 0x05
     59c:	be 81       	ldd	r27, Y+6	; 0x06
     59e:	68 94       	set
     5a0:	15 f8       	bld	r1, 5
     5a2:	b6 95       	lsr	r27
     5a4:	a7 95       	ror	r26
     5a6:	97 95       	ror	r25
     5a8:	87 95       	ror	r24
     5aa:	16 94       	lsr	r1
     5ac:	d1 f7       	brne	.-12     	; 0x5a2 <prvSetupTimerInterrupt+0x2a>
     5ae:	8b 83       	std	Y+3, r24	; 0x03
     5b0:	9c 83       	std	Y+4, r25	; 0x04
     5b2:	ad 83       	std	Y+5, r26	; 0x05
     5b4:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
     5b6:	8b 81       	ldd	r24, Y+3	; 0x03
     5b8:	9c 81       	ldd	r25, Y+4	; 0x04
     5ba:	ad 81       	ldd	r26, Y+5	; 0x05
     5bc:	be 81       	ldd	r27, Y+6	; 0x06
     5be:	01 97       	sbiw	r24, 0x01	; 1
     5c0:	a1 09       	sbc	r26, r1
     5c2:	b1 09       	sbc	r27, r1
     5c4:	8b 83       	std	Y+3, r24	; 0x03
     5c6:	9c 83       	std	Y+4, r25	; 0x04
     5c8:	ad 83       	std	Y+5, r26	; 0x05
     5ca:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
     5cc:	8b 81       	ldd	r24, Y+3	; 0x03
     5ce:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
     5d0:	8b 81       	ldd	r24, Y+3	; 0x03
     5d2:	9c 81       	ldd	r25, Y+4	; 0x04
     5d4:	ad 81       	ldd	r26, Y+5	; 0x05
     5d6:	be 81       	ldd	r27, Y+6	; 0x06
     5d8:	89 2f       	mov	r24, r25
     5da:	9a 2f       	mov	r25, r26
     5dc:	ab 2f       	mov	r26, r27
     5de:	bb 27       	eor	r27, r27
     5e0:	8b 83       	std	Y+3, r24	; 0x03
     5e2:	9c 83       	std	Y+4, r25	; 0x04
     5e4:	ad 83       	std	Y+5, r26	; 0x05
     5e6:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
     5e8:	8b 81       	ldd	r24, Y+3	; 0x03
     5ea:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
     5ec:	eb e4       	ldi	r30, 0x4B	; 75
     5ee:	f0 e0       	ldi	r31, 0x00	; 0
     5f0:	8a 81       	ldd	r24, Y+2	; 0x02
     5f2:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
     5f4:	ea e4       	ldi	r30, 0x4A	; 74
     5f6:	f0 e0       	ldi	r31, 0x00	; 0
     5f8:	89 81       	ldd	r24, Y+1	; 0x01
     5fa:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
     5fc:	8b e0       	ldi	r24, 0x0B	; 11
     5fe:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
     600:	ee e4       	ldi	r30, 0x4E	; 78
     602:	f0 e0       	ldi	r31, 0x00	; 0
     604:	89 81       	ldd	r24, Y+1	; 0x01
     606:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     608:	e9 e5       	ldi	r30, 0x59	; 89
     60a:	f0 e0       	ldi	r31, 0x00	; 0
     60c:	80 81       	ld	r24, Z
     60e:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     610:	89 81       	ldd	r24, Y+1	; 0x01
     612:	80 61       	ori	r24, 0x10	; 16
     614:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
     616:	e9 e5       	ldi	r30, 0x59	; 89
     618:	f0 e0       	ldi	r31, 0x00	; 0
     61a:	89 81       	ldd	r24, Y+1	; 0x01
     61c:	80 83       	st	Z, r24
}
     61e:	26 96       	adiw	r28, 0x06	; 6
     620:	0f b6       	in	r0, 0x3f	; 63
     622:	f8 94       	cli
     624:	de bf       	out	0x3e, r29	; 62
     626:	0f be       	out	0x3f, r0	; 63
     628:	cd bf       	out	0x3d, r28	; 61
     62a:	cf 91       	pop	r28
     62c:	df 91       	pop	r29
     62e:	08 95       	ret

00000630 <__vector_6>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
     630:	0e 94 61 02 	call	0x4c2	; 0x4c2 <vPortYieldFromTick>
		asm volatile ( "reti" );
     634:	18 95       	reti

00000636 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     636:	df 93       	push	r29
     638:	cf 93       	push	r28
     63a:	cd b7       	in	r28, 0x3d	; 61
     63c:	de b7       	in	r29, 0x3e	; 62
     63e:	27 97       	sbiw	r28, 0x07	; 7
     640:	0f b6       	in	r0, 0x3f	; 63
     642:	f8 94       	cli
     644:	de bf       	out	0x3e, r29	; 62
     646:	0f be       	out	0x3f, r0	; 63
     648:	cd bf       	out	0x3d, r28	; 61
     64a:	9d 83       	std	Y+5, r25	; 0x05
     64c:	8c 83       	std	Y+4, r24	; 0x04
     64e:	6e 83       	std	Y+6, r22	; 0x06
     650:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     652:	8a e1       	ldi	r24, 0x1A	; 26
     654:	90 e0       	ldi	r25, 0x00	; 0
     656:	0e 94 59 07 	call	0xeb2	; 0xeb2 <pvPortMalloc>
     65a:	9a 83       	std	Y+2, r25	; 0x02
     65c:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
     65e:	89 81       	ldd	r24, Y+1	; 0x01
     660:	9a 81       	ldd	r25, Y+2	; 0x02
     662:	00 97       	sbiw	r24, 0x00	; 0
     664:	09 f4       	brne	.+2      	; 0x668 <xCoRoutineCreate+0x32>
     666:	6e c0       	rjmp	.+220    	; 0x744 <xCoRoutineCreate+0x10e>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     668:	80 91 74 00 	lds	r24, 0x0074
     66c:	90 91 75 00 	lds	r25, 0x0075
     670:	00 97       	sbiw	r24, 0x00	; 0
     672:	41 f4       	brne	.+16     	; 0x684 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     674:	89 81       	ldd	r24, Y+1	; 0x01
     676:	9a 81       	ldd	r25, Y+2	; 0x02
     678:	90 93 75 00 	sts	0x0075, r25
     67c:	80 93 74 00 	sts	0x0074, r24
			prvInitialiseCoRoutineLists();
     680:	0e 94 9d 05 	call	0xb3a	; 0xb3a <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     684:	8e 81       	ldd	r24, Y+6	; 0x06
     686:	88 23       	and	r24, r24
     688:	09 f0       	breq	.+2      	; 0x68c <xCoRoutineCreate+0x56>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     68a:	1e 82       	std	Y+6, r1	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     68c:	e9 81       	ldd	r30, Y+1	; 0x01
     68e:	fa 81       	ldd	r31, Y+2	; 0x02
     690:	11 8e       	std	Z+25, r1	; 0x19
     692:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     694:	e9 81       	ldd	r30, Y+1	; 0x01
     696:	fa 81       	ldd	r31, Y+2	; 0x02
     698:	8e 81       	ldd	r24, Y+6	; 0x06
     69a:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     69c:	e9 81       	ldd	r30, Y+1	; 0x01
     69e:	fa 81       	ldd	r31, Y+2	; 0x02
     6a0:	8f 81       	ldd	r24, Y+7	; 0x07
     6a2:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     6a4:	e9 81       	ldd	r30, Y+1	; 0x01
     6a6:	fa 81       	ldd	r31, Y+2	; 0x02
     6a8:	8c 81       	ldd	r24, Y+4	; 0x04
     6aa:	9d 81       	ldd	r25, Y+5	; 0x05
     6ac:	91 83       	std	Z+1, r25	; 0x01
     6ae:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     6b0:	89 81       	ldd	r24, Y+1	; 0x01
     6b2:	9a 81       	ldd	r25, Y+2	; 0x02
     6b4:	02 96       	adiw	r24, 0x02	; 2
     6b6:	0e 94 48 06 	call	0xc90	; 0xc90 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     6ba:	89 81       	ldd	r24, Y+1	; 0x01
     6bc:	9a 81       	ldd	r25, Y+2	; 0x02
     6be:	0c 96       	adiw	r24, 0x0c	; 12
     6c0:	0e 94 48 06 	call	0xc90	; 0xc90 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     6c4:	e9 81       	ldd	r30, Y+1	; 0x01
     6c6:	fa 81       	ldd	r31, Y+2	; 0x02
     6c8:	89 81       	ldd	r24, Y+1	; 0x01
     6ca:	9a 81       	ldd	r25, Y+2	; 0x02
     6cc:	91 87       	std	Z+9, r25	; 0x09
     6ce:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     6d0:	e9 81       	ldd	r30, Y+1	; 0x01
     6d2:	fa 81       	ldd	r31, Y+2	; 0x02
     6d4:	89 81       	ldd	r24, Y+1	; 0x01
     6d6:	9a 81       	ldd	r25, Y+2	; 0x02
     6d8:	93 8b       	std	Z+19, r25	; 0x13
     6da:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     6dc:	8e 81       	ldd	r24, Y+6	; 0x06
     6de:	28 2f       	mov	r18, r24
     6e0:	30 e0       	ldi	r19, 0x00	; 0
     6e2:	81 e0       	ldi	r24, 0x01	; 1
     6e4:	90 e0       	ldi	r25, 0x00	; 0
     6e6:	82 1b       	sub	r24, r18
     6e8:	93 0b       	sbc	r25, r19
     6ea:	e9 81       	ldd	r30, Y+1	; 0x01
     6ec:	fa 81       	ldd	r31, Y+2	; 0x02
     6ee:	95 87       	std	Z+13, r25	; 0x0d
     6f0:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     6f2:	e9 81       	ldd	r30, Y+1	; 0x01
     6f4:	fa 81       	ldd	r31, Y+2	; 0x02
     6f6:	96 89       	ldd	r25, Z+22	; 0x16
     6f8:	80 91 76 00 	lds	r24, 0x0076
     6fc:	89 17       	cp	r24, r25
     6fe:	28 f4       	brcc	.+10     	; 0x70a <xCoRoutineCreate+0xd4>
     700:	e9 81       	ldd	r30, Y+1	; 0x01
     702:	fa 81       	ldd	r31, Y+2	; 0x02
     704:	86 89       	ldd	r24, Z+22	; 0x16
     706:	80 93 76 00 	sts	0x0076, r24
     70a:	e9 81       	ldd	r30, Y+1	; 0x01
     70c:	fa 81       	ldd	r31, Y+2	; 0x02
     70e:	86 89       	ldd	r24, Z+22	; 0x16
     710:	28 2f       	mov	r18, r24
     712:	30 e0       	ldi	r19, 0x00	; 0
     714:	c9 01       	movw	r24, r18
     716:	88 0f       	add	r24, r24
     718:	99 1f       	adc	r25, r25
     71a:	88 0f       	add	r24, r24
     71c:	99 1f       	adc	r25, r25
     71e:	88 0f       	add	r24, r24
     720:	99 1f       	adc	r25, r25
     722:	82 0f       	add	r24, r18
     724:	93 1f       	adc	r25, r19
     726:	ac 01       	movw	r20, r24
     728:	43 58       	subi	r20, 0x83	; 131
     72a:	5f 4f       	sbci	r21, 0xFF	; 255
     72c:	89 81       	ldd	r24, Y+1	; 0x01
     72e:	9a 81       	ldd	r25, Y+2	; 0x02
     730:	9c 01       	movw	r18, r24
     732:	2e 5f       	subi	r18, 0xFE	; 254
     734:	3f 4f       	sbci	r19, 0xFF	; 255
     736:	ca 01       	movw	r24, r20
     738:	b9 01       	movw	r22, r18
     73a:	0e 94 58 06 	call	0xcb0	; 0xcb0 <vListInsertEnd>

		xReturn = pdPASS;
     73e:	81 e0       	ldi	r24, 0x01	; 1
     740:	8b 83       	std	Y+3, r24	; 0x03
     742:	02 c0       	rjmp	.+4      	; 0x748 <xCoRoutineCreate+0x112>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     744:	8f ef       	ldi	r24, 0xFF	; 255
     746:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
     748:	8b 81       	ldd	r24, Y+3	; 0x03
}
     74a:	27 96       	adiw	r28, 0x07	; 7
     74c:	0f b6       	in	r0, 0x3f	; 63
     74e:	f8 94       	cli
     750:	de bf       	out	0x3e, r29	; 62
     752:	0f be       	out	0x3f, r0	; 63
     754:	cd bf       	out	0x3d, r28	; 61
     756:	cf 91       	pop	r28
     758:	df 91       	pop	r29
     75a:	08 95       	ret

0000075c <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     75c:	df 93       	push	r29
     75e:	cf 93       	push	r28
     760:	00 d0       	rcall	.+0      	; 0x762 <vCoRoutineAddToDelayedList+0x6>
     762:	00 d0       	rcall	.+0      	; 0x764 <vCoRoutineAddToDelayedList+0x8>
     764:	00 d0       	rcall	.+0      	; 0x766 <vCoRoutineAddToDelayedList+0xa>
     766:	cd b7       	in	r28, 0x3d	; 61
     768:	de b7       	in	r29, 0x3e	; 62
     76a:	9c 83       	std	Y+4, r25	; 0x04
     76c:	8b 83       	std	Y+3, r24	; 0x03
     76e:	7e 83       	std	Y+6, r23	; 0x06
     770:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     772:	20 91 77 00 	lds	r18, 0x0077
     776:	30 91 78 00 	lds	r19, 0x0078
     77a:	8b 81       	ldd	r24, Y+3	; 0x03
     77c:	9c 81       	ldd	r25, Y+4	; 0x04
     77e:	82 0f       	add	r24, r18
     780:	93 1f       	adc	r25, r19
     782:	9a 83       	std	Y+2, r25	; 0x02
     784:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     786:	80 91 74 00 	lds	r24, 0x0074
     78a:	90 91 75 00 	lds	r25, 0x0075
     78e:	02 96       	adiw	r24, 0x02	; 2
     790:	0e 94 10 07 	call	0xe20	; 0xe20 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     794:	e0 91 74 00 	lds	r30, 0x0074
     798:	f0 91 75 00 	lds	r31, 0x0075
     79c:	89 81       	ldd	r24, Y+1	; 0x01
     79e:	9a 81       	ldd	r25, Y+2	; 0x02
     7a0:	93 83       	std	Z+3, r25	; 0x03
     7a2:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     7a4:	20 91 77 00 	lds	r18, 0x0077
     7a8:	30 91 78 00 	lds	r19, 0x0078
     7ac:	89 81       	ldd	r24, Y+1	; 0x01
     7ae:	9a 81       	ldd	r25, Y+2	; 0x02
     7b0:	82 17       	cp	r24, r18
     7b2:	93 07       	cpc	r25, r19
     7b4:	70 f4       	brcc	.+28     	; 0x7d2 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     7b6:	80 91 9a 00 	lds	r24, 0x009A
     7ba:	90 91 9b 00 	lds	r25, 0x009B
     7be:	20 91 74 00 	lds	r18, 0x0074
     7c2:	30 91 75 00 	lds	r19, 0x0075
     7c6:	2e 5f       	subi	r18, 0xFE	; 254
     7c8:	3f 4f       	sbci	r19, 0xFF	; 255
     7ca:	b9 01       	movw	r22, r18
     7cc:	0e 94 a4 06 	call	0xd48	; 0xd48 <vListInsert>
     7d0:	0d c0       	rjmp	.+26     	; 0x7ec <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     7d2:	80 91 98 00 	lds	r24, 0x0098
     7d6:	90 91 99 00 	lds	r25, 0x0099
     7da:	20 91 74 00 	lds	r18, 0x0074
     7de:	30 91 75 00 	lds	r19, 0x0075
     7e2:	2e 5f       	subi	r18, 0xFE	; 254
     7e4:	3f 4f       	sbci	r19, 0xFF	; 255
     7e6:	b9 01       	movw	r22, r18
     7e8:	0e 94 a4 06 	call	0xd48	; 0xd48 <vListInsert>
	}

	if( pxEventList )
     7ec:	8d 81       	ldd	r24, Y+5	; 0x05
     7ee:	9e 81       	ldd	r25, Y+6	; 0x06
     7f0:	00 97       	sbiw	r24, 0x00	; 0
     7f2:	61 f0       	breq	.+24     	; 0x80c <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     7f4:	80 91 74 00 	lds	r24, 0x0074
     7f8:	90 91 75 00 	lds	r25, 0x0075
     7fc:	9c 01       	movw	r18, r24
     7fe:	24 5f       	subi	r18, 0xF4	; 244
     800:	3f 4f       	sbci	r19, 0xFF	; 255
     802:	8d 81       	ldd	r24, Y+5	; 0x05
     804:	9e 81       	ldd	r25, Y+6	; 0x06
     806:	b9 01       	movw	r22, r18
     808:	0e 94 a4 06 	call	0xd48	; 0xd48 <vListInsert>
	}
}
     80c:	26 96       	adiw	r28, 0x06	; 6
     80e:	0f b6       	in	r0, 0x3f	; 63
     810:	f8 94       	cli
     812:	de bf       	out	0x3e, r29	; 62
     814:	0f be       	out	0x3f, r0	; 63
     816:	cd bf       	out	0x3d, r28	; 61
     818:	cf 91       	pop	r28
     81a:	df 91       	pop	r29
     81c:	08 95       	ret

0000081e <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
     81e:	df 93       	push	r29
     820:	cf 93       	push	r28
     822:	00 d0       	rcall	.+0      	; 0x824 <prvCheckPendingReadyList+0x6>
     824:	00 d0       	rcall	.+0      	; 0x826 <prvCheckPendingReadyList+0x8>
     826:	cd b7       	in	r28, 0x3d	; 61
     828:	de b7       	in	r29, 0x3e	; 62
     82a:	45 c0       	rjmp	.+138    	; 0x8b6 <prvCheckPendingReadyList+0x98>
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     82c:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     82e:	80 91 9c 00 	lds	r24, 0x009C
     832:	88 23       	and	r24, r24
     834:	49 f0       	breq	.+18     	; 0x848 <prvCheckPendingReadyList+0x2a>
     836:	e0 91 a1 00 	lds	r30, 0x00A1
     83a:	f0 91 a2 00 	lds	r31, 0x00A2
     83e:	86 81       	ldd	r24, Z+6	; 0x06
     840:	97 81       	ldd	r25, Z+7	; 0x07
     842:	9c 83       	std	Y+4, r25	; 0x04
     844:	8b 83       	std	Y+3, r24	; 0x03
     846:	02 c0       	rjmp	.+4      	; 0x84c <prvCheckPendingReadyList+0x2e>
     848:	1c 82       	std	Y+4, r1	; 0x04
     84a:	1b 82       	std	Y+3, r1	; 0x03
     84c:	8b 81       	ldd	r24, Y+3	; 0x03
     84e:	9c 81       	ldd	r25, Y+4	; 0x04
     850:	9a 83       	std	Y+2, r25	; 0x02
     852:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     854:	89 81       	ldd	r24, Y+1	; 0x01
     856:	9a 81       	ldd	r25, Y+2	; 0x02
     858:	0c 96       	adiw	r24, 0x0c	; 12
     85a:	0e 94 10 07 	call	0xe20	; 0xe20 <vListRemove>
		}
		portENABLE_INTERRUPTS();
     85e:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     860:	89 81       	ldd	r24, Y+1	; 0x01
     862:	9a 81       	ldd	r25, Y+2	; 0x02
     864:	02 96       	adiw	r24, 0x02	; 2
     866:	0e 94 10 07 	call	0xe20	; 0xe20 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     86a:	e9 81       	ldd	r30, Y+1	; 0x01
     86c:	fa 81       	ldd	r31, Y+2	; 0x02
     86e:	96 89       	ldd	r25, Z+22	; 0x16
     870:	80 91 76 00 	lds	r24, 0x0076
     874:	89 17       	cp	r24, r25
     876:	28 f4       	brcc	.+10     	; 0x882 <prvCheckPendingReadyList+0x64>
     878:	e9 81       	ldd	r30, Y+1	; 0x01
     87a:	fa 81       	ldd	r31, Y+2	; 0x02
     87c:	86 89       	ldd	r24, Z+22	; 0x16
     87e:	80 93 76 00 	sts	0x0076, r24
     882:	e9 81       	ldd	r30, Y+1	; 0x01
     884:	fa 81       	ldd	r31, Y+2	; 0x02
     886:	86 89       	ldd	r24, Z+22	; 0x16
     888:	28 2f       	mov	r18, r24
     88a:	30 e0       	ldi	r19, 0x00	; 0
     88c:	c9 01       	movw	r24, r18
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	88 0f       	add	r24, r24
     894:	99 1f       	adc	r25, r25
     896:	88 0f       	add	r24, r24
     898:	99 1f       	adc	r25, r25
     89a:	82 0f       	add	r24, r18
     89c:	93 1f       	adc	r25, r19
     89e:	ac 01       	movw	r20, r24
     8a0:	43 58       	subi	r20, 0x83	; 131
     8a2:	5f 4f       	sbci	r21, 0xFF	; 255
     8a4:	89 81       	ldd	r24, Y+1	; 0x01
     8a6:	9a 81       	ldd	r25, Y+2	; 0x02
     8a8:	9c 01       	movw	r18, r24
     8aa:	2e 5f       	subi	r18, 0xFE	; 254
     8ac:	3f 4f       	sbci	r19, 0xFF	; 255
     8ae:	ca 01       	movw	r24, r20
     8b0:	b9 01       	movw	r22, r18
     8b2:	0e 94 58 06 	call	0xcb0	; 0xcb0 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( !listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) )
     8b6:	80 91 9c 00 	lds	r24, 0x009C
     8ba:	88 23       	and	r24, r24
     8bc:	09 f0       	breq	.+2      	; 0x8c0 <prvCheckPendingReadyList+0xa2>
     8be:	b6 cf       	rjmp	.-148    	; 0x82c <prvCheckPendingReadyList+0xe>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
     8c0:	0f 90       	pop	r0
     8c2:	0f 90       	pop	r0
     8c4:	0f 90       	pop	r0
     8c6:	0f 90       	pop	r0
     8c8:	cf 91       	pop	r28
     8ca:	df 91       	pop	r29
     8cc:	08 95       	ret

000008ce <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
     8ce:	df 93       	push	r29
     8d0:	cf 93       	push	r28
     8d2:	00 d0       	rcall	.+0      	; 0x8d4 <prvCheckDelayedList+0x6>
     8d4:	00 d0       	rcall	.+0      	; 0x8d6 <prvCheckDelayedList+0x8>
     8d6:	00 d0       	rcall	.+0      	; 0x8d8 <prvCheckDelayedList+0xa>
     8d8:	cd b7       	in	r28, 0x3d	; 61
     8da:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     8dc:	0e 94 a8 0f 	call	0x1f50	; 0x1f50 <xTaskGetTickCount>
     8e0:	20 91 79 00 	lds	r18, 0x0079
     8e4:	30 91 7a 00 	lds	r19, 0x007A
     8e8:	82 1b       	sub	r24, r18
     8ea:	93 0b       	sbc	r25, r19
     8ec:	90 93 7c 00 	sts	0x007C, r25
     8f0:	80 93 7b 00 	sts	0x007B, r24
     8f4:	90 c0       	rjmp	.+288    	; 0xa16 <prvCheckDelayedList+0x148>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     8f6:	80 91 77 00 	lds	r24, 0x0077
     8fa:	90 91 78 00 	lds	r25, 0x0078
     8fe:	01 96       	adiw	r24, 0x01	; 1
     900:	90 93 78 00 	sts	0x0078, r25
     904:	80 93 77 00 	sts	0x0077, r24
		xPassedTicks--;
     908:	80 91 7b 00 	lds	r24, 0x007B
     90c:	90 91 7c 00 	lds	r25, 0x007C
     910:	01 97       	sbiw	r24, 0x01	; 1
     912:	90 93 7c 00 	sts	0x007C, r25
     916:	80 93 7b 00 	sts	0x007B, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     91a:	80 91 77 00 	lds	r24, 0x0077
     91e:	90 91 78 00 	lds	r25, 0x0078
     922:	00 97       	sbiw	r24, 0x00	; 0
     924:	09 f0       	breq	.+2      	; 0x928 <prvCheckDelayedList+0x5a>
     926:	59 c0       	rjmp	.+178    	; 0x9da <prvCheckDelayedList+0x10c>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     928:	80 91 98 00 	lds	r24, 0x0098
     92c:	90 91 99 00 	lds	r25, 0x0099
     930:	9a 83       	std	Y+2, r25	; 0x02
     932:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     934:	80 91 9a 00 	lds	r24, 0x009A
     938:	90 91 9b 00 	lds	r25, 0x009B
     93c:	90 93 99 00 	sts	0x0099, r25
     940:	80 93 98 00 	sts	0x0098, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
     944:	89 81       	ldd	r24, Y+1	; 0x01
     946:	9a 81       	ldd	r25, Y+2	; 0x02
     948:	90 93 9b 00 	sts	0x009B, r25
     94c:	80 93 9a 00 	sts	0x009A, r24
     950:	44 c0       	rjmp	.+136    	; 0x9da <prvCheckDelayedList+0x10c>
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
		{	
			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     952:	eb 81       	ldd	r30, Y+3	; 0x03
     954:	fc 81       	ldd	r31, Y+4	; 0x04
     956:	22 81       	ldd	r18, Z+2	; 0x02
     958:	33 81       	ldd	r19, Z+3	; 0x03
     95a:	80 91 77 00 	lds	r24, 0x0077
     95e:	90 91 78 00 	lds	r25, 0x0078
     962:	82 17       	cp	r24, r18
     964:	93 07       	cpc	r25, r19
     966:	08 f4       	brcc	.+2      	; 0x96a <prvCheckDelayedList+0x9c>
     968:	56 c0       	rjmp	.+172    	; 0xa16 <prvCheckDelayedList+0x148>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     96a:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
     96c:	8b 81       	ldd	r24, Y+3	; 0x03
     96e:	9c 81       	ldd	r25, Y+4	; 0x04
     970:	02 96       	adiw	r24, 0x02	; 2
     972:	0e 94 10 07 	call	0xe20	; 0xe20 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     976:	eb 81       	ldd	r30, Y+3	; 0x03
     978:	fc 81       	ldd	r31, Y+4	; 0x04
     97a:	84 89       	ldd	r24, Z+20	; 0x14
     97c:	95 89       	ldd	r25, Z+21	; 0x15
     97e:	00 97       	sbiw	r24, 0x00	; 0
     980:	29 f0       	breq	.+10     	; 0x98c <prvCheckDelayedList+0xbe>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
     982:	8b 81       	ldd	r24, Y+3	; 0x03
     984:	9c 81       	ldd	r25, Y+4	; 0x04
     986:	0c 96       	adiw	r24, 0x0c	; 12
     988:	0e 94 10 07 	call	0xe20	; 0xe20 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     98c:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     98e:	eb 81       	ldd	r30, Y+3	; 0x03
     990:	fc 81       	ldd	r31, Y+4	; 0x04
     992:	96 89       	ldd	r25, Z+22	; 0x16
     994:	80 91 76 00 	lds	r24, 0x0076
     998:	89 17       	cp	r24, r25
     99a:	28 f4       	brcc	.+10     	; 0x9a6 <prvCheckDelayedList+0xd8>
     99c:	eb 81       	ldd	r30, Y+3	; 0x03
     99e:	fc 81       	ldd	r31, Y+4	; 0x04
     9a0:	86 89       	ldd	r24, Z+22	; 0x16
     9a2:	80 93 76 00 	sts	0x0076, r24
     9a6:	eb 81       	ldd	r30, Y+3	; 0x03
     9a8:	fc 81       	ldd	r31, Y+4	; 0x04
     9aa:	86 89       	ldd	r24, Z+22	; 0x16
     9ac:	28 2f       	mov	r18, r24
     9ae:	30 e0       	ldi	r19, 0x00	; 0
     9b0:	c9 01       	movw	r24, r18
     9b2:	88 0f       	add	r24, r24
     9b4:	99 1f       	adc	r25, r25
     9b6:	88 0f       	add	r24, r24
     9b8:	99 1f       	adc	r25, r25
     9ba:	88 0f       	add	r24, r24
     9bc:	99 1f       	adc	r25, r25
     9be:	82 0f       	add	r24, r18
     9c0:	93 1f       	adc	r25, r19
     9c2:	ac 01       	movw	r20, r24
     9c4:	43 58       	subi	r20, 0x83	; 131
     9c6:	5f 4f       	sbci	r21, 0xFF	; 255
     9c8:	8b 81       	ldd	r24, Y+3	; 0x03
     9ca:	9c 81       	ldd	r25, Y+4	; 0x04
     9cc:	9c 01       	movw	r18, r24
     9ce:	2e 5f       	subi	r18, 0xFE	; 254
     9d0:	3f 4f       	sbci	r19, 0xFF	; 255
     9d2:	ca 01       	movw	r24, r20
     9d4:	b9 01       	movw	r22, r18
     9d6:	0e 94 58 06 	call	0xcb0	; 0xcb0 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( ( pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList ) ) != NULL )
     9da:	e0 91 98 00 	lds	r30, 0x0098
     9de:	f0 91 99 00 	lds	r31, 0x0099
     9e2:	80 81       	ld	r24, Z
     9e4:	88 23       	and	r24, r24
     9e6:	61 f0       	breq	.+24     	; 0xa00 <prvCheckDelayedList+0x132>
     9e8:	e0 91 98 00 	lds	r30, 0x0098
     9ec:	f0 91 99 00 	lds	r31, 0x0099
     9f0:	05 80       	ldd	r0, Z+5	; 0x05
     9f2:	f6 81       	ldd	r31, Z+6	; 0x06
     9f4:	e0 2d       	mov	r30, r0
     9f6:	86 81       	ldd	r24, Z+6	; 0x06
     9f8:	97 81       	ldd	r25, Z+7	; 0x07
     9fa:	9e 83       	std	Y+6, r25	; 0x06
     9fc:	8d 83       	std	Y+5, r24	; 0x05
     9fe:	02 c0       	rjmp	.+4      	; 0xa04 <prvCheckDelayedList+0x136>
     a00:	1e 82       	std	Y+6, r1	; 0x06
     a02:	1d 82       	std	Y+5, r1	; 0x05
     a04:	8d 81       	ldd	r24, Y+5	; 0x05
     a06:	9e 81       	ldd	r25, Y+6	; 0x06
     a08:	9c 83       	std	Y+4, r25	; 0x04
     a0a:	8b 83       	std	Y+3, r24	; 0x03
     a0c:	8b 81       	ldd	r24, Y+3	; 0x03
     a0e:	9c 81       	ldd	r25, Y+4	; 0x04
     a10:	00 97       	sbiw	r24, 0x00	; 0
     a12:	09 f0       	breq	.+2      	; 0xa16 <prvCheckDelayedList+0x148>
     a14:	9e cf       	rjmp	.-196    	; 0x952 <prvCheckDelayedList+0x84>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     a16:	80 91 7b 00 	lds	r24, 0x007B
     a1a:	90 91 7c 00 	lds	r25, 0x007C
     a1e:	00 97       	sbiw	r24, 0x00	; 0
     a20:	09 f0       	breq	.+2      	; 0xa24 <prvCheckDelayedList+0x156>
     a22:	69 cf       	rjmp	.-302    	; 0x8f6 <prvCheckDelayedList+0x28>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     a24:	80 91 77 00 	lds	r24, 0x0077
     a28:	90 91 78 00 	lds	r25, 0x0078
     a2c:	90 93 7a 00 	sts	0x007A, r25
     a30:	80 93 79 00 	sts	0x0079, r24
}
     a34:	26 96       	adiw	r28, 0x06	; 6
     a36:	0f b6       	in	r0, 0x3f	; 63
     a38:	f8 94       	cli
     a3a:	de bf       	out	0x3e, r29	; 62
     a3c:	0f be       	out	0x3f, r0	; 63
     a3e:	cd bf       	out	0x3d, r28	; 61
     a40:	cf 91       	pop	r28
     a42:	df 91       	pop	r29
     a44:	08 95       	ret

00000a46 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     a46:	df 93       	push	r29
     a48:	cf 93       	push	r28
     a4a:	00 d0       	rcall	.+0      	; 0xa4c <vCoRoutineSchedule+0x6>
     a4c:	cd b7       	in	r28, 0x3d	; 61
     a4e:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
     a50:	0e 94 0f 04 	call	0x81e	; 0x81e <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
     a54:	0e 94 67 04 	call	0x8ce	; 0x8ce <prvCheckDelayedList>
     a58:	0a c0       	rjmp	.+20     	; 0xa6e <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     a5a:	80 91 76 00 	lds	r24, 0x0076
     a5e:	88 23       	and	r24, r24
     a60:	09 f4       	brne	.+2      	; 0xa64 <vCoRoutineSchedule+0x1e>
     a62:	66 c0       	rjmp	.+204    	; 0xb30 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     a64:	80 91 76 00 	lds	r24, 0x0076
     a68:	81 50       	subi	r24, 0x01	; 1
     a6a:	80 93 76 00 	sts	0x0076, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     a6e:	80 91 76 00 	lds	r24, 0x0076
     a72:	28 2f       	mov	r18, r24
     a74:	30 e0       	ldi	r19, 0x00	; 0
     a76:	c9 01       	movw	r24, r18
     a78:	88 0f       	add	r24, r24
     a7a:	99 1f       	adc	r25, r25
     a7c:	88 0f       	add	r24, r24
     a7e:	99 1f       	adc	r25, r25
     a80:	88 0f       	add	r24, r24
     a82:	99 1f       	adc	r25, r25
     a84:	82 0f       	add	r24, r18
     a86:	93 1f       	adc	r25, r19
     a88:	fc 01       	movw	r30, r24
     a8a:	e3 58       	subi	r30, 0x83	; 131
     a8c:	ff 4f       	sbci	r31, 0xFF	; 255
     a8e:	80 81       	ld	r24, Z
     a90:	88 23       	and	r24, r24
     a92:	19 f3       	breq	.-58     	; 0xa5a <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     a94:	80 91 76 00 	lds	r24, 0x0076
     a98:	28 2f       	mov	r18, r24
     a9a:	30 e0       	ldi	r19, 0x00	; 0
     a9c:	c9 01       	movw	r24, r18
     a9e:	88 0f       	add	r24, r24
     aa0:	99 1f       	adc	r25, r25
     aa2:	88 0f       	add	r24, r24
     aa4:	99 1f       	adc	r25, r25
     aa6:	88 0f       	add	r24, r24
     aa8:	99 1f       	adc	r25, r25
     aaa:	82 0f       	add	r24, r18
     aac:	93 1f       	adc	r25, r19
     aae:	83 58       	subi	r24, 0x83	; 131
     ab0:	9f 4f       	sbci	r25, 0xFF	; 255
     ab2:	9a 83       	std	Y+2, r25	; 0x02
     ab4:	89 83       	std	Y+1, r24	; 0x01
     ab6:	e9 81       	ldd	r30, Y+1	; 0x01
     ab8:	fa 81       	ldd	r31, Y+2	; 0x02
     aba:	01 80       	ldd	r0, Z+1	; 0x01
     abc:	f2 81       	ldd	r31, Z+2	; 0x02
     abe:	e0 2d       	mov	r30, r0
     ac0:	82 81       	ldd	r24, Z+2	; 0x02
     ac2:	93 81       	ldd	r25, Z+3	; 0x03
     ac4:	e9 81       	ldd	r30, Y+1	; 0x01
     ac6:	fa 81       	ldd	r31, Y+2	; 0x02
     ac8:	92 83       	std	Z+2, r25	; 0x02
     aca:	81 83       	std	Z+1, r24	; 0x01
     acc:	e9 81       	ldd	r30, Y+1	; 0x01
     ace:	fa 81       	ldd	r31, Y+2	; 0x02
     ad0:	21 81       	ldd	r18, Z+1	; 0x01
     ad2:	32 81       	ldd	r19, Z+2	; 0x02
     ad4:	89 81       	ldd	r24, Y+1	; 0x01
     ad6:	9a 81       	ldd	r25, Y+2	; 0x02
     ad8:	03 96       	adiw	r24, 0x03	; 3
     ada:	28 17       	cp	r18, r24
     adc:	39 07       	cpc	r19, r25
     ade:	59 f4       	brne	.+22     	; 0xaf6 <vCoRoutineSchedule+0xb0>
     ae0:	e9 81       	ldd	r30, Y+1	; 0x01
     ae2:	fa 81       	ldd	r31, Y+2	; 0x02
     ae4:	01 80       	ldd	r0, Z+1	; 0x01
     ae6:	f2 81       	ldd	r31, Z+2	; 0x02
     ae8:	e0 2d       	mov	r30, r0
     aea:	82 81       	ldd	r24, Z+2	; 0x02
     aec:	93 81       	ldd	r25, Z+3	; 0x03
     aee:	e9 81       	ldd	r30, Y+1	; 0x01
     af0:	fa 81       	ldd	r31, Y+2	; 0x02
     af2:	92 83       	std	Z+2, r25	; 0x02
     af4:	81 83       	std	Z+1, r24	; 0x01
     af6:	e9 81       	ldd	r30, Y+1	; 0x01
     af8:	fa 81       	ldd	r31, Y+2	; 0x02
     afa:	01 80       	ldd	r0, Z+1	; 0x01
     afc:	f2 81       	ldd	r31, Z+2	; 0x02
     afe:	e0 2d       	mov	r30, r0
     b00:	86 81       	ldd	r24, Z+6	; 0x06
     b02:	97 81       	ldd	r25, Z+7	; 0x07
     b04:	90 93 75 00 	sts	0x0075, r25
     b08:	80 93 74 00 	sts	0x0074, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     b0c:	e0 91 74 00 	lds	r30, 0x0074
     b10:	f0 91 75 00 	lds	r31, 0x0075
     b14:	40 81       	ld	r20, Z
     b16:	51 81       	ldd	r21, Z+1	; 0x01
     b18:	80 91 74 00 	lds	r24, 0x0074
     b1c:	90 91 75 00 	lds	r25, 0x0075
     b20:	e0 91 74 00 	lds	r30, 0x0074
     b24:	f0 91 75 00 	lds	r31, 0x0075
     b28:	27 89       	ldd	r18, Z+23	; 0x17
     b2a:	62 2f       	mov	r22, r18
     b2c:	fa 01       	movw	r30, r20
     b2e:	09 95       	icall

	return;
}
     b30:	0f 90       	pop	r0
     b32:	0f 90       	pop	r0
     b34:	cf 91       	pop	r28
     b36:	df 91       	pop	r29
     b38:	08 95       	ret

00000b3a <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
     b3a:	df 93       	push	r29
     b3c:	cf 93       	push	r28
     b3e:	0f 92       	push	r0
     b40:	cd b7       	in	r28, 0x3d	; 61
     b42:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     b44:	19 82       	std	Y+1, r1	; 0x01
     b46:	13 c0       	rjmp	.+38     	; 0xb6e <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     b48:	89 81       	ldd	r24, Y+1	; 0x01
     b4a:	28 2f       	mov	r18, r24
     b4c:	30 e0       	ldi	r19, 0x00	; 0
     b4e:	c9 01       	movw	r24, r18
     b50:	88 0f       	add	r24, r24
     b52:	99 1f       	adc	r25, r25
     b54:	88 0f       	add	r24, r24
     b56:	99 1f       	adc	r25, r25
     b58:	88 0f       	add	r24, r24
     b5a:	99 1f       	adc	r25, r25
     b5c:	82 0f       	add	r24, r18
     b5e:	93 1f       	adc	r25, r19
     b60:	83 58       	subi	r24, 0x83	; 131
     b62:	9f 4f       	sbci	r25, 0xFF	; 255
     b64:	0e 94 1e 06 	call	0xc3c	; 0xc3c <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     b68:	89 81       	ldd	r24, Y+1	; 0x01
     b6a:	8f 5f       	subi	r24, 0xFF	; 255
     b6c:	89 83       	std	Y+1, r24	; 0x01
     b6e:	89 81       	ldd	r24, Y+1	; 0x01
     b70:	88 23       	and	r24, r24
     b72:	51 f3       	breq	.-44     	; 0xb48 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
     b74:	86 e8       	ldi	r24, 0x86	; 134
     b76:	90 e0       	ldi	r25, 0x00	; 0
     b78:	0e 94 1e 06 	call	0xc3c	; 0xc3c <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
     b7c:	8f e8       	ldi	r24, 0x8F	; 143
     b7e:	90 e0       	ldi	r25, 0x00	; 0
     b80:	0e 94 1e 06 	call	0xc3c	; 0xc3c <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
     b84:	8c e9       	ldi	r24, 0x9C	; 156
     b86:	90 e0       	ldi	r25, 0x00	; 0
     b88:	0e 94 1e 06 	call	0xc3c	; 0xc3c <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     b8c:	86 e8       	ldi	r24, 0x86	; 134
     b8e:	90 e0       	ldi	r25, 0x00	; 0
     b90:	90 93 99 00 	sts	0x0099, r25
     b94:	80 93 98 00 	sts	0x0098, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     b98:	8f e8       	ldi	r24, 0x8F	; 143
     b9a:	90 e0       	ldi	r25, 0x00	; 0
     b9c:	90 93 9b 00 	sts	0x009B, r25
     ba0:	80 93 9a 00 	sts	0x009A, r24
}
     ba4:	0f 90       	pop	r0
     ba6:	cf 91       	pop	r28
     ba8:	df 91       	pop	r29
     baa:	08 95       	ret

00000bac <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     bac:	df 93       	push	r29
     bae:	cf 93       	push	r28
     bb0:	cd b7       	in	r28, 0x3d	; 61
     bb2:	de b7       	in	r29, 0x3e	; 62
     bb4:	27 97       	sbiw	r28, 0x07	; 7
     bb6:	0f b6       	in	r0, 0x3f	; 63
     bb8:	f8 94       	cli
     bba:	de bf       	out	0x3e, r29	; 62
     bbc:	0f be       	out	0x3f, r0	; 63
     bbe:	cd bf       	out	0x3d, r28	; 61
     bc0:	9d 83       	std	Y+5, r25	; 0x05
     bc2:	8c 83       	std	Y+4, r24	; 0x04
corCRCB *pxUnblockedCRCB;
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     bc4:	ec 81       	ldd	r30, Y+4	; 0x04
     bc6:	fd 81       	ldd	r31, Y+5	; 0x05
     bc8:	80 81       	ld	r24, Z
     bca:	88 23       	and	r24, r24
     bcc:	51 f0       	breq	.+20     	; 0xbe2 <xCoRoutineRemoveFromEventList+0x36>
     bce:	ec 81       	ldd	r30, Y+4	; 0x04
     bd0:	fd 81       	ldd	r31, Y+5	; 0x05
     bd2:	05 80       	ldd	r0, Z+5	; 0x05
     bd4:	f6 81       	ldd	r31, Z+6	; 0x06
     bd6:	e0 2d       	mov	r30, r0
     bd8:	86 81       	ldd	r24, Z+6	; 0x06
     bda:	97 81       	ldd	r25, Z+7	; 0x07
     bdc:	9f 83       	std	Y+7, r25	; 0x07
     bde:	8e 83       	std	Y+6, r24	; 0x06
     be0:	02 c0       	rjmp	.+4      	; 0xbe6 <xCoRoutineRemoveFromEventList+0x3a>
     be2:	1f 82       	std	Y+7, r1	; 0x07
     be4:	1e 82       	std	Y+6, r1	; 0x06
     be6:	8e 81       	ldd	r24, Y+6	; 0x06
     be8:	9f 81       	ldd	r25, Y+7	; 0x07
     bea:	9b 83       	std	Y+3, r25	; 0x03
     bec:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     bee:	8a 81       	ldd	r24, Y+2	; 0x02
     bf0:	9b 81       	ldd	r25, Y+3	; 0x03
     bf2:	0c 96       	adiw	r24, 0x0c	; 12
     bf4:	0e 94 10 07 	call	0xe20	; 0xe20 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     bf8:	8a 81       	ldd	r24, Y+2	; 0x02
     bfa:	9b 81       	ldd	r25, Y+3	; 0x03
     bfc:	9c 01       	movw	r18, r24
     bfe:	24 5f       	subi	r18, 0xF4	; 244
     c00:	3f 4f       	sbci	r19, 0xFF	; 255
     c02:	8c e9       	ldi	r24, 0x9C	; 156
     c04:	90 e0       	ldi	r25, 0x00	; 0
     c06:	b9 01       	movw	r22, r18
     c08:	0e 94 58 06 	call	0xcb0	; 0xcb0 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     c0c:	ea 81       	ldd	r30, Y+2	; 0x02
     c0e:	fb 81       	ldd	r31, Y+3	; 0x03
     c10:	96 89       	ldd	r25, Z+22	; 0x16
     c12:	e0 91 74 00 	lds	r30, 0x0074
     c16:	f0 91 75 00 	lds	r31, 0x0075
     c1a:	86 89       	ldd	r24, Z+22	; 0x16
     c1c:	98 17       	cp	r25, r24
     c1e:	18 f0       	brcs	.+6      	; 0xc26 <xCoRoutineRemoveFromEventList+0x7a>
	{
		xReturn = pdTRUE;
     c20:	81 e0       	ldi	r24, 0x01	; 1
     c22:	89 83       	std	Y+1, r24	; 0x01
     c24:	01 c0       	rjmp	.+2      	; 0xc28 <xCoRoutineRemoveFromEventList+0x7c>
	}
	else
	{
		xReturn = pdFALSE;
     c26:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
     c28:	89 81       	ldd	r24, Y+1	; 0x01
}
     c2a:	27 96       	adiw	r28, 0x07	; 7
     c2c:	0f b6       	in	r0, 0x3f	; 63
     c2e:	f8 94       	cli
     c30:	de bf       	out	0x3e, r29	; 62
     c32:	0f be       	out	0x3f, r0	; 63
     c34:	cd bf       	out	0x3d, r28	; 61
     c36:	cf 91       	pop	r28
     c38:	df 91       	pop	r29
     c3a:	08 95       	ret

00000c3c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     c3c:	df 93       	push	r29
     c3e:	cf 93       	push	r28
     c40:	00 d0       	rcall	.+0      	; 0xc42 <vListInitialise+0x6>
     c42:	cd b7       	in	r28, 0x3d	; 61
     c44:	de b7       	in	r29, 0x3e	; 62
     c46:	9a 83       	std	Y+2, r25	; 0x02
     c48:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     c4a:	89 81       	ldd	r24, Y+1	; 0x01
     c4c:	9a 81       	ldd	r25, Y+2	; 0x02
     c4e:	03 96       	adiw	r24, 0x03	; 3
     c50:	e9 81       	ldd	r30, Y+1	; 0x01
     c52:	fa 81       	ldd	r31, Y+2	; 0x02
     c54:	92 83       	std	Z+2, r25	; 0x02
     c56:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     c58:	e9 81       	ldd	r30, Y+1	; 0x01
     c5a:	fa 81       	ldd	r31, Y+2	; 0x02
     c5c:	8f ef       	ldi	r24, 0xFF	; 255
     c5e:	9f ef       	ldi	r25, 0xFF	; 255
     c60:	94 83       	std	Z+4, r25	; 0x04
     c62:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     c64:	89 81       	ldd	r24, Y+1	; 0x01
     c66:	9a 81       	ldd	r25, Y+2	; 0x02
     c68:	03 96       	adiw	r24, 0x03	; 3
     c6a:	e9 81       	ldd	r30, Y+1	; 0x01
     c6c:	fa 81       	ldd	r31, Y+2	; 0x02
     c6e:	96 83       	std	Z+6, r25	; 0x06
     c70:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     c72:	89 81       	ldd	r24, Y+1	; 0x01
     c74:	9a 81       	ldd	r25, Y+2	; 0x02
     c76:	03 96       	adiw	r24, 0x03	; 3
     c78:	e9 81       	ldd	r30, Y+1	; 0x01
     c7a:	fa 81       	ldd	r31, Y+2	; 0x02
     c7c:	90 87       	std	Z+8, r25	; 0x08
     c7e:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = 0;
     c80:	e9 81       	ldd	r30, Y+1	; 0x01
     c82:	fa 81       	ldd	r31, Y+2	; 0x02
     c84:	10 82       	st	Z, r1
}
     c86:	0f 90       	pop	r0
     c88:	0f 90       	pop	r0
     c8a:	cf 91       	pop	r28
     c8c:	df 91       	pop	r29
     c8e:	08 95       	ret

00000c90 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
     c90:	df 93       	push	r29
     c92:	cf 93       	push	r28
     c94:	00 d0       	rcall	.+0      	; 0xc96 <vListInitialiseItem+0x6>
     c96:	cd b7       	in	r28, 0x3d	; 61
     c98:	de b7       	in	r29, 0x3e	; 62
     c9a:	9a 83       	std	Y+2, r25	; 0x02
     c9c:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     c9e:	e9 81       	ldd	r30, Y+1	; 0x01
     ca0:	fa 81       	ldd	r31, Y+2	; 0x02
     ca2:	11 86       	std	Z+9, r1	; 0x09
     ca4:	10 86       	std	Z+8, r1	; 0x08
}
     ca6:	0f 90       	pop	r0
     ca8:	0f 90       	pop	r0
     caa:	cf 91       	pop	r28
     cac:	df 91       	pop	r29
     cae:	08 95       	ret

00000cb0 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     cb0:	df 93       	push	r29
     cb2:	cf 93       	push	r28
     cb4:	00 d0       	rcall	.+0      	; 0xcb6 <vListInsertEnd+0x6>
     cb6:	00 d0       	rcall	.+0      	; 0xcb8 <vListInsertEnd+0x8>
     cb8:	00 d0       	rcall	.+0      	; 0xcba <vListInsertEnd+0xa>
     cba:	cd b7       	in	r28, 0x3d	; 61
     cbc:	de b7       	in	r29, 0x3e	; 62
     cbe:	9c 83       	std	Y+4, r25	; 0x04
     cc0:	8b 83       	std	Y+3, r24	; 0x03
     cc2:	7e 83       	std	Y+6, r23	; 0x06
     cc4:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     cc6:	eb 81       	ldd	r30, Y+3	; 0x03
     cc8:	fc 81       	ldd	r31, Y+4	; 0x04
     cca:	81 81       	ldd	r24, Z+1	; 0x01
     ccc:	92 81       	ldd	r25, Z+2	; 0x02
     cce:	9a 83       	std	Y+2, r25	; 0x02
     cd0:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
     cd2:	e9 81       	ldd	r30, Y+1	; 0x01
     cd4:	fa 81       	ldd	r31, Y+2	; 0x02
     cd6:	82 81       	ldd	r24, Z+2	; 0x02
     cd8:	93 81       	ldd	r25, Z+3	; 0x03
     cda:	ed 81       	ldd	r30, Y+5	; 0x05
     cdc:	fe 81       	ldd	r31, Y+6	; 0x06
     cde:	93 83       	std	Z+3, r25	; 0x03
     ce0:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
     ce2:	eb 81       	ldd	r30, Y+3	; 0x03
     ce4:	fc 81       	ldd	r31, Y+4	; 0x04
     ce6:	81 81       	ldd	r24, Z+1	; 0x01
     ce8:	92 81       	ldd	r25, Z+2	; 0x02
     cea:	ed 81       	ldd	r30, Y+5	; 0x05
     cec:	fe 81       	ldd	r31, Y+6	; 0x06
     cee:	95 83       	std	Z+5, r25	; 0x05
     cf0:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     cf2:	e9 81       	ldd	r30, Y+1	; 0x01
     cf4:	fa 81       	ldd	r31, Y+2	; 0x02
     cf6:	02 80       	ldd	r0, Z+2	; 0x02
     cf8:	f3 81       	ldd	r31, Z+3	; 0x03
     cfa:	e0 2d       	mov	r30, r0
     cfc:	8d 81       	ldd	r24, Y+5	; 0x05
     cfe:	9e 81       	ldd	r25, Y+6	; 0x06
     d00:	95 83       	std	Z+5, r25	; 0x05
     d02:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     d04:	8d 81       	ldd	r24, Y+5	; 0x05
     d06:	9e 81       	ldd	r25, Y+6	; 0x06
     d08:	e9 81       	ldd	r30, Y+1	; 0x01
     d0a:	fa 81       	ldd	r31, Y+2	; 0x02
     d0c:	93 83       	std	Z+3, r25	; 0x03
     d0e:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     d10:	8d 81       	ldd	r24, Y+5	; 0x05
     d12:	9e 81       	ldd	r25, Y+6	; 0x06
     d14:	eb 81       	ldd	r30, Y+3	; 0x03
     d16:	fc 81       	ldd	r31, Y+4	; 0x04
     d18:	92 83       	std	Z+2, r25	; 0x02
     d1a:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     d1c:	ed 81       	ldd	r30, Y+5	; 0x05
     d1e:	fe 81       	ldd	r31, Y+6	; 0x06
     d20:	8b 81       	ldd	r24, Y+3	; 0x03
     d22:	9c 81       	ldd	r25, Y+4	; 0x04
     d24:	91 87       	std	Z+9, r25	; 0x09
     d26:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     d28:	eb 81       	ldd	r30, Y+3	; 0x03
     d2a:	fc 81       	ldd	r31, Y+4	; 0x04
     d2c:	80 81       	ld	r24, Z
     d2e:	8f 5f       	subi	r24, 0xFF	; 255
     d30:	eb 81       	ldd	r30, Y+3	; 0x03
     d32:	fc 81       	ldd	r31, Y+4	; 0x04
     d34:	80 83       	st	Z, r24
}
     d36:	26 96       	adiw	r28, 0x06	; 6
     d38:	0f b6       	in	r0, 0x3f	; 63
     d3a:	f8 94       	cli
     d3c:	de bf       	out	0x3e, r29	; 62
     d3e:	0f be       	out	0x3f, r0	; 63
     d40:	cd bf       	out	0x3d, r28	; 61
     d42:	cf 91       	pop	r28
     d44:	df 91       	pop	r29
     d46:	08 95       	ret

00000d48 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     d48:	df 93       	push	r29
     d4a:	cf 93       	push	r28
     d4c:	cd b7       	in	r28, 0x3d	; 61
     d4e:	de b7       	in	r29, 0x3e	; 62
     d50:	28 97       	sbiw	r28, 0x08	; 8
     d52:	0f b6       	in	r0, 0x3f	; 63
     d54:	f8 94       	cli
     d56:	de bf       	out	0x3e, r29	; 62
     d58:	0f be       	out	0x3f, r0	; 63
     d5a:	cd bf       	out	0x3d, r28	; 61
     d5c:	9e 83       	std	Y+6, r25	; 0x06
     d5e:	8d 83       	std	Y+5, r24	; 0x05
     d60:	78 87       	std	Y+8, r23	; 0x08
     d62:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     d64:	ef 81       	ldd	r30, Y+7	; 0x07
     d66:	f8 85       	ldd	r31, Y+8	; 0x08
     d68:	80 81       	ld	r24, Z
     d6a:	91 81       	ldd	r25, Z+1	; 0x01
     d6c:	9a 83       	std	Y+2, r25	; 0x02
     d6e:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as 
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the 
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     d70:	89 81       	ldd	r24, Y+1	; 0x01
     d72:	9a 81       	ldd	r25, Y+2	; 0x02
     d74:	2f ef       	ldi	r18, 0xFF	; 255
     d76:	8f 3f       	cpi	r24, 0xFF	; 255
     d78:	92 07       	cpc	r25, r18
     d7a:	39 f4       	brne	.+14     	; 0xd8a <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     d7c:	ed 81       	ldd	r30, Y+5	; 0x05
     d7e:	fe 81       	ldd	r31, Y+6	; 0x06
     d80:	87 81       	ldd	r24, Z+7	; 0x07
     d82:	90 85       	ldd	r25, Z+8	; 0x08
     d84:	9c 83       	std	Y+4, r25	; 0x04
     d86:	8b 83       	std	Y+3, r24	; 0x03
     d88:	18 c0       	rjmp	.+48     	; 0xdba <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips. 
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     d8a:	8d 81       	ldd	r24, Y+5	; 0x05
     d8c:	9e 81       	ldd	r25, Y+6	; 0x06
     d8e:	03 96       	adiw	r24, 0x03	; 3
     d90:	9c 83       	std	Y+4, r25	; 0x04
     d92:	8b 83       	std	Y+3, r24	; 0x03
     d94:	06 c0       	rjmp	.+12     	; 0xda2 <vListInsert+0x5a>
     d96:	eb 81       	ldd	r30, Y+3	; 0x03
     d98:	fc 81       	ldd	r31, Y+4	; 0x04
     d9a:	82 81       	ldd	r24, Z+2	; 0x02
     d9c:	93 81       	ldd	r25, Z+3	; 0x03
     d9e:	9c 83       	std	Y+4, r25	; 0x04
     da0:	8b 83       	std	Y+3, r24	; 0x03
     da2:	eb 81       	ldd	r30, Y+3	; 0x03
     da4:	fc 81       	ldd	r31, Y+4	; 0x04
     da6:	02 80       	ldd	r0, Z+2	; 0x02
     da8:	f3 81       	ldd	r31, Z+3	; 0x03
     daa:	e0 2d       	mov	r30, r0
     dac:	20 81       	ld	r18, Z
     dae:	31 81       	ldd	r19, Z+1	; 0x01
     db0:	89 81       	ldd	r24, Y+1	; 0x01
     db2:	9a 81       	ldd	r25, Y+2	; 0x02
     db4:	82 17       	cp	r24, r18
     db6:	93 07       	cpc	r25, r19
     db8:	70 f7       	brcc	.-36     	; 0xd96 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     dba:	eb 81       	ldd	r30, Y+3	; 0x03
     dbc:	fc 81       	ldd	r31, Y+4	; 0x04
     dbe:	82 81       	ldd	r24, Z+2	; 0x02
     dc0:	93 81       	ldd	r25, Z+3	; 0x03
     dc2:	ef 81       	ldd	r30, Y+7	; 0x07
     dc4:	f8 85       	ldd	r31, Y+8	; 0x08
     dc6:	93 83       	std	Z+3, r25	; 0x03
     dc8:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     dca:	ef 81       	ldd	r30, Y+7	; 0x07
     dcc:	f8 85       	ldd	r31, Y+8	; 0x08
     dce:	02 80       	ldd	r0, Z+2	; 0x02
     dd0:	f3 81       	ldd	r31, Z+3	; 0x03
     dd2:	e0 2d       	mov	r30, r0
     dd4:	8f 81       	ldd	r24, Y+7	; 0x07
     dd6:	98 85       	ldd	r25, Y+8	; 0x08
     dd8:	95 83       	std	Z+5, r25	; 0x05
     dda:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     ddc:	ef 81       	ldd	r30, Y+7	; 0x07
     dde:	f8 85       	ldd	r31, Y+8	; 0x08
     de0:	8b 81       	ldd	r24, Y+3	; 0x03
     de2:	9c 81       	ldd	r25, Y+4	; 0x04
     de4:	95 83       	std	Z+5, r25	; 0x05
     de6:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     de8:	8f 81       	ldd	r24, Y+7	; 0x07
     dea:	98 85       	ldd	r25, Y+8	; 0x08
     dec:	eb 81       	ldd	r30, Y+3	; 0x03
     dee:	fc 81       	ldd	r31, Y+4	; 0x04
     df0:	93 83       	std	Z+3, r25	; 0x03
     df2:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     df4:	ef 81       	ldd	r30, Y+7	; 0x07
     df6:	f8 85       	ldd	r31, Y+8	; 0x08
     df8:	8d 81       	ldd	r24, Y+5	; 0x05
     dfa:	9e 81       	ldd	r25, Y+6	; 0x06
     dfc:	91 87       	std	Z+9, r25	; 0x09
     dfe:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     e00:	ed 81       	ldd	r30, Y+5	; 0x05
     e02:	fe 81       	ldd	r31, Y+6	; 0x06
     e04:	80 81       	ld	r24, Z
     e06:	8f 5f       	subi	r24, 0xFF	; 255
     e08:	ed 81       	ldd	r30, Y+5	; 0x05
     e0a:	fe 81       	ldd	r31, Y+6	; 0x06
     e0c:	80 83       	st	Z, r24
}
     e0e:	28 96       	adiw	r28, 0x08	; 8
     e10:	0f b6       	in	r0, 0x3f	; 63
     e12:	f8 94       	cli
     e14:	de bf       	out	0x3e, r29	; 62
     e16:	0f be       	out	0x3f, r0	; 63
     e18:	cd bf       	out	0x3d, r28	; 61
     e1a:	cf 91       	pop	r28
     e1c:	df 91       	pop	r29
     e1e:	08 95       	ret

00000e20 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     e20:	df 93       	push	r29
     e22:	cf 93       	push	r28
     e24:	00 d0       	rcall	.+0      	; 0xe26 <vListRemove+0x6>
     e26:	00 d0       	rcall	.+0      	; 0xe28 <vListRemove+0x8>
     e28:	cd b7       	in	r28, 0x3d	; 61
     e2a:	de b7       	in	r29, 0x3e	; 62
     e2c:	9c 83       	std	Y+4, r25	; 0x04
     e2e:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     e30:	eb 81       	ldd	r30, Y+3	; 0x03
     e32:	fc 81       	ldd	r31, Y+4	; 0x04
     e34:	a2 81       	ldd	r26, Z+2	; 0x02
     e36:	b3 81       	ldd	r27, Z+3	; 0x03
     e38:	eb 81       	ldd	r30, Y+3	; 0x03
     e3a:	fc 81       	ldd	r31, Y+4	; 0x04
     e3c:	84 81       	ldd	r24, Z+4	; 0x04
     e3e:	95 81       	ldd	r25, Z+5	; 0x05
     e40:	15 96       	adiw	r26, 0x05	; 5
     e42:	9c 93       	st	X, r25
     e44:	8e 93       	st	-X, r24
     e46:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     e48:	eb 81       	ldd	r30, Y+3	; 0x03
     e4a:	fc 81       	ldd	r31, Y+4	; 0x04
     e4c:	a4 81       	ldd	r26, Z+4	; 0x04
     e4e:	b5 81       	ldd	r27, Z+5	; 0x05
     e50:	eb 81       	ldd	r30, Y+3	; 0x03
     e52:	fc 81       	ldd	r31, Y+4	; 0x04
     e54:	82 81       	ldd	r24, Z+2	; 0x02
     e56:	93 81       	ldd	r25, Z+3	; 0x03
     e58:	13 96       	adiw	r26, 0x03	; 3
     e5a:	9c 93       	st	X, r25
     e5c:	8e 93       	st	-X, r24
     e5e:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     e60:	eb 81       	ldd	r30, Y+3	; 0x03
     e62:	fc 81       	ldd	r31, Y+4	; 0x04
     e64:	80 85       	ldd	r24, Z+8	; 0x08
     e66:	91 85       	ldd	r25, Z+9	; 0x09
     e68:	9a 83       	std	Y+2, r25	; 0x02
     e6a:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     e6c:	e9 81       	ldd	r30, Y+1	; 0x01
     e6e:	fa 81       	ldd	r31, Y+2	; 0x02
     e70:	21 81       	ldd	r18, Z+1	; 0x01
     e72:	32 81       	ldd	r19, Z+2	; 0x02
     e74:	8b 81       	ldd	r24, Y+3	; 0x03
     e76:	9c 81       	ldd	r25, Y+4	; 0x04
     e78:	28 17       	cp	r18, r24
     e7a:	39 07       	cpc	r19, r25
     e7c:	41 f4       	brne	.+16     	; 0xe8e <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     e7e:	eb 81       	ldd	r30, Y+3	; 0x03
     e80:	fc 81       	ldd	r31, Y+4	; 0x04
     e82:	84 81       	ldd	r24, Z+4	; 0x04
     e84:	95 81       	ldd	r25, Z+5	; 0x05
     e86:	e9 81       	ldd	r30, Y+1	; 0x01
     e88:	fa 81       	ldd	r31, Y+2	; 0x02
     e8a:	92 83       	std	Z+2, r25	; 0x02
     e8c:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
     e8e:	eb 81       	ldd	r30, Y+3	; 0x03
     e90:	fc 81       	ldd	r31, Y+4	; 0x04
     e92:	11 86       	std	Z+9, r1	; 0x09
     e94:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     e96:	e9 81       	ldd	r30, Y+1	; 0x01
     e98:	fa 81       	ldd	r31, Y+2	; 0x02
     e9a:	80 81       	ld	r24, Z
     e9c:	81 50       	subi	r24, 0x01	; 1
     e9e:	e9 81       	ldd	r30, Y+1	; 0x01
     ea0:	fa 81       	ldd	r31, Y+2	; 0x02
     ea2:	80 83       	st	Z, r24
}
     ea4:	0f 90       	pop	r0
     ea6:	0f 90       	pop	r0
     ea8:	0f 90       	pop	r0
     eaa:	0f 90       	pop	r0
     eac:	cf 91       	pop	r28
     eae:	df 91       	pop	r29
     eb0:	08 95       	ret

00000eb2 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     eb2:	df 93       	push	r29
     eb4:	cf 93       	push	r28
     eb6:	00 d0       	rcall	.+0      	; 0xeb8 <pvPortMalloc+0x6>
     eb8:	00 d0       	rcall	.+0      	; 0xeba <pvPortMalloc+0x8>
     eba:	cd b7       	in	r28, 0x3d	; 61
     ebc:	de b7       	in	r29, 0x3e	; 62
     ebe:	9c 83       	std	Y+4, r25	; 0x04
     ec0:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
     ec2:	1a 82       	std	Y+2, r1	; 0x02
     ec4:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     ec6:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     eca:	80 91 a5 00 	lds	r24, 0x00A5
     ece:	90 91 a6 00 	lds	r25, 0x00A6
     ed2:	2b 81       	ldd	r18, Y+3	; 0x03
     ed4:	3c 81       	ldd	r19, Y+4	; 0x04
     ed6:	82 0f       	add	r24, r18
     ed8:	93 1f       	adc	r25, r19
     eda:	22 e0       	ldi	r18, 0x02	; 2
     edc:	88 35       	cpi	r24, 0x58	; 88
     ede:	92 07       	cpc	r25, r18
     ee0:	18 f5       	brcc	.+70     	; 0xf28 <pvPortMalloc+0x76>
     ee2:	20 91 a5 00 	lds	r18, 0x00A5
     ee6:	30 91 a6 00 	lds	r19, 0x00A6
     eea:	8b 81       	ldd	r24, Y+3	; 0x03
     eec:	9c 81       	ldd	r25, Y+4	; 0x04
     eee:	28 0f       	add	r18, r24
     ef0:	39 1f       	adc	r19, r25
     ef2:	80 91 a5 00 	lds	r24, 0x00A5
     ef6:	90 91 a6 00 	lds	r25, 0x00A6
     efa:	82 17       	cp	r24, r18
     efc:	93 07       	cpc	r25, r19
     efe:	a0 f4       	brcc	.+40     	; 0xf28 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     f00:	80 91 a5 00 	lds	r24, 0x00A5
     f04:	90 91 a6 00 	lds	r25, 0x00A6
     f08:	89 55       	subi	r24, 0x59	; 89
     f0a:	9f 4f       	sbci	r25, 0xFF	; 255
     f0c:	9a 83       	std	Y+2, r25	; 0x02
     f0e:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
     f10:	20 91 a5 00 	lds	r18, 0x00A5
     f14:	30 91 a6 00 	lds	r19, 0x00A6
     f18:	8b 81       	ldd	r24, Y+3	; 0x03
     f1a:	9c 81       	ldd	r25, Y+4	; 0x04
     f1c:	82 0f       	add	r24, r18
     f1e:	93 1f       	adc	r25, r19
     f20:	90 93 a6 00 	sts	0x00A6, r25
     f24:	80 93 a5 00 	sts	0x00A5, r24
		}	
	}
	xTaskResumeAll();
     f28:	0e 94 10 0f 	call	0x1e20	; 0x1e20 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
     f2c:	89 81       	ldd	r24, Y+1	; 0x01
     f2e:	9a 81       	ldd	r25, Y+2	; 0x02
}
     f30:	0f 90       	pop	r0
     f32:	0f 90       	pop	r0
     f34:	0f 90       	pop	r0
     f36:	0f 90       	pop	r0
     f38:	cf 91       	pop	r28
     f3a:	df 91       	pop	r29
     f3c:	08 95       	ret

00000f3e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     f3e:	df 93       	push	r29
     f40:	cf 93       	push	r28
     f42:	00 d0       	rcall	.+0      	; 0xf44 <vPortFree+0x6>
     f44:	cd b7       	in	r28, 0x3d	; 61
     f46:	de b7       	in	r29, 0x3e	; 62
     f48:	9a 83       	std	Y+2, r25	; 0x02
     f4a:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
     f4c:	0f 90       	pop	r0
     f4e:	0f 90       	pop	r0
     f50:	cf 91       	pop	r28
     f52:	df 91       	pop	r29
     f54:	08 95       	ret

00000f56 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     f56:	df 93       	push	r29
     f58:	cf 93       	push	r28
     f5a:	cd b7       	in	r28, 0x3d	; 61
     f5c:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     f5e:	10 92 a6 00 	sts	0x00A6, r1
     f62:	10 92 a5 00 	sts	0x00A5, r1
}
     f66:	cf 91       	pop	r28
     f68:	df 91       	pop	r29
     f6a:	08 95       	ret

00000f6c <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     f6c:	df 93       	push	r29
     f6e:	cf 93       	push	r28
     f70:	cd b7       	in	r28, 0x3d	; 61
     f72:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
     f74:	20 91 a5 00 	lds	r18, 0x00A5
     f78:	30 91 a6 00 	lds	r19, 0x00A6
     f7c:	88 e5       	ldi	r24, 0x58	; 88
     f7e:	92 e0       	ldi	r25, 0x02	; 2
     f80:	82 1b       	sub	r24, r18
     f82:	93 0b       	sbc	r25, r19
}
     f84:	cf 91       	pop	r28
     f86:	df 91       	pop	r29
     f88:	08 95       	ret

00000f8a <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
     f8a:	df 93       	push	r29
     f8c:	cf 93       	push	r28
     f8e:	cd b7       	in	r28, 0x3d	; 61
     f90:	de b7       	in	r29, 0x3e	; 62
     f92:	28 97       	sbiw	r28, 0x08	; 8
     f94:	0f b6       	in	r0, 0x3f	; 63
     f96:	f8 94       	cli
     f98:	de bf       	out	0x3e, r29	; 62
     f9a:	0f be       	out	0x3f, r0	; 63
     f9c:	cd bf       	out	0x3d, r28	; 61
     f9e:	8d 83       	std	Y+5, r24	; 0x05
     fa0:	6e 83       	std	Y+6, r22	; 0x06
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
     fa2:	8d 81       	ldd	r24, Y+5	; 0x05
     fa4:	88 23       	and	r24, r24
     fa6:	09 f4       	brne	.+2      	; 0xfaa <xQueueCreate+0x20>
     fa8:	8c c0       	rjmp	.+280    	; 0x10c2 <xQueueCreate+0x138>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
     faa:	8f e1       	ldi	r24, 0x1F	; 31
     fac:	90 e0       	ldi	r25, 0x00	; 0
     fae:	0e 94 59 07 	call	0xeb2	; 0xeb2 <pvPortMalloc>
     fb2:	9c 83       	std	Y+4, r25	; 0x04
     fb4:	8b 83       	std	Y+3, r24	; 0x03
		if( pxNewQueue != NULL )
     fb6:	8b 81       	ldd	r24, Y+3	; 0x03
     fb8:	9c 81       	ldd	r25, Y+4	; 0x04
     fba:	00 97       	sbiw	r24, 0x00	; 0
     fbc:	09 f4       	brne	.+2      	; 0xfc0 <xQueueCreate+0x36>
     fbe:	81 c0       	rjmp	.+258    	; 0x10c2 <xQueueCreate+0x138>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
     fc0:	8d 81       	ldd	r24, Y+5	; 0x05
     fc2:	28 2f       	mov	r18, r24
     fc4:	30 e0       	ldi	r19, 0x00	; 0
     fc6:	8e 81       	ldd	r24, Y+6	; 0x06
     fc8:	88 2f       	mov	r24, r24
     fca:	90 e0       	ldi	r25, 0x00	; 0
     fcc:	ac 01       	movw	r20, r24
     fce:	24 9f       	mul	r18, r20
     fd0:	c0 01       	movw	r24, r0
     fd2:	25 9f       	mul	r18, r21
     fd4:	90 0d       	add	r25, r0
     fd6:	34 9f       	mul	r19, r20
     fd8:	90 0d       	add	r25, r0
     fda:	11 24       	eor	r1, r1
     fdc:	01 96       	adiw	r24, 0x01	; 1
     fde:	9a 83       	std	Y+2, r25	; 0x02
     fe0:	89 83       	std	Y+1, r24	; 0x01

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
     fe2:	89 81       	ldd	r24, Y+1	; 0x01
     fe4:	9a 81       	ldd	r25, Y+2	; 0x02
     fe6:	0e 94 59 07 	call	0xeb2	; 0xeb2 <pvPortMalloc>
     fea:	eb 81       	ldd	r30, Y+3	; 0x03
     fec:	fc 81       	ldd	r31, Y+4	; 0x04
     fee:	91 83       	std	Z+1, r25	; 0x01
     ff0:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
     ff2:	eb 81       	ldd	r30, Y+3	; 0x03
     ff4:	fc 81       	ldd	r31, Y+4	; 0x04
     ff6:	80 81       	ld	r24, Z
     ff8:	91 81       	ldd	r25, Z+1	; 0x01
     ffa:	00 97       	sbiw	r24, 0x00	; 0
     ffc:	09 f4       	brne	.+2      	; 0x1000 <xQueueCreate+0x76>
     ffe:	5d c0       	rjmp	.+186    	; 0x10ba <xQueueCreate+0x130>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    1000:	eb 81       	ldd	r30, Y+3	; 0x03
    1002:	fc 81       	ldd	r31, Y+4	; 0x04
    1004:	40 81       	ld	r20, Z
    1006:	51 81       	ldd	r21, Z+1	; 0x01
    1008:	8d 81       	ldd	r24, Y+5	; 0x05
    100a:	28 2f       	mov	r18, r24
    100c:	30 e0       	ldi	r19, 0x00	; 0
    100e:	8e 81       	ldd	r24, Y+6	; 0x06
    1010:	88 2f       	mov	r24, r24
    1012:	90 e0       	ldi	r25, 0x00	; 0
    1014:	bc 01       	movw	r22, r24
    1016:	26 9f       	mul	r18, r22
    1018:	c0 01       	movw	r24, r0
    101a:	27 9f       	mul	r18, r23
    101c:	90 0d       	add	r25, r0
    101e:	36 9f       	mul	r19, r22
    1020:	90 0d       	add	r25, r0
    1022:	11 24       	eor	r1, r1
    1024:	84 0f       	add	r24, r20
    1026:	95 1f       	adc	r25, r21
    1028:	eb 81       	ldd	r30, Y+3	; 0x03
    102a:	fc 81       	ldd	r31, Y+4	; 0x04
    102c:	93 83       	std	Z+3, r25	; 0x03
    102e:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = 0;
    1030:	eb 81       	ldd	r30, Y+3	; 0x03
    1032:	fc 81       	ldd	r31, Y+4	; 0x04
    1034:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    1036:	eb 81       	ldd	r30, Y+3	; 0x03
    1038:	fc 81       	ldd	r31, Y+4	; 0x04
    103a:	80 81       	ld	r24, Z
    103c:	91 81       	ldd	r25, Z+1	; 0x01
    103e:	eb 81       	ldd	r30, Y+3	; 0x03
    1040:	fc 81       	ldd	r31, Y+4	; 0x04
    1042:	95 83       	std	Z+5, r25	; 0x05
    1044:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - 1 ) * uxItemSize );
    1046:	eb 81       	ldd	r30, Y+3	; 0x03
    1048:	fc 81       	ldd	r31, Y+4	; 0x04
    104a:	40 81       	ld	r20, Z
    104c:	51 81       	ldd	r21, Z+1	; 0x01
    104e:	8d 81       	ldd	r24, Y+5	; 0x05
    1050:	88 2f       	mov	r24, r24
    1052:	90 e0       	ldi	r25, 0x00	; 0
    1054:	9c 01       	movw	r18, r24
    1056:	21 50       	subi	r18, 0x01	; 1
    1058:	30 40       	sbci	r19, 0x00	; 0
    105a:	8e 81       	ldd	r24, Y+6	; 0x06
    105c:	88 2f       	mov	r24, r24
    105e:	90 e0       	ldi	r25, 0x00	; 0
    1060:	bc 01       	movw	r22, r24
    1062:	26 9f       	mul	r18, r22
    1064:	c0 01       	movw	r24, r0
    1066:	27 9f       	mul	r18, r23
    1068:	90 0d       	add	r25, r0
    106a:	36 9f       	mul	r19, r22
    106c:	90 0d       	add	r25, r0
    106e:	11 24       	eor	r1, r1
    1070:	84 0f       	add	r24, r20
    1072:	95 1f       	adc	r25, r21
    1074:	eb 81       	ldd	r30, Y+3	; 0x03
    1076:	fc 81       	ldd	r31, Y+4	; 0x04
    1078:	97 83       	std	Z+7, r25	; 0x07
    107a:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    107c:	eb 81       	ldd	r30, Y+3	; 0x03
    107e:	fc 81       	ldd	r31, Y+4	; 0x04
    1080:	8d 81       	ldd	r24, Y+5	; 0x05
    1082:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1084:	eb 81       	ldd	r30, Y+3	; 0x03
    1086:	fc 81       	ldd	r31, Y+4	; 0x04
    1088:	8e 81       	ldd	r24, Y+6	; 0x06
    108a:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    108c:	eb 81       	ldd	r30, Y+3	; 0x03
    108e:	fc 81       	ldd	r31, Y+4	; 0x04
    1090:	8f ef       	ldi	r24, 0xFF	; 255
    1092:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    1094:	eb 81       	ldd	r30, Y+3	; 0x03
    1096:	fc 81       	ldd	r31, Y+4	; 0x04
    1098:	8f ef       	ldi	r24, 0xFF	; 255
    109a:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    109c:	8b 81       	ldd	r24, Y+3	; 0x03
    109e:	9c 81       	ldd	r25, Y+4	; 0x04
    10a0:	08 96       	adiw	r24, 0x08	; 8
    10a2:	0e 94 1e 06 	call	0xc3c	; 0xc3c <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    10a6:	8b 81       	ldd	r24, Y+3	; 0x03
    10a8:	9c 81       	ldd	r25, Y+4	; 0x04
    10aa:	41 96       	adiw	r24, 0x11	; 17
    10ac:	0e 94 1e 06 	call	0xc3c	; 0xc3c <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				return  pxNewQueue;
    10b0:	8b 81       	ldd	r24, Y+3	; 0x03
    10b2:	9c 81       	ldd	r25, Y+4	; 0x04
    10b4:	98 87       	std	Y+8, r25	; 0x08
    10b6:	8f 83       	std	Y+7, r24	; 0x07
    10b8:	06 c0       	rjmp	.+12     	; 0x10c6 <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    10ba:	8b 81       	ldd	r24, Y+3	; 0x03
    10bc:	9c 81       	ldd	r25, Y+4	; 0x04
    10be:	0e 94 9f 07 	call	0xf3e	; 0xf3e <vPortFree>
		}
	}

	/* Will only reach here if we could not allocate enough memory or no memory
	was required. */
	return NULL;
    10c2:	18 86       	std	Y+8, r1	; 0x08
    10c4:	1f 82       	std	Y+7, r1	; 0x07
    10c6:	8f 81       	ldd	r24, Y+7	; 0x07
    10c8:	98 85       	ldd	r25, Y+8	; 0x08
}
    10ca:	28 96       	adiw	r28, 0x08	; 8
    10cc:	0f b6       	in	r0, 0x3f	; 63
    10ce:	f8 94       	cli
    10d0:	de bf       	out	0x3e, r29	; 62
    10d2:	0f be       	out	0x3f, r0	; 63
    10d4:	cd bf       	out	0x3d, r28	; 61
    10d6:	cf 91       	pop	r28
    10d8:	df 91       	pop	r29
    10da:	08 95       	ret

000010dc <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    10dc:	df 93       	push	r29
    10de:	cf 93       	push	r28
    10e0:	cd b7       	in	r28, 0x3d	; 61
    10e2:	de b7       	in	r29, 0x3e	; 62
    10e4:	2c 97       	sbiw	r28, 0x0c	; 12
    10e6:	0f b6       	in	r0, 0x3f	; 63
    10e8:	f8 94       	cli
    10ea:	de bf       	out	0x3e, r29	; 62
    10ec:	0f be       	out	0x3f, r0	; 63
    10ee:	cd bf       	out	0x3d, r28	; 61
    10f0:	9e 83       	std	Y+6, r25	; 0x06
    10f2:	8d 83       	std	Y+5, r24	; 0x05
    10f4:	78 87       	std	Y+8, r23	; 0x08
    10f6:	6f 83       	std	Y+7, r22	; 0x07
    10f8:	5a 87       	std	Y+10, r21	; 0x0a
    10fa:	49 87       	std	Y+9, r20	; 0x09
    10fc:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    10fe:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1100:	0f b6       	in	r0, 0x3f	; 63
    1102:	f8 94       	cli
    1104:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1106:	ed 81       	ldd	r30, Y+5	; 0x05
    1108:	fe 81       	ldd	r31, Y+6	; 0x06
    110a:	92 8d       	ldd	r25, Z+26	; 0x1a
    110c:	ed 81       	ldd	r30, Y+5	; 0x05
    110e:	fe 81       	ldd	r31, Y+6	; 0x06
    1110:	83 8d       	ldd	r24, Z+27	; 0x1b
    1112:	98 17       	cp	r25, r24
    1114:	d8 f4       	brcc	.+54     	; 0x114c <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1116:	8d 81       	ldd	r24, Y+5	; 0x05
    1118:	9e 81       	ldd	r25, Y+6	; 0x06
    111a:	2f 81       	ldd	r18, Y+7	; 0x07
    111c:	38 85       	ldd	r19, Y+8	; 0x08
    111e:	b9 01       	movw	r22, r18
    1120:	4b 85       	ldd	r20, Y+11	; 0x0b
    1122:	0e 94 a9 0a 	call	0x1552	; 0x1552 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1126:	ed 81       	ldd	r30, Y+5	; 0x05
    1128:	fe 81       	ldd	r31, Y+6	; 0x06
    112a:	81 89       	ldd	r24, Z+17	; 0x11
    112c:	88 23       	and	r24, r24
    112e:	49 f0       	breq	.+18     	; 0x1142 <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1130:	8d 81       	ldd	r24, Y+5	; 0x05
    1132:	9e 81       	ldd	r25, Y+6	; 0x06
    1134:	41 96       	adiw	r24, 0x11	; 17
    1136:	0e 94 2e 11 	call	0x225c	; 0x225c <xTaskRemoveFromEventList>
    113a:	81 30       	cpi	r24, 0x01	; 1
    113c:	11 f4       	brne	.+4      	; 0x1142 <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    113e:	0e 94 08 02 	call	0x410	; 0x410 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    1142:	0f 90       	pop	r0
    1144:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    1146:	81 e0       	ldi	r24, 0x01	; 1
    1148:	8c 87       	std	Y+12, r24	; 0x0c
    114a:	5c c0       	rjmp	.+184    	; 0x1204 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    114c:	89 85       	ldd	r24, Y+9	; 0x09
    114e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1150:	00 97       	sbiw	r24, 0x00	; 0
    1152:	21 f4       	brne	.+8      	; 0x115c <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1154:	0f 90       	pop	r0
    1156:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1158:	1c 86       	std	Y+12, r1	; 0x0c
    115a:	54 c0       	rjmp	.+168    	; 0x1204 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    115c:	89 81       	ldd	r24, Y+1	; 0x01
    115e:	88 23       	and	r24, r24
    1160:	31 f4       	brne	.+12     	; 0x116e <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1162:	ce 01       	movw	r24, r28
    1164:	02 96       	adiw	r24, 0x02	; 2
    1166:	0e 94 a6 11 	call	0x234c	; 0x234c <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    116a:	81 e0       	ldi	r24, 0x01	; 1
    116c:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    116e:	0f 90       	pop	r0
    1170:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1172:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1176:	0f b6       	in	r0, 0x3f	; 63
    1178:	f8 94       	cli
    117a:	0f 92       	push	r0
    117c:	ed 81       	ldd	r30, Y+5	; 0x05
    117e:	fe 81       	ldd	r31, Y+6	; 0x06
    1180:	85 8d       	ldd	r24, Z+29	; 0x1d
    1182:	8f 3f       	cpi	r24, 0xFF	; 255
    1184:	19 f4       	brne	.+6      	; 0x118c <xQueueGenericSend+0xb0>
    1186:	ed 81       	ldd	r30, Y+5	; 0x05
    1188:	fe 81       	ldd	r31, Y+6	; 0x06
    118a:	15 8e       	std	Z+29, r1	; 0x1d
    118c:	ed 81       	ldd	r30, Y+5	; 0x05
    118e:	fe 81       	ldd	r31, Y+6	; 0x06
    1190:	86 8d       	ldd	r24, Z+30	; 0x1e
    1192:	8f 3f       	cpi	r24, 0xFF	; 255
    1194:	19 f4       	brne	.+6      	; 0x119c <xQueueGenericSend+0xc0>
    1196:	ed 81       	ldd	r30, Y+5	; 0x05
    1198:	fe 81       	ldd	r31, Y+6	; 0x06
    119a:	16 8e       	std	Z+30, r1	; 0x1e
    119c:	0f 90       	pop	r0
    119e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    11a0:	ce 01       	movw	r24, r28
    11a2:	02 96       	adiw	r24, 0x02	; 2
    11a4:	9e 01       	movw	r18, r28
    11a6:	27 5f       	subi	r18, 0xF7	; 247
    11a8:	3f 4f       	sbci	r19, 0xFF	; 255
    11aa:	b9 01       	movw	r22, r18
    11ac:	0e 94 bf 11 	call	0x237e	; 0x237e <xTaskCheckForTimeOut>
    11b0:	88 23       	and	r24, r24
    11b2:	09 f5       	brne	.+66     	; 0x11f6 <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) )
    11b4:	8d 81       	ldd	r24, Y+5	; 0x05
    11b6:	9e 81       	ldd	r25, Y+6	; 0x06
    11b8:	0e 94 0d 0c 	call	0x181a	; 0x181a <prvIsQueueFull>
    11bc:	88 23       	and	r24, r24
    11be:	a1 f0       	breq	.+40     	; 0x11e8 <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    11c0:	8d 81       	ldd	r24, Y+5	; 0x05
    11c2:	9e 81       	ldd	r25, Y+6	; 0x06
    11c4:	08 96       	adiw	r24, 0x08	; 8
    11c6:	29 85       	ldd	r18, Y+9	; 0x09
    11c8:	3a 85       	ldd	r19, Y+10	; 0x0a
    11ca:	b9 01       	movw	r22, r18
    11cc:	0e 94 d0 10 	call	0x21a0	; 0x21a0 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    11d0:	8d 81       	ldd	r24, Y+5	; 0x05
    11d2:	9e 81       	ldd	r25, Y+6	; 0x06
    11d4:	0e 94 86 0b 	call	0x170c	; 0x170c <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
    11d8:	0e 94 10 0f 	call	0x1e20	; 0x1e20 <xTaskResumeAll>
    11dc:	88 23       	and	r24, r24
    11de:	09 f0       	breq	.+2      	; 0x11e2 <xQueueGenericSend+0x106>
    11e0:	8f cf       	rjmp	.-226    	; 0x1100 <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    11e2:	0e 94 08 02 	call	0x410	; 0x410 <vPortYield>
    11e6:	8c cf       	rjmp	.-232    	; 0x1100 <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    11e8:	8d 81       	ldd	r24, Y+5	; 0x05
    11ea:	9e 81       	ldd	r25, Y+6	; 0x06
    11ec:	0e 94 86 0b 	call	0x170c	; 0x170c <prvUnlockQueue>
				( void ) xTaskResumeAll();
    11f0:	0e 94 10 0f 	call	0x1e20	; 0x1e20 <xTaskResumeAll>
    11f4:	85 cf       	rjmp	.-246    	; 0x1100 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    11f6:	8d 81       	ldd	r24, Y+5	; 0x05
    11f8:	9e 81       	ldd	r25, Y+6	; 0x06
    11fa:	0e 94 86 0b 	call	0x170c	; 0x170c <prvUnlockQueue>
			( void ) xTaskResumeAll();
    11fe:	0e 94 10 0f 	call	0x1e20	; 0x1e20 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1202:	1c 86       	std	Y+12, r1	; 0x0c
    1204:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    1206:	2c 96       	adiw	r28, 0x0c	; 12
    1208:	0f b6       	in	r0, 0x3f	; 63
    120a:	f8 94       	cli
    120c:	de bf       	out	0x3e, r29	; 62
    120e:	0f be       	out	0x3f, r0	; 63
    1210:	cd bf       	out	0x3d, r28	; 61
    1212:	cf 91       	pop	r28
    1214:	df 91       	pop	r29
    1216:	08 95       	ret

00001218 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1218:	df 93       	push	r29
    121a:	cf 93       	push	r28
    121c:	cd b7       	in	r28, 0x3d	; 61
    121e:	de b7       	in	r29, 0x3e	; 62
    1220:	29 97       	sbiw	r28, 0x09	; 9
    1222:	0f b6       	in	r0, 0x3f	; 63
    1224:	f8 94       	cli
    1226:	de bf       	out	0x3e, r29	; 62
    1228:	0f be       	out	0x3f, r0	; 63
    122a:	cd bf       	out	0x3d, r28	; 61
    122c:	9c 83       	std	Y+4, r25	; 0x04
    122e:	8b 83       	std	Y+3, r24	; 0x03
    1230:	7e 83       	std	Y+6, r23	; 0x06
    1232:	6d 83       	std	Y+5, r22	; 0x05
    1234:	58 87       	std	Y+8, r21	; 0x08
    1236:	4f 83       	std	Y+7, r20	; 0x07
    1238:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    123a:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    123c:	eb 81       	ldd	r30, Y+3	; 0x03
    123e:	fc 81       	ldd	r31, Y+4	; 0x04
    1240:	92 8d       	ldd	r25, Z+26	; 0x1a
    1242:	eb 81       	ldd	r30, Y+3	; 0x03
    1244:	fc 81       	ldd	r31, Y+4	; 0x04
    1246:	83 8d       	ldd	r24, Z+27	; 0x1b
    1248:	98 17       	cp	r25, r24
    124a:	40 f5       	brcc	.+80     	; 0x129c <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    124c:	8b 81       	ldd	r24, Y+3	; 0x03
    124e:	9c 81       	ldd	r25, Y+4	; 0x04
    1250:	2d 81       	ldd	r18, Y+5	; 0x05
    1252:	3e 81       	ldd	r19, Y+6	; 0x06
    1254:	b9 01       	movw	r22, r18
    1256:	49 85       	ldd	r20, Y+9	; 0x09
    1258:	0e 94 a9 0a 	call	0x1552	; 0x1552 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    125c:	eb 81       	ldd	r30, Y+3	; 0x03
    125e:	fc 81       	ldd	r31, Y+4	; 0x04
    1260:	86 8d       	ldd	r24, Z+30	; 0x1e
    1262:	8f 3f       	cpi	r24, 0xFF	; 255
    1264:	89 f4       	brne	.+34     	; 0x1288 <xQueueGenericSendFromISR+0x70>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    1266:	eb 81       	ldd	r30, Y+3	; 0x03
    1268:	fc 81       	ldd	r31, Y+4	; 0x04
    126a:	81 89       	ldd	r24, Z+17	; 0x11
    126c:	88 23       	and	r24, r24
    126e:	99 f0       	breq	.+38     	; 0x1296 <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1270:	8b 81       	ldd	r24, Y+3	; 0x03
    1272:	9c 81       	ldd	r25, Y+4	; 0x04
    1274:	41 96       	adiw	r24, 0x11	; 17
    1276:	0e 94 2e 11 	call	0x225c	; 0x225c <xTaskRemoveFromEventList>
    127a:	88 23       	and	r24, r24
    127c:	61 f0       	breq	.+24     	; 0x1296 <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    127e:	ef 81       	ldd	r30, Y+7	; 0x07
    1280:	f8 85       	ldd	r31, Y+8	; 0x08
    1282:	81 e0       	ldi	r24, 0x01	; 1
    1284:	80 83       	st	Z, r24
    1286:	07 c0       	rjmp	.+14     	; 0x1296 <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1288:	eb 81       	ldd	r30, Y+3	; 0x03
    128a:	fc 81       	ldd	r31, Y+4	; 0x04
    128c:	86 8d       	ldd	r24, Z+30	; 0x1e
    128e:	8f 5f       	subi	r24, 0xFF	; 255
    1290:	eb 81       	ldd	r30, Y+3	; 0x03
    1292:	fc 81       	ldd	r31, Y+4	; 0x04
    1294:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1296:	81 e0       	ldi	r24, 0x01	; 1
    1298:	8a 83       	std	Y+2, r24	; 0x02
    129a:	01 c0       	rjmp	.+2      	; 0x129e <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    129c:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    129e:	8a 81       	ldd	r24, Y+2	; 0x02
}
    12a0:	29 96       	adiw	r28, 0x09	; 9
    12a2:	0f b6       	in	r0, 0x3f	; 63
    12a4:	f8 94       	cli
    12a6:	de bf       	out	0x3e, r29	; 62
    12a8:	0f be       	out	0x3f, r0	; 63
    12aa:	cd bf       	out	0x3d, r28	; 61
    12ac:	cf 91       	pop	r28
    12ae:	df 91       	pop	r29
    12b0:	08 95       	ret

000012b2 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    12b2:	df 93       	push	r29
    12b4:	cf 93       	push	r28
    12b6:	cd b7       	in	r28, 0x3d	; 61
    12b8:	de b7       	in	r29, 0x3e	; 62
    12ba:	2e 97       	sbiw	r28, 0x0e	; 14
    12bc:	0f b6       	in	r0, 0x3f	; 63
    12be:	f8 94       	cli
    12c0:	de bf       	out	0x3e, r29	; 62
    12c2:	0f be       	out	0x3f, r0	; 63
    12c4:	cd bf       	out	0x3d, r28	; 61
    12c6:	98 87       	std	Y+8, r25	; 0x08
    12c8:	8f 83       	std	Y+7, r24	; 0x07
    12ca:	7a 87       	std	Y+10, r23	; 0x0a
    12cc:	69 87       	std	Y+9, r22	; 0x09
    12ce:	5c 87       	std	Y+12, r21	; 0x0c
    12d0:	4b 87       	std	Y+11, r20	; 0x0b
    12d2:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    12d4:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    12d6:	0f b6       	in	r0, 0x3f	; 63
    12d8:	f8 94       	cli
    12da:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    12dc:	ef 81       	ldd	r30, Y+7	; 0x07
    12de:	f8 85       	ldd	r31, Y+8	; 0x08
    12e0:	82 8d       	ldd	r24, Z+26	; 0x1a
    12e2:	88 23       	and	r24, r24
    12e4:	09 f4       	brne	.+2      	; 0x12e8 <xQueueGenericReceive+0x36>
    12e6:	3f c0       	rjmp	.+126    	; 0x1366 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    12e8:	ef 81       	ldd	r30, Y+7	; 0x07
    12ea:	f8 85       	ldd	r31, Y+8	; 0x08
    12ec:	86 81       	ldd	r24, Z+6	; 0x06
    12ee:	97 81       	ldd	r25, Z+7	; 0x07
    12f0:	9a 83       	std	Y+2, r25	; 0x02
    12f2:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    12f4:	8f 81       	ldd	r24, Y+7	; 0x07
    12f6:	98 85       	ldd	r25, Y+8	; 0x08
    12f8:	29 85       	ldd	r18, Y+9	; 0x09
    12fa:	3a 85       	ldd	r19, Y+10	; 0x0a
    12fc:	b9 01       	movw	r22, r18
    12fe:	0e 94 3e 0b 	call	0x167c	; 0x167c <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1302:	8d 85       	ldd	r24, Y+13	; 0x0d
    1304:	88 23       	and	r24, r24
    1306:	b1 f4       	brne	.+44     	; 0x1334 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1308:	ef 81       	ldd	r30, Y+7	; 0x07
    130a:	f8 85       	ldd	r31, Y+8	; 0x08
    130c:	82 8d       	ldd	r24, Z+26	; 0x1a
    130e:	81 50       	subi	r24, 0x01	; 1
    1310:	ef 81       	ldd	r30, Y+7	; 0x07
    1312:	f8 85       	ldd	r31, Y+8	; 0x08
    1314:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1316:	ef 81       	ldd	r30, Y+7	; 0x07
    1318:	f8 85       	ldd	r31, Y+8	; 0x08
    131a:	80 85       	ldd	r24, Z+8	; 0x08
    131c:	88 23       	and	r24, r24
    131e:	f1 f0       	breq	.+60     	; 0x135c <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1320:	8f 81       	ldd	r24, Y+7	; 0x07
    1322:	98 85       	ldd	r25, Y+8	; 0x08
    1324:	08 96       	adiw	r24, 0x08	; 8
    1326:	0e 94 2e 11 	call	0x225c	; 0x225c <xTaskRemoveFromEventList>
    132a:	81 30       	cpi	r24, 0x01	; 1
    132c:	b9 f4       	brne	.+46     	; 0x135c <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    132e:	0e 94 08 02 	call	0x410	; 0x410 <vPortYield>
    1332:	14 c0       	rjmp	.+40     	; 0x135c <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1334:	ef 81       	ldd	r30, Y+7	; 0x07
    1336:	f8 85       	ldd	r31, Y+8	; 0x08
    1338:	89 81       	ldd	r24, Y+1	; 0x01
    133a:	9a 81       	ldd	r25, Y+2	; 0x02
    133c:	97 83       	std	Z+7, r25	; 0x07
    133e:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    1340:	ef 81       	ldd	r30, Y+7	; 0x07
    1342:	f8 85       	ldd	r31, Y+8	; 0x08
    1344:	81 89       	ldd	r24, Z+17	; 0x11
    1346:	88 23       	and	r24, r24
    1348:	49 f0       	breq	.+18     	; 0x135c <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    134a:	8f 81       	ldd	r24, Y+7	; 0x07
    134c:	98 85       	ldd	r25, Y+8	; 0x08
    134e:	41 96       	adiw	r24, 0x11	; 17
    1350:	0e 94 2e 11 	call	0x225c	; 0x225c <xTaskRemoveFromEventList>
    1354:	88 23       	and	r24, r24
    1356:	11 f0       	breq	.+4      	; 0x135c <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1358:	0e 94 08 02 	call	0x410	; 0x410 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    135c:	0f 90       	pop	r0
    135e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1360:	81 e0       	ldi	r24, 0x01	; 1
    1362:	8e 87       	std	Y+14, r24	; 0x0e
    1364:	5c c0       	rjmp	.+184    	; 0x141e <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1366:	8b 85       	ldd	r24, Y+11	; 0x0b
    1368:	9c 85       	ldd	r25, Y+12	; 0x0c
    136a:	00 97       	sbiw	r24, 0x00	; 0
    136c:	21 f4       	brne	.+8      	; 0x1376 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    136e:	0f 90       	pop	r0
    1370:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1372:	1e 86       	std	Y+14, r1	; 0x0e
    1374:	54 c0       	rjmp	.+168    	; 0x141e <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    1376:	8b 81       	ldd	r24, Y+3	; 0x03
    1378:	88 23       	and	r24, r24
    137a:	31 f4       	brne	.+12     	; 0x1388 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    137c:	ce 01       	movw	r24, r28
    137e:	04 96       	adiw	r24, 0x04	; 4
    1380:	0e 94 a6 11 	call	0x234c	; 0x234c <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1384:	81 e0       	ldi	r24, 0x01	; 1
    1386:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    1388:	0f 90       	pop	r0
    138a:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    138c:	0e 94 04 0f 	call	0x1e08	; 0x1e08 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1390:	0f b6       	in	r0, 0x3f	; 63
    1392:	f8 94       	cli
    1394:	0f 92       	push	r0
    1396:	ef 81       	ldd	r30, Y+7	; 0x07
    1398:	f8 85       	ldd	r31, Y+8	; 0x08
    139a:	85 8d       	ldd	r24, Z+29	; 0x1d
    139c:	8f 3f       	cpi	r24, 0xFF	; 255
    139e:	19 f4       	brne	.+6      	; 0x13a6 <xQueueGenericReceive+0xf4>
    13a0:	ef 81       	ldd	r30, Y+7	; 0x07
    13a2:	f8 85       	ldd	r31, Y+8	; 0x08
    13a4:	15 8e       	std	Z+29, r1	; 0x1d
    13a6:	ef 81       	ldd	r30, Y+7	; 0x07
    13a8:	f8 85       	ldd	r31, Y+8	; 0x08
    13aa:	86 8d       	ldd	r24, Z+30	; 0x1e
    13ac:	8f 3f       	cpi	r24, 0xFF	; 255
    13ae:	19 f4       	brne	.+6      	; 0x13b6 <xQueueGenericReceive+0x104>
    13b0:	ef 81       	ldd	r30, Y+7	; 0x07
    13b2:	f8 85       	ldd	r31, Y+8	; 0x08
    13b4:	16 8e       	std	Z+30, r1	; 0x1e
    13b6:	0f 90       	pop	r0
    13b8:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    13ba:	ce 01       	movw	r24, r28
    13bc:	04 96       	adiw	r24, 0x04	; 4
    13be:	9e 01       	movw	r18, r28
    13c0:	25 5f       	subi	r18, 0xF5	; 245
    13c2:	3f 4f       	sbci	r19, 0xFF	; 255
    13c4:	b9 01       	movw	r22, r18
    13c6:	0e 94 bf 11 	call	0x237e	; 0x237e <xTaskCheckForTimeOut>
    13ca:	88 23       	and	r24, r24
    13cc:	09 f5       	brne	.+66     	; 0x1410 <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) )
    13ce:	8f 81       	ldd	r24, Y+7	; 0x07
    13d0:	98 85       	ldd	r25, Y+8	; 0x08
    13d2:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <prvIsQueueEmpty>
    13d6:	88 23       	and	r24, r24
    13d8:	a1 f0       	breq	.+40     	; 0x1402 <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    13da:	8f 81       	ldd	r24, Y+7	; 0x07
    13dc:	98 85       	ldd	r25, Y+8	; 0x08
    13de:	41 96       	adiw	r24, 0x11	; 17
    13e0:	2b 85       	ldd	r18, Y+11	; 0x0b
    13e2:	3c 85       	ldd	r19, Y+12	; 0x0c
    13e4:	b9 01       	movw	r22, r18
    13e6:	0e 94 d0 10 	call	0x21a0	; 0x21a0 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    13ea:	8f 81       	ldd	r24, Y+7	; 0x07
    13ec:	98 85       	ldd	r25, Y+8	; 0x08
    13ee:	0e 94 86 0b 	call	0x170c	; 0x170c <prvUnlockQueue>
				if( !xTaskResumeAll() )
    13f2:	0e 94 10 0f 	call	0x1e20	; 0x1e20 <xTaskResumeAll>
    13f6:	88 23       	and	r24, r24
    13f8:	09 f0       	breq	.+2      	; 0x13fc <xQueueGenericReceive+0x14a>
    13fa:	6d cf       	rjmp	.-294    	; 0x12d6 <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    13fc:	0e 94 08 02 	call	0x410	; 0x410 <vPortYield>
    1400:	6a cf       	rjmp	.-300    	; 0x12d6 <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1402:	8f 81       	ldd	r24, Y+7	; 0x07
    1404:	98 85       	ldd	r25, Y+8	; 0x08
    1406:	0e 94 86 0b 	call	0x170c	; 0x170c <prvUnlockQueue>
				( void ) xTaskResumeAll();
    140a:	0e 94 10 0f 	call	0x1e20	; 0x1e20 <xTaskResumeAll>
    140e:	63 cf       	rjmp	.-314    	; 0x12d6 <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1410:	8f 81       	ldd	r24, Y+7	; 0x07
    1412:	98 85       	ldd	r25, Y+8	; 0x08
    1414:	0e 94 86 0b 	call	0x170c	; 0x170c <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1418:	0e 94 10 0f 	call	0x1e20	; 0x1e20 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    141c:	1e 86       	std	Y+14, r1	; 0x0e
    141e:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    1420:	2e 96       	adiw	r28, 0x0e	; 14
    1422:	0f b6       	in	r0, 0x3f	; 63
    1424:	f8 94       	cli
    1426:	de bf       	out	0x3e, r29	; 62
    1428:	0f be       	out	0x3f, r0	; 63
    142a:	cd bf       	out	0x3d, r28	; 61
    142c:	cf 91       	pop	r28
    142e:	df 91       	pop	r29
    1430:	08 95       	ret

00001432 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    1432:	df 93       	push	r29
    1434:	cf 93       	push	r28
    1436:	cd b7       	in	r28, 0x3d	; 61
    1438:	de b7       	in	r29, 0x3e	; 62
    143a:	28 97       	sbiw	r28, 0x08	; 8
    143c:	0f b6       	in	r0, 0x3f	; 63
    143e:	f8 94       	cli
    1440:	de bf       	out	0x3e, r29	; 62
    1442:	0f be       	out	0x3f, r0	; 63
    1444:	cd bf       	out	0x3d, r28	; 61
    1446:	9c 83       	std	Y+4, r25	; 0x04
    1448:	8b 83       	std	Y+3, r24	; 0x03
    144a:	7e 83       	std	Y+6, r23	; 0x06
    144c:	6d 83       	std	Y+5, r22	; 0x05
    144e:	58 87       	std	Y+8, r21	; 0x08
    1450:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1452:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1454:	eb 81       	ldd	r30, Y+3	; 0x03
    1456:	fc 81       	ldd	r31, Y+4	; 0x04
    1458:	82 8d       	ldd	r24, Z+26	; 0x1a
    145a:	88 23       	and	r24, r24
    145c:	71 f1       	breq	.+92     	; 0x14ba <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    145e:	8b 81       	ldd	r24, Y+3	; 0x03
    1460:	9c 81       	ldd	r25, Y+4	; 0x04
    1462:	2d 81       	ldd	r18, Y+5	; 0x05
    1464:	3e 81       	ldd	r19, Y+6	; 0x06
    1466:	b9 01       	movw	r22, r18
    1468:	0e 94 3e 0b 	call	0x167c	; 0x167c <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    146c:	eb 81       	ldd	r30, Y+3	; 0x03
    146e:	fc 81       	ldd	r31, Y+4	; 0x04
    1470:	82 8d       	ldd	r24, Z+26	; 0x1a
    1472:	81 50       	subi	r24, 0x01	; 1
    1474:	eb 81       	ldd	r30, Y+3	; 0x03
    1476:	fc 81       	ldd	r31, Y+4	; 0x04
    1478:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    147a:	eb 81       	ldd	r30, Y+3	; 0x03
    147c:	fc 81       	ldd	r31, Y+4	; 0x04
    147e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1480:	8f 3f       	cpi	r24, 0xFF	; 255
    1482:	89 f4       	brne	.+34     	; 0x14a6 <xQueueReceiveFromISR+0x74>
			{
				if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    1484:	eb 81       	ldd	r30, Y+3	; 0x03
    1486:	fc 81       	ldd	r31, Y+4	; 0x04
    1488:	80 85       	ldd	r24, Z+8	; 0x08
    148a:	88 23       	and	r24, r24
    148c:	99 f0       	breq	.+38     	; 0x14b4 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    148e:	8b 81       	ldd	r24, Y+3	; 0x03
    1490:	9c 81       	ldd	r25, Y+4	; 0x04
    1492:	08 96       	adiw	r24, 0x08	; 8
    1494:	0e 94 2e 11 	call	0x225c	; 0x225c <xTaskRemoveFromEventList>
    1498:	88 23       	and	r24, r24
    149a:	61 f0       	breq	.+24     	; 0x14b4 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    149c:	ef 81       	ldd	r30, Y+7	; 0x07
    149e:	f8 85       	ldd	r31, Y+8	; 0x08
    14a0:	81 e0       	ldi	r24, 0x01	; 1
    14a2:	80 83       	st	Z, r24
    14a4:	07 c0       	rjmp	.+14     	; 0x14b4 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    14a6:	eb 81       	ldd	r30, Y+3	; 0x03
    14a8:	fc 81       	ldd	r31, Y+4	; 0x04
    14aa:	85 8d       	ldd	r24, Z+29	; 0x1d
    14ac:	8f 5f       	subi	r24, 0xFF	; 255
    14ae:	eb 81       	ldd	r30, Y+3	; 0x03
    14b0:	fc 81       	ldd	r31, Y+4	; 0x04
    14b2:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    14b4:	81 e0       	ldi	r24, 0x01	; 1
    14b6:	8a 83       	std	Y+2, r24	; 0x02
    14b8:	01 c0       	rjmp	.+2      	; 0x14bc <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    14ba:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    14bc:	8a 81       	ldd	r24, Y+2	; 0x02
}
    14be:	28 96       	adiw	r28, 0x08	; 8
    14c0:	0f b6       	in	r0, 0x3f	; 63
    14c2:	f8 94       	cli
    14c4:	de bf       	out	0x3e, r29	; 62
    14c6:	0f be       	out	0x3f, r0	; 63
    14c8:	cd bf       	out	0x3d, r28	; 61
    14ca:	cf 91       	pop	r28
    14cc:	df 91       	pop	r29
    14ce:	08 95       	ret

000014d0 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    14d0:	df 93       	push	r29
    14d2:	cf 93       	push	r28
    14d4:	00 d0       	rcall	.+0      	; 0x14d6 <uxQueueMessagesWaiting+0x6>
    14d6:	0f 92       	push	r0
    14d8:	cd b7       	in	r28, 0x3d	; 61
    14da:	de b7       	in	r29, 0x3e	; 62
    14dc:	9b 83       	std	Y+3, r25	; 0x03
    14de:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	taskENTER_CRITICAL();
    14e0:	0f b6       	in	r0, 0x3f	; 63
    14e2:	f8 94       	cli
    14e4:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    14e6:	ea 81       	ldd	r30, Y+2	; 0x02
    14e8:	fb 81       	ldd	r31, Y+3	; 0x03
    14ea:	82 8d       	ldd	r24, Z+26	; 0x1a
    14ec:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    14ee:	0f 90       	pop	r0
    14f0:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    14f2:	89 81       	ldd	r24, Y+1	; 0x01
}
    14f4:	0f 90       	pop	r0
    14f6:	0f 90       	pop	r0
    14f8:	0f 90       	pop	r0
    14fa:	cf 91       	pop	r28
    14fc:	df 91       	pop	r29
    14fe:	08 95       	ret

00001500 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    1500:	df 93       	push	r29
    1502:	cf 93       	push	r28
    1504:	00 d0       	rcall	.+0      	; 0x1506 <uxQueueMessagesWaitingFromISR+0x6>
    1506:	0f 92       	push	r0
    1508:	cd b7       	in	r28, 0x3d	; 61
    150a:	de b7       	in	r29, 0x3e	; 62
    150c:	9b 83       	std	Y+3, r25	; 0x03
    150e:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	uxReturn = pxQueue->uxMessagesWaiting;
    1510:	ea 81       	ldd	r30, Y+2	; 0x02
    1512:	fb 81       	ldd	r31, Y+3	; 0x03
    1514:	82 8d       	ldd	r24, Z+26	; 0x1a
    1516:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    1518:	89 81       	ldd	r24, Y+1	; 0x01
}
    151a:	0f 90       	pop	r0
    151c:	0f 90       	pop	r0
    151e:	0f 90       	pop	r0
    1520:	cf 91       	pop	r28
    1522:	df 91       	pop	r29
    1524:	08 95       	ret

00001526 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    1526:	df 93       	push	r29
    1528:	cf 93       	push	r28
    152a:	00 d0       	rcall	.+0      	; 0x152c <vQueueDelete+0x6>
    152c:	cd b7       	in	r28, 0x3d	; 61
    152e:	de b7       	in	r29, 0x3e	; 62
    1530:	9a 83       	std	Y+2, r25	; 0x02
    1532:	89 83       	std	Y+1, r24	; 0x01
	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    1534:	e9 81       	ldd	r30, Y+1	; 0x01
    1536:	fa 81       	ldd	r31, Y+2	; 0x02
    1538:	80 81       	ld	r24, Z
    153a:	91 81       	ldd	r25, Z+1	; 0x01
    153c:	0e 94 9f 07 	call	0xf3e	; 0xf3e <vPortFree>
	vPortFree( pxQueue );
    1540:	89 81       	ldd	r24, Y+1	; 0x01
    1542:	9a 81       	ldd	r25, Y+2	; 0x02
    1544:	0e 94 9f 07 	call	0xf3e	; 0xf3e <vPortFree>
}
    1548:	0f 90       	pop	r0
    154a:	0f 90       	pop	r0
    154c:	cf 91       	pop	r28
    154e:	df 91       	pop	r29
    1550:	08 95       	ret

00001552 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    1552:	df 93       	push	r29
    1554:	cf 93       	push	r28
    1556:	00 d0       	rcall	.+0      	; 0x1558 <prvCopyDataToQueue+0x6>
    1558:	00 d0       	rcall	.+0      	; 0x155a <prvCopyDataToQueue+0x8>
    155a:	0f 92       	push	r0
    155c:	cd b7       	in	r28, 0x3d	; 61
    155e:	de b7       	in	r29, 0x3e	; 62
    1560:	9a 83       	std	Y+2, r25	; 0x02
    1562:	89 83       	std	Y+1, r24	; 0x01
    1564:	7c 83       	std	Y+4, r23	; 0x04
    1566:	6b 83       	std	Y+3, r22	; 0x03
    1568:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    156a:	e9 81       	ldd	r30, Y+1	; 0x01
    156c:	fa 81       	ldd	r31, Y+2	; 0x02
    156e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1570:	88 23       	and	r24, r24
    1572:	09 f4       	brne	.+2      	; 0x1576 <prvCopyDataToQueue+0x24>
    1574:	74 c0       	rjmp	.+232    	; 0x165e <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    1576:	8d 81       	ldd	r24, Y+5	; 0x05
    1578:	88 23       	and	r24, r24
    157a:	99 f5       	brne	.+102    	; 0x15e2 <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    157c:	e9 81       	ldd	r30, Y+1	; 0x01
    157e:	fa 81       	ldd	r31, Y+2	; 0x02
    1580:	64 81       	ldd	r22, Z+4	; 0x04
    1582:	75 81       	ldd	r23, Z+5	; 0x05
    1584:	e9 81       	ldd	r30, Y+1	; 0x01
    1586:	fa 81       	ldd	r31, Y+2	; 0x02
    1588:	84 8d       	ldd	r24, Z+28	; 0x1c
    158a:	48 2f       	mov	r20, r24
    158c:	50 e0       	ldi	r21, 0x00	; 0
    158e:	2b 81       	ldd	r18, Y+3	; 0x03
    1590:	3c 81       	ldd	r19, Y+4	; 0x04
    1592:	cb 01       	movw	r24, r22
    1594:	b9 01       	movw	r22, r18
    1596:	0e 94 76 16 	call	0x2cec	; 0x2cec <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    159a:	e9 81       	ldd	r30, Y+1	; 0x01
    159c:	fa 81       	ldd	r31, Y+2	; 0x02
    159e:	24 81       	ldd	r18, Z+4	; 0x04
    15a0:	35 81       	ldd	r19, Z+5	; 0x05
    15a2:	e9 81       	ldd	r30, Y+1	; 0x01
    15a4:	fa 81       	ldd	r31, Y+2	; 0x02
    15a6:	84 8d       	ldd	r24, Z+28	; 0x1c
    15a8:	88 2f       	mov	r24, r24
    15aa:	90 e0       	ldi	r25, 0x00	; 0
    15ac:	82 0f       	add	r24, r18
    15ae:	93 1f       	adc	r25, r19
    15b0:	e9 81       	ldd	r30, Y+1	; 0x01
    15b2:	fa 81       	ldd	r31, Y+2	; 0x02
    15b4:	95 83       	std	Z+5, r25	; 0x05
    15b6:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    15b8:	e9 81       	ldd	r30, Y+1	; 0x01
    15ba:	fa 81       	ldd	r31, Y+2	; 0x02
    15bc:	24 81       	ldd	r18, Z+4	; 0x04
    15be:	35 81       	ldd	r19, Z+5	; 0x05
    15c0:	e9 81       	ldd	r30, Y+1	; 0x01
    15c2:	fa 81       	ldd	r31, Y+2	; 0x02
    15c4:	82 81       	ldd	r24, Z+2	; 0x02
    15c6:	93 81       	ldd	r25, Z+3	; 0x03
    15c8:	28 17       	cp	r18, r24
    15ca:	39 07       	cpc	r19, r25
    15cc:	08 f4       	brcc	.+2      	; 0x15d0 <prvCopyDataToQueue+0x7e>
    15ce:	47 c0       	rjmp	.+142    	; 0x165e <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    15d0:	e9 81       	ldd	r30, Y+1	; 0x01
    15d2:	fa 81       	ldd	r31, Y+2	; 0x02
    15d4:	80 81       	ld	r24, Z
    15d6:	91 81       	ldd	r25, Z+1	; 0x01
    15d8:	e9 81       	ldd	r30, Y+1	; 0x01
    15da:	fa 81       	ldd	r31, Y+2	; 0x02
    15dc:	95 83       	std	Z+5, r25	; 0x05
    15de:	84 83       	std	Z+4, r24	; 0x04
    15e0:	3e c0       	rjmp	.+124    	; 0x165e <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    15e2:	e9 81       	ldd	r30, Y+1	; 0x01
    15e4:	fa 81       	ldd	r31, Y+2	; 0x02
    15e6:	66 81       	ldd	r22, Z+6	; 0x06
    15e8:	77 81       	ldd	r23, Z+7	; 0x07
    15ea:	e9 81       	ldd	r30, Y+1	; 0x01
    15ec:	fa 81       	ldd	r31, Y+2	; 0x02
    15ee:	84 8d       	ldd	r24, Z+28	; 0x1c
    15f0:	48 2f       	mov	r20, r24
    15f2:	50 e0       	ldi	r21, 0x00	; 0
    15f4:	2b 81       	ldd	r18, Y+3	; 0x03
    15f6:	3c 81       	ldd	r19, Y+4	; 0x04
    15f8:	cb 01       	movw	r24, r22
    15fa:	b9 01       	movw	r22, r18
    15fc:	0e 94 76 16 	call	0x2cec	; 0x2cec <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    1600:	e9 81       	ldd	r30, Y+1	; 0x01
    1602:	fa 81       	ldd	r31, Y+2	; 0x02
    1604:	26 81       	ldd	r18, Z+6	; 0x06
    1606:	37 81       	ldd	r19, Z+7	; 0x07
    1608:	e9 81       	ldd	r30, Y+1	; 0x01
    160a:	fa 81       	ldd	r31, Y+2	; 0x02
    160c:	84 8d       	ldd	r24, Z+28	; 0x1c
    160e:	88 2f       	mov	r24, r24
    1610:	90 e0       	ldi	r25, 0x00	; 0
    1612:	90 95       	com	r25
    1614:	81 95       	neg	r24
    1616:	9f 4f       	sbci	r25, 0xFF	; 255
    1618:	82 0f       	add	r24, r18
    161a:	93 1f       	adc	r25, r19
    161c:	e9 81       	ldd	r30, Y+1	; 0x01
    161e:	fa 81       	ldd	r31, Y+2	; 0x02
    1620:	97 83       	std	Z+7, r25	; 0x07
    1622:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    1624:	e9 81       	ldd	r30, Y+1	; 0x01
    1626:	fa 81       	ldd	r31, Y+2	; 0x02
    1628:	26 81       	ldd	r18, Z+6	; 0x06
    162a:	37 81       	ldd	r19, Z+7	; 0x07
    162c:	e9 81       	ldd	r30, Y+1	; 0x01
    162e:	fa 81       	ldd	r31, Y+2	; 0x02
    1630:	80 81       	ld	r24, Z
    1632:	91 81       	ldd	r25, Z+1	; 0x01
    1634:	28 17       	cp	r18, r24
    1636:	39 07       	cpc	r19, r25
    1638:	90 f4       	brcc	.+36     	; 0x165e <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    163a:	e9 81       	ldd	r30, Y+1	; 0x01
    163c:	fa 81       	ldd	r31, Y+2	; 0x02
    163e:	22 81       	ldd	r18, Z+2	; 0x02
    1640:	33 81       	ldd	r19, Z+3	; 0x03
    1642:	e9 81       	ldd	r30, Y+1	; 0x01
    1644:	fa 81       	ldd	r31, Y+2	; 0x02
    1646:	84 8d       	ldd	r24, Z+28	; 0x1c
    1648:	88 2f       	mov	r24, r24
    164a:	90 e0       	ldi	r25, 0x00	; 0
    164c:	90 95       	com	r25
    164e:	81 95       	neg	r24
    1650:	9f 4f       	sbci	r25, 0xFF	; 255
    1652:	82 0f       	add	r24, r18
    1654:	93 1f       	adc	r25, r19
    1656:	e9 81       	ldd	r30, Y+1	; 0x01
    1658:	fa 81       	ldd	r31, Y+2	; 0x02
    165a:	97 83       	std	Z+7, r25	; 0x07
    165c:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    165e:	e9 81       	ldd	r30, Y+1	; 0x01
    1660:	fa 81       	ldd	r31, Y+2	; 0x02
    1662:	82 8d       	ldd	r24, Z+26	; 0x1a
    1664:	8f 5f       	subi	r24, 0xFF	; 255
    1666:	e9 81       	ldd	r30, Y+1	; 0x01
    1668:	fa 81       	ldd	r31, Y+2	; 0x02
    166a:	82 8f       	std	Z+26, r24	; 0x1a
}
    166c:	0f 90       	pop	r0
    166e:	0f 90       	pop	r0
    1670:	0f 90       	pop	r0
    1672:	0f 90       	pop	r0
    1674:	0f 90       	pop	r0
    1676:	cf 91       	pop	r28
    1678:	df 91       	pop	r29
    167a:	08 95       	ret

0000167c <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    167c:	df 93       	push	r29
    167e:	cf 93       	push	r28
    1680:	00 d0       	rcall	.+0      	; 0x1682 <prvCopyDataFromQueue+0x6>
    1682:	00 d0       	rcall	.+0      	; 0x1684 <prvCopyDataFromQueue+0x8>
    1684:	cd b7       	in	r28, 0x3d	; 61
    1686:	de b7       	in	r29, 0x3e	; 62
    1688:	9a 83       	std	Y+2, r25	; 0x02
    168a:	89 83       	std	Y+1, r24	; 0x01
    168c:	7c 83       	std	Y+4, r23	; 0x04
    168e:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    1690:	e9 81       	ldd	r30, Y+1	; 0x01
    1692:	fa 81       	ldd	r31, Y+2	; 0x02
    1694:	80 81       	ld	r24, Z
    1696:	91 81       	ldd	r25, Z+1	; 0x01
    1698:	00 97       	sbiw	r24, 0x00	; 0
    169a:	89 f1       	breq	.+98     	; 0x16fe <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    169c:	e9 81       	ldd	r30, Y+1	; 0x01
    169e:	fa 81       	ldd	r31, Y+2	; 0x02
    16a0:	26 81       	ldd	r18, Z+6	; 0x06
    16a2:	37 81       	ldd	r19, Z+7	; 0x07
    16a4:	e9 81       	ldd	r30, Y+1	; 0x01
    16a6:	fa 81       	ldd	r31, Y+2	; 0x02
    16a8:	84 8d       	ldd	r24, Z+28	; 0x1c
    16aa:	88 2f       	mov	r24, r24
    16ac:	90 e0       	ldi	r25, 0x00	; 0
    16ae:	82 0f       	add	r24, r18
    16b0:	93 1f       	adc	r25, r19
    16b2:	e9 81       	ldd	r30, Y+1	; 0x01
    16b4:	fa 81       	ldd	r31, Y+2	; 0x02
    16b6:	97 83       	std	Z+7, r25	; 0x07
    16b8:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    16ba:	e9 81       	ldd	r30, Y+1	; 0x01
    16bc:	fa 81       	ldd	r31, Y+2	; 0x02
    16be:	26 81       	ldd	r18, Z+6	; 0x06
    16c0:	37 81       	ldd	r19, Z+7	; 0x07
    16c2:	e9 81       	ldd	r30, Y+1	; 0x01
    16c4:	fa 81       	ldd	r31, Y+2	; 0x02
    16c6:	82 81       	ldd	r24, Z+2	; 0x02
    16c8:	93 81       	ldd	r25, Z+3	; 0x03
    16ca:	28 17       	cp	r18, r24
    16cc:	39 07       	cpc	r19, r25
    16ce:	40 f0       	brcs	.+16     	; 0x16e0 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    16d0:	e9 81       	ldd	r30, Y+1	; 0x01
    16d2:	fa 81       	ldd	r31, Y+2	; 0x02
    16d4:	80 81       	ld	r24, Z
    16d6:	91 81       	ldd	r25, Z+1	; 0x01
    16d8:	e9 81       	ldd	r30, Y+1	; 0x01
    16da:	fa 81       	ldd	r31, Y+2	; 0x02
    16dc:	97 83       	std	Z+7, r25	; 0x07
    16de:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    16e0:	e9 81       	ldd	r30, Y+1	; 0x01
    16e2:	fa 81       	ldd	r31, Y+2	; 0x02
    16e4:	46 81       	ldd	r20, Z+6	; 0x06
    16e6:	57 81       	ldd	r21, Z+7	; 0x07
    16e8:	e9 81       	ldd	r30, Y+1	; 0x01
    16ea:	fa 81       	ldd	r31, Y+2	; 0x02
    16ec:	84 8d       	ldd	r24, Z+28	; 0x1c
    16ee:	28 2f       	mov	r18, r24
    16f0:	30 e0       	ldi	r19, 0x00	; 0
    16f2:	8b 81       	ldd	r24, Y+3	; 0x03
    16f4:	9c 81       	ldd	r25, Y+4	; 0x04
    16f6:	ba 01       	movw	r22, r20
    16f8:	a9 01       	movw	r20, r18
    16fa:	0e 94 76 16 	call	0x2cec	; 0x2cec <memcpy>
	}
}
    16fe:	0f 90       	pop	r0
    1700:	0f 90       	pop	r0
    1702:	0f 90       	pop	r0
    1704:	0f 90       	pop	r0
    1706:	cf 91       	pop	r28
    1708:	df 91       	pop	r29
    170a:	08 95       	ret

0000170c <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    170c:	df 93       	push	r29
    170e:	cf 93       	push	r28
    1710:	00 d0       	rcall	.+0      	; 0x1712 <prvUnlockQueue+0x6>
    1712:	cd b7       	in	r28, 0x3d	; 61
    1714:	de b7       	in	r29, 0x3e	; 62
    1716:	9a 83       	std	Y+2, r25	; 0x02
    1718:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    171a:	0f b6       	in	r0, 0x3f	; 63
    171c:	f8 94       	cli
    171e:	0f 92       	push	r0
    1720:	15 c0       	rjmp	.+42     	; 0x174c <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    1722:	e9 81       	ldd	r30, Y+1	; 0x01
    1724:	fa 81       	ldd	r31, Y+2	; 0x02
    1726:	81 89       	ldd	r24, Z+17	; 0x11
    1728:	88 23       	and	r24, r24
    172a:	a9 f0       	breq	.+42     	; 0x1756 <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    172c:	89 81       	ldd	r24, Y+1	; 0x01
    172e:	9a 81       	ldd	r25, Y+2	; 0x02
    1730:	41 96       	adiw	r24, 0x11	; 17
    1732:	0e 94 2e 11 	call	0x225c	; 0x225c <xTaskRemoveFromEventList>
    1736:	88 23       	and	r24, r24
    1738:	11 f0       	breq	.+4      	; 0x173e <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    173a:	0e 94 1c 12 	call	0x2438	; 0x2438 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    173e:	e9 81       	ldd	r30, Y+1	; 0x01
    1740:	fa 81       	ldd	r31, Y+2	; 0x02
    1742:	86 8d       	ldd	r24, Z+30	; 0x1e
    1744:	81 50       	subi	r24, 0x01	; 1
    1746:	e9 81       	ldd	r30, Y+1	; 0x01
    1748:	fa 81       	ldd	r31, Y+2	; 0x02
    174a:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    174c:	e9 81       	ldd	r30, Y+1	; 0x01
    174e:	fa 81       	ldd	r31, Y+2	; 0x02
    1750:	86 8d       	ldd	r24, Z+30	; 0x1e
    1752:	18 16       	cp	r1, r24
    1754:	34 f3       	brlt	.-52     	; 0x1722 <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    1756:	e9 81       	ldd	r30, Y+1	; 0x01
    1758:	fa 81       	ldd	r31, Y+2	; 0x02
    175a:	8f ef       	ldi	r24, 0xFF	; 255
    175c:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    175e:	0f 90       	pop	r0
    1760:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1762:	0f b6       	in	r0, 0x3f	; 63
    1764:	f8 94       	cli
    1766:	0f 92       	push	r0
    1768:	15 c0       	rjmp	.+42     	; 0x1794 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    176a:	e9 81       	ldd	r30, Y+1	; 0x01
    176c:	fa 81       	ldd	r31, Y+2	; 0x02
    176e:	80 85       	ldd	r24, Z+8	; 0x08
    1770:	88 23       	and	r24, r24
    1772:	a9 f0       	breq	.+42     	; 0x179e <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1774:	89 81       	ldd	r24, Y+1	; 0x01
    1776:	9a 81       	ldd	r25, Y+2	; 0x02
    1778:	08 96       	adiw	r24, 0x08	; 8
    177a:	0e 94 2e 11 	call	0x225c	; 0x225c <xTaskRemoveFromEventList>
    177e:	88 23       	and	r24, r24
    1780:	11 f0       	breq	.+4      	; 0x1786 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    1782:	0e 94 1c 12 	call	0x2438	; 0x2438 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    1786:	e9 81       	ldd	r30, Y+1	; 0x01
    1788:	fa 81       	ldd	r31, Y+2	; 0x02
    178a:	85 8d       	ldd	r24, Z+29	; 0x1d
    178c:	81 50       	subi	r24, 0x01	; 1
    178e:	e9 81       	ldd	r30, Y+1	; 0x01
    1790:	fa 81       	ldd	r31, Y+2	; 0x02
    1792:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1794:	e9 81       	ldd	r30, Y+1	; 0x01
    1796:	fa 81       	ldd	r31, Y+2	; 0x02
    1798:	85 8d       	ldd	r24, Z+29	; 0x1d
    179a:	18 16       	cp	r1, r24
    179c:	34 f3       	brlt	.-52     	; 0x176a <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    179e:	e9 81       	ldd	r30, Y+1	; 0x01
    17a0:	fa 81       	ldd	r31, Y+2	; 0x02
    17a2:	8f ef       	ldi	r24, 0xFF	; 255
    17a4:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    17a6:	0f 90       	pop	r0
    17a8:	0f be       	out	0x3f, r0	; 63
}
    17aa:	0f 90       	pop	r0
    17ac:	0f 90       	pop	r0
    17ae:	cf 91       	pop	r28
    17b0:	df 91       	pop	r29
    17b2:	08 95       	ret

000017b4 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    17b4:	df 93       	push	r29
    17b6:	cf 93       	push	r28
    17b8:	00 d0       	rcall	.+0      	; 0x17ba <prvIsQueueEmpty+0x6>
    17ba:	0f 92       	push	r0
    17bc:	cd b7       	in	r28, 0x3d	; 61
    17be:	de b7       	in	r29, 0x3e	; 62
    17c0:	9b 83       	std	Y+3, r25	; 0x03
    17c2:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    17c4:	0f b6       	in	r0, 0x3f	; 63
    17c6:	f8 94       	cli
    17c8:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    17ca:	ea 81       	ldd	r30, Y+2	; 0x02
    17cc:	fb 81       	ldd	r31, Y+3	; 0x03
    17ce:	82 8d       	ldd	r24, Z+26	; 0x1a
    17d0:	19 82       	std	Y+1, r1	; 0x01
    17d2:	88 23       	and	r24, r24
    17d4:	11 f4       	brne	.+4      	; 0x17da <prvIsQueueEmpty+0x26>
    17d6:	81 e0       	ldi	r24, 0x01	; 1
    17d8:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    17da:	0f 90       	pop	r0
    17dc:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    17de:	89 81       	ldd	r24, Y+1	; 0x01
}
    17e0:	0f 90       	pop	r0
    17e2:	0f 90       	pop	r0
    17e4:	0f 90       	pop	r0
    17e6:	cf 91       	pop	r28
    17e8:	df 91       	pop	r29
    17ea:	08 95       	ret

000017ec <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    17ec:	df 93       	push	r29
    17ee:	cf 93       	push	r28
    17f0:	00 d0       	rcall	.+0      	; 0x17f2 <xQueueIsQueueEmptyFromISR+0x6>
    17f2:	0f 92       	push	r0
    17f4:	cd b7       	in	r28, 0x3d	; 61
    17f6:	de b7       	in	r29, 0x3e	; 62
    17f8:	9b 83       	std	Y+3, r25	; 0x03
    17fa:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    17fc:	ea 81       	ldd	r30, Y+2	; 0x02
    17fe:	fb 81       	ldd	r31, Y+3	; 0x03
    1800:	82 8d       	ldd	r24, Z+26	; 0x1a
    1802:	19 82       	std	Y+1, r1	; 0x01
    1804:	88 23       	and	r24, r24
    1806:	11 f4       	brne	.+4      	; 0x180c <xQueueIsQueueEmptyFromISR+0x20>
    1808:	81 e0       	ldi	r24, 0x01	; 1
    180a:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    180c:	89 81       	ldd	r24, Y+1	; 0x01
}
    180e:	0f 90       	pop	r0
    1810:	0f 90       	pop	r0
    1812:	0f 90       	pop	r0
    1814:	cf 91       	pop	r28
    1816:	df 91       	pop	r29
    1818:	08 95       	ret

0000181a <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    181a:	df 93       	push	r29
    181c:	cf 93       	push	r28
    181e:	00 d0       	rcall	.+0      	; 0x1820 <prvIsQueueFull+0x6>
    1820:	0f 92       	push	r0
    1822:	cd b7       	in	r28, 0x3d	; 61
    1824:	de b7       	in	r29, 0x3e	; 62
    1826:	9b 83       	std	Y+3, r25	; 0x03
    1828:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    182a:	0f b6       	in	r0, 0x3f	; 63
    182c:	f8 94       	cli
    182e:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1830:	ea 81       	ldd	r30, Y+2	; 0x02
    1832:	fb 81       	ldd	r31, Y+3	; 0x03
    1834:	92 8d       	ldd	r25, Z+26	; 0x1a
    1836:	ea 81       	ldd	r30, Y+2	; 0x02
    1838:	fb 81       	ldd	r31, Y+3	; 0x03
    183a:	83 8d       	ldd	r24, Z+27	; 0x1b
    183c:	19 82       	std	Y+1, r1	; 0x01
    183e:	98 17       	cp	r25, r24
    1840:	11 f4       	brne	.+4      	; 0x1846 <prvIsQueueFull+0x2c>
    1842:	81 e0       	ldi	r24, 0x01	; 1
    1844:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1846:	0f 90       	pop	r0
    1848:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    184a:	89 81       	ldd	r24, Y+1	; 0x01
}
    184c:	0f 90       	pop	r0
    184e:	0f 90       	pop	r0
    1850:	0f 90       	pop	r0
    1852:	cf 91       	pop	r28
    1854:	df 91       	pop	r29
    1856:	08 95       	ret

00001858 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    1858:	df 93       	push	r29
    185a:	cf 93       	push	r28
    185c:	00 d0       	rcall	.+0      	; 0x185e <xQueueIsQueueFullFromISR+0x6>
    185e:	0f 92       	push	r0
    1860:	cd b7       	in	r28, 0x3d	; 61
    1862:	de b7       	in	r29, 0x3e	; 62
    1864:	9b 83       	std	Y+3, r25	; 0x03
    1866:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1868:	ea 81       	ldd	r30, Y+2	; 0x02
    186a:	fb 81       	ldd	r31, Y+3	; 0x03
    186c:	92 8d       	ldd	r25, Z+26	; 0x1a
    186e:	ea 81       	ldd	r30, Y+2	; 0x02
    1870:	fb 81       	ldd	r31, Y+3	; 0x03
    1872:	83 8d       	ldd	r24, Z+27	; 0x1b
    1874:	19 82       	std	Y+1, r1	; 0x01
    1876:	98 17       	cp	r25, r24
    1878:	11 f4       	brne	.+4      	; 0x187e <xQueueIsQueueFullFromISR+0x26>
    187a:	81 e0       	ldi	r24, 0x01	; 1
    187c:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    187e:	89 81       	ldd	r24, Y+1	; 0x01
}
    1880:	0f 90       	pop	r0
    1882:	0f 90       	pop	r0
    1884:	0f 90       	pop	r0
    1886:	cf 91       	pop	r28
    1888:	df 91       	pop	r29
    188a:	08 95       	ret

0000188c <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if configUSE_CO_ROUTINES == 1
signed portBASE_TYPE xQueueCRSend( xQueueHandle pxQueue, const void *pvItemToQueue, portTickType xTicksToWait )
{
    188c:	df 93       	push	r29
    188e:	cf 93       	push	r28
    1890:	cd b7       	in	r28, 0x3d	; 61
    1892:	de b7       	in	r29, 0x3e	; 62
    1894:	28 97       	sbiw	r28, 0x08	; 8
    1896:	0f b6       	in	r0, 0x3f	; 63
    1898:	f8 94       	cli
    189a:	de bf       	out	0x3e, r29	; 62
    189c:	0f be       	out	0x3f, r0	; 63
    189e:	cd bf       	out	0x3d, r28	; 61
    18a0:	9b 83       	std	Y+3, r25	; 0x03
    18a2:	8a 83       	std	Y+2, r24	; 0x02
    18a4:	7d 83       	std	Y+5, r23	; 0x05
    18a6:	6c 83       	std	Y+4, r22	; 0x04
    18a8:	5f 83       	std	Y+7, r21	; 0x07
    18aa:	4e 83       	std	Y+6, r20	; 0x06
signed portBASE_TYPE xReturn;

	/* If the queue is already full we may have to block.  A critical section
	is required to prevent an interrupt removing something from the queue
	between the check to see if the queue is full and blocking on the queue. */
	portDISABLE_INTERRUPTS();
    18ac:	f8 94       	cli
	{
		if( prvIsQueueFull( pxQueue ) )
    18ae:	8a 81       	ldd	r24, Y+2	; 0x02
    18b0:	9b 81       	ldd	r25, Y+3	; 0x03
    18b2:	0e 94 0d 0c 	call	0x181a	; 0x181a <prvIsQueueFull>
    18b6:	88 23       	and	r24, r24
    18b8:	a9 f0       	breq	.+42     	; 0x18e4 <xQueueCRSend+0x58>
		{
			/* The queue is full - do we want to block or just leave without
			posting? */
			if( xTicksToWait > ( portTickType ) 0 )
    18ba:	8e 81       	ldd	r24, Y+6	; 0x06
    18bc:	9f 81       	ldd	r25, Y+7	; 0x07
    18be:	00 97       	sbiw	r24, 0x00	; 0
    18c0:	71 f0       	breq	.+28     	; 0x18de <xQueueCRSend+0x52>
			{
				/* As this is called from a coroutine we cannot block directly, but
				return indicating that we need to block. */
				vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    18c2:	8a 81       	ldd	r24, Y+2	; 0x02
    18c4:	9b 81       	ldd	r25, Y+3	; 0x03
    18c6:	9c 01       	movw	r18, r24
    18c8:	28 5f       	subi	r18, 0xF8	; 248
    18ca:	3f 4f       	sbci	r19, 0xFF	; 255
    18cc:	8e 81       	ldd	r24, Y+6	; 0x06
    18ce:	9f 81       	ldd	r25, Y+7	; 0x07
    18d0:	b9 01       	movw	r22, r18
    18d2:	0e 94 ae 03 	call	0x75c	; 0x75c <vCoRoutineAddToDelayedList>
				portENABLE_INTERRUPTS();
    18d6:	78 94       	sei
				return errQUEUE_BLOCKED;
    18d8:	8c ef       	ldi	r24, 0xFC	; 252
    18da:	88 87       	std	Y+8, r24	; 0x08
    18dc:	2b c0       	rjmp	.+86     	; 0x1934 <xQueueCRSend+0xa8>
			}
			else
			{
				portENABLE_INTERRUPTS();
    18de:	78 94       	sei
				return errQUEUE_FULL;
    18e0:	18 86       	std	Y+8, r1	; 0x08
    18e2:	28 c0       	rjmp	.+80     	; 0x1934 <xQueueCRSend+0xa8>
			}
		}
	}
	portENABLE_INTERRUPTS();
    18e4:	78 94       	sei

	portNOP();
    18e6:	00 00       	nop

	portDISABLE_INTERRUPTS();
    18e8:	f8 94       	cli
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    18ea:	ea 81       	ldd	r30, Y+2	; 0x02
    18ec:	fb 81       	ldd	r31, Y+3	; 0x03
    18ee:	92 8d       	ldd	r25, Z+26	; 0x1a
    18f0:	ea 81       	ldd	r30, Y+2	; 0x02
    18f2:	fb 81       	ldd	r31, Y+3	; 0x03
    18f4:	83 8d       	ldd	r24, Z+27	; 0x1b
    18f6:	98 17       	cp	r25, r24
    18f8:	c8 f4       	brcc	.+50     	; 0x192c <xQueueCRSend+0xa0>
		{
			/* There is room in the queue, copy the data into the queue. */
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    18fa:	8a 81       	ldd	r24, Y+2	; 0x02
    18fc:	9b 81       	ldd	r25, Y+3	; 0x03
    18fe:	2c 81       	ldd	r18, Y+4	; 0x04
    1900:	3d 81       	ldd	r19, Y+5	; 0x05
    1902:	b9 01       	movw	r22, r18
    1904:	40 e0       	ldi	r20, 0x00	; 0
    1906:	0e 94 a9 0a 	call	0x1552	; 0x1552 <prvCopyDataToQueue>
			xReturn = pdPASS;
    190a:	81 e0       	ldi	r24, 0x01	; 1
    190c:	89 83       	std	Y+1, r24	; 0x01

			/* Were any co-routines waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    190e:	ea 81       	ldd	r30, Y+2	; 0x02
    1910:	fb 81       	ldd	r31, Y+3	; 0x03
    1912:	81 89       	ldd	r24, Z+17	; 0x11
    1914:	88 23       	and	r24, r24
    1916:	59 f0       	breq	.+22     	; 0x192e <xQueueCRSend+0xa2>
			{
				/* In this instance the co-routine could be placed directly
				into the ready list as we are within a critical section.
				Instead the same pending ready list mechanism is used as if
				the event were caused from within an interrupt. */
				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1918:	8a 81       	ldd	r24, Y+2	; 0x02
    191a:	9b 81       	ldd	r25, Y+3	; 0x03
    191c:	41 96       	adiw	r24, 0x11	; 17
    191e:	0e 94 d6 05 	call	0xbac	; 0xbac <xCoRoutineRemoveFromEventList>
    1922:	88 23       	and	r24, r24
    1924:	21 f0       	breq	.+8      	; 0x192e <xQueueCRSend+0xa2>
				{
					/* The co-routine waiting has a higher priority so record
					that a yield might be appropriate. */
					xReturn = errQUEUE_YIELD;
    1926:	8b ef       	ldi	r24, 0xFB	; 251
    1928:	89 83       	std	Y+1, r24	; 0x01
    192a:	01 c0       	rjmp	.+2      	; 0x192e <xQueueCRSend+0xa2>
				}
			}
		}
		else
		{
			xReturn = errQUEUE_FULL;
    192c:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	portENABLE_INTERRUPTS();
    192e:	78 94       	sei

	return xReturn;
    1930:	89 81       	ldd	r24, Y+1	; 0x01
    1932:	88 87       	std	Y+8, r24	; 0x08
    1934:	88 85       	ldd	r24, Y+8	; 0x08
}
    1936:	28 96       	adiw	r28, 0x08	; 8
    1938:	0f b6       	in	r0, 0x3f	; 63
    193a:	f8 94       	cli
    193c:	de bf       	out	0x3e, r29	; 62
    193e:	0f be       	out	0x3f, r0	; 63
    1940:	cd bf       	out	0x3d, r28	; 61
    1942:	cf 91       	pop	r28
    1944:	df 91       	pop	r29
    1946:	08 95       	ret

00001948 <xQueueCRReceive>:
#endif
/*-----------------------------------------------------------*/

#if configUSE_CO_ROUTINES == 1
signed portBASE_TYPE xQueueCRReceive( xQueueHandle pxQueue, void *pvBuffer, portTickType xTicksToWait )
{
    1948:	df 93       	push	r29
    194a:	cf 93       	push	r28
    194c:	cd b7       	in	r28, 0x3d	; 61
    194e:	de b7       	in	r29, 0x3e	; 62
    1950:	28 97       	sbiw	r28, 0x08	; 8
    1952:	0f b6       	in	r0, 0x3f	; 63
    1954:	f8 94       	cli
    1956:	de bf       	out	0x3e, r29	; 62
    1958:	0f be       	out	0x3f, r0	; 63
    195a:	cd bf       	out	0x3d, r28	; 61
    195c:	9b 83       	std	Y+3, r25	; 0x03
    195e:	8a 83       	std	Y+2, r24	; 0x02
    1960:	7d 83       	std	Y+5, r23	; 0x05
    1962:	6c 83       	std	Y+4, r22	; 0x04
    1964:	5f 83       	std	Y+7, r21	; 0x07
    1966:	4e 83       	std	Y+6, r20	; 0x06
signed portBASE_TYPE xReturn;

	/* If the queue is already empty we may have to block.  A critical section
	is required to prevent an interrupt adding something to the queue
	between the check to see if the queue is empty and blocking on the queue. */
	portDISABLE_INTERRUPTS();
    1968:	f8 94       	cli
	{
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
    196a:	ea 81       	ldd	r30, Y+2	; 0x02
    196c:	fb 81       	ldd	r31, Y+3	; 0x03
    196e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1970:	88 23       	and	r24, r24
    1972:	a9 f4       	brne	.+42     	; 0x199e <xQueueCRReceive+0x56>
		{
			/* There are no messages in the queue, do we want to block or just
			leave with nothing? */
			if( xTicksToWait > ( portTickType ) 0 )
    1974:	8e 81       	ldd	r24, Y+6	; 0x06
    1976:	9f 81       	ldd	r25, Y+7	; 0x07
    1978:	00 97       	sbiw	r24, 0x00	; 0
    197a:	71 f0       	breq	.+28     	; 0x1998 <xQueueCRReceive+0x50>
			{
				/* As this is a co-routine we cannot block directly, but return
				indicating that we need to block. */
				vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    197c:	8a 81       	ldd	r24, Y+2	; 0x02
    197e:	9b 81       	ldd	r25, Y+3	; 0x03
    1980:	9c 01       	movw	r18, r24
    1982:	2f 5e       	subi	r18, 0xEF	; 239
    1984:	3f 4f       	sbci	r19, 0xFF	; 255
    1986:	8e 81       	ldd	r24, Y+6	; 0x06
    1988:	9f 81       	ldd	r25, Y+7	; 0x07
    198a:	b9 01       	movw	r22, r18
    198c:	0e 94 ae 03 	call	0x75c	; 0x75c <vCoRoutineAddToDelayedList>
				portENABLE_INTERRUPTS();
    1990:	78 94       	sei
				return errQUEUE_BLOCKED;
    1992:	8c ef       	ldi	r24, 0xFC	; 252
    1994:	88 87       	std	Y+8, r24	; 0x08
    1996:	59 c0       	rjmp	.+178    	; 0x1a4a <xQueueCRReceive+0x102>
			}
			else
			{
				portENABLE_INTERRUPTS();
    1998:	78 94       	sei
				return errQUEUE_FULL;
    199a:	18 86       	std	Y+8, r1	; 0x08
    199c:	56 c0       	rjmp	.+172    	; 0x1a4a <xQueueCRReceive+0x102>
			}
		}
	}
	portENABLE_INTERRUPTS();
    199e:	78 94       	sei

	portNOP();
    19a0:	00 00       	nop

	portDISABLE_INTERRUPTS();
    19a2:	f8 94       	cli
	{
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    19a4:	ea 81       	ldd	r30, Y+2	; 0x02
    19a6:	fb 81       	ldd	r31, Y+3	; 0x03
    19a8:	82 8d       	ldd	r24, Z+26	; 0x1a
    19aa:	88 23       	and	r24, r24
    19ac:	09 f4       	brne	.+2      	; 0x19b0 <xQueueCRReceive+0x68>
    19ae:	49 c0       	rjmp	.+146    	; 0x1a42 <xQueueCRReceive+0xfa>
		{
			/* Data is available from the queue. */
			pxQueue->pcReadFrom += pxQueue->uxItemSize;
    19b0:	ea 81       	ldd	r30, Y+2	; 0x02
    19b2:	fb 81       	ldd	r31, Y+3	; 0x03
    19b4:	26 81       	ldd	r18, Z+6	; 0x06
    19b6:	37 81       	ldd	r19, Z+7	; 0x07
    19b8:	ea 81       	ldd	r30, Y+2	; 0x02
    19ba:	fb 81       	ldd	r31, Y+3	; 0x03
    19bc:	84 8d       	ldd	r24, Z+28	; 0x1c
    19be:	88 2f       	mov	r24, r24
    19c0:	90 e0       	ldi	r25, 0x00	; 0
    19c2:	82 0f       	add	r24, r18
    19c4:	93 1f       	adc	r25, r19
    19c6:	ea 81       	ldd	r30, Y+2	; 0x02
    19c8:	fb 81       	ldd	r31, Y+3	; 0x03
    19ca:	97 83       	std	Z+7, r25	; 0x07
    19cc:	86 83       	std	Z+6, r24	; 0x06
			if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    19ce:	ea 81       	ldd	r30, Y+2	; 0x02
    19d0:	fb 81       	ldd	r31, Y+3	; 0x03
    19d2:	26 81       	ldd	r18, Z+6	; 0x06
    19d4:	37 81       	ldd	r19, Z+7	; 0x07
    19d6:	ea 81       	ldd	r30, Y+2	; 0x02
    19d8:	fb 81       	ldd	r31, Y+3	; 0x03
    19da:	82 81       	ldd	r24, Z+2	; 0x02
    19dc:	93 81       	ldd	r25, Z+3	; 0x03
    19de:	28 17       	cp	r18, r24
    19e0:	39 07       	cpc	r19, r25
    19e2:	40 f0       	brcs	.+16     	; 0x19f4 <xQueueCRReceive+0xac>
			{
				pxQueue->pcReadFrom = pxQueue->pcHead;
    19e4:	ea 81       	ldd	r30, Y+2	; 0x02
    19e6:	fb 81       	ldd	r31, Y+3	; 0x03
    19e8:	80 81       	ld	r24, Z
    19ea:	91 81       	ldd	r25, Z+1	; 0x01
    19ec:	ea 81       	ldd	r30, Y+2	; 0x02
    19ee:	fb 81       	ldd	r31, Y+3	; 0x03
    19f0:	97 83       	std	Z+7, r25	; 0x07
    19f2:	86 83       	std	Z+6, r24	; 0x06
			}
			--( pxQueue->uxMessagesWaiting );
    19f4:	ea 81       	ldd	r30, Y+2	; 0x02
    19f6:	fb 81       	ldd	r31, Y+3	; 0x03
    19f8:	82 8d       	ldd	r24, Z+26	; 0x1a
    19fa:	81 50       	subi	r24, 0x01	; 1
    19fc:	ea 81       	ldd	r30, Y+2	; 0x02
    19fe:	fb 81       	ldd	r31, Y+3	; 0x03
    1a00:	82 8f       	std	Z+26, r24	; 0x1a
			memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1a02:	ea 81       	ldd	r30, Y+2	; 0x02
    1a04:	fb 81       	ldd	r31, Y+3	; 0x03
    1a06:	46 81       	ldd	r20, Z+6	; 0x06
    1a08:	57 81       	ldd	r21, Z+7	; 0x07
    1a0a:	ea 81       	ldd	r30, Y+2	; 0x02
    1a0c:	fb 81       	ldd	r31, Y+3	; 0x03
    1a0e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1a10:	28 2f       	mov	r18, r24
    1a12:	30 e0       	ldi	r19, 0x00	; 0
    1a14:	8c 81       	ldd	r24, Y+4	; 0x04
    1a16:	9d 81       	ldd	r25, Y+5	; 0x05
    1a18:	ba 01       	movw	r22, r20
    1a1a:	a9 01       	movw	r20, r18
    1a1c:	0e 94 76 16 	call	0x2cec	; 0x2cec <memcpy>

			xReturn = pdPASS;
    1a20:	81 e0       	ldi	r24, 0x01	; 1
    1a22:	89 83       	std	Y+1, r24	; 0x01

			/* Were any co-routines waiting for space to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    1a24:	ea 81       	ldd	r30, Y+2	; 0x02
    1a26:	fb 81       	ldd	r31, Y+3	; 0x03
    1a28:	80 85       	ldd	r24, Z+8	; 0x08
    1a2a:	88 23       	and	r24, r24
    1a2c:	59 f0       	breq	.+22     	; 0x1a44 <xQueueCRReceive+0xfc>
			{
				/* In this instance the co-routine could be placed directly
				into the ready list as we are within a critical section.
				Instead the same pending ready list mechanism is used as if
				the event were caused from within an interrupt. */
				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1a2e:	8a 81       	ldd	r24, Y+2	; 0x02
    1a30:	9b 81       	ldd	r25, Y+3	; 0x03
    1a32:	08 96       	adiw	r24, 0x08	; 8
    1a34:	0e 94 d6 05 	call	0xbac	; 0xbac <xCoRoutineRemoveFromEventList>
    1a38:	88 23       	and	r24, r24
    1a3a:	21 f0       	breq	.+8      	; 0x1a44 <xQueueCRReceive+0xfc>
				{
					xReturn = errQUEUE_YIELD;
    1a3c:	8b ef       	ldi	r24, 0xFB	; 251
    1a3e:	89 83       	std	Y+1, r24	; 0x01
    1a40:	01 c0       	rjmp	.+2      	; 0x1a44 <xQueueCRReceive+0xfc>
				}
			}
		}
		else
		{
			xReturn = pdFAIL;
    1a42:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	portENABLE_INTERRUPTS();
    1a44:	78 94       	sei

	return xReturn;
    1a46:	89 81       	ldd	r24, Y+1	; 0x01
    1a48:	88 87       	std	Y+8, r24	; 0x08
    1a4a:	88 85       	ldd	r24, Y+8	; 0x08
}
    1a4c:	28 96       	adiw	r28, 0x08	; 8
    1a4e:	0f b6       	in	r0, 0x3f	; 63
    1a50:	f8 94       	cli
    1a52:	de bf       	out	0x3e, r29	; 62
    1a54:	0f be       	out	0x3f, r0	; 63
    1a56:	cd bf       	out	0x3d, r28	; 61
    1a58:	cf 91       	pop	r28
    1a5a:	df 91       	pop	r29
    1a5c:	08 95       	ret

00001a5e <xQueueCRSendFromISR>:



#if configUSE_CO_ROUTINES == 1
signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle pxQueue, const void *pvItemToQueue, signed portBASE_TYPE xCoRoutinePreviouslyWoken )
{
    1a5e:	df 93       	push	r29
    1a60:	cf 93       	push	r28
    1a62:	00 d0       	rcall	.+0      	; 0x1a64 <xQueueCRSendFromISR+0x6>
    1a64:	00 d0       	rcall	.+0      	; 0x1a66 <xQueueCRSendFromISR+0x8>
    1a66:	00 d0       	rcall	.+0      	; 0x1a68 <xQueueCRSendFromISR+0xa>
    1a68:	cd b7       	in	r28, 0x3d	; 61
    1a6a:	de b7       	in	r29, 0x3e	; 62
    1a6c:	9a 83       	std	Y+2, r25	; 0x02
    1a6e:	89 83       	std	Y+1, r24	; 0x01
    1a70:	7c 83       	std	Y+4, r23	; 0x04
    1a72:	6b 83       	std	Y+3, r22	; 0x03
    1a74:	4d 83       	std	Y+5, r20	; 0x05
	/* Cannot block within an ISR so if there is no space on the queue then
	exit without doing anything. */
	if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1a76:	e9 81       	ldd	r30, Y+1	; 0x01
    1a78:	fa 81       	ldd	r31, Y+2	; 0x02
    1a7a:	92 8d       	ldd	r25, Z+26	; 0x1a
    1a7c:	e9 81       	ldd	r30, Y+1	; 0x01
    1a7e:	fa 81       	ldd	r31, Y+2	; 0x02
    1a80:	83 8d       	ldd	r24, Z+27	; 0x1b
    1a82:	98 17       	cp	r25, r24
    1a84:	d0 f4       	brcc	.+52     	; 0x1aba <xQueueCRSendFromISR+0x5c>
	{
		prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1a86:	89 81       	ldd	r24, Y+1	; 0x01
    1a88:	9a 81       	ldd	r25, Y+2	; 0x02
    1a8a:	2b 81       	ldd	r18, Y+3	; 0x03
    1a8c:	3c 81       	ldd	r19, Y+4	; 0x04
    1a8e:	b9 01       	movw	r22, r18
    1a90:	40 e0       	ldi	r20, 0x00	; 0
    1a92:	0e 94 a9 0a 	call	0x1552	; 0x1552 <prvCopyDataToQueue>

		/* We only want to wake one co-routine per ISR, so check that a
		co-routine has not already been woken. */
		if( !xCoRoutinePreviouslyWoken )
    1a96:	8d 81       	ldd	r24, Y+5	; 0x05
    1a98:	88 23       	and	r24, r24
    1a9a:	79 f4       	brne	.+30     	; 0x1aba <xQueueCRSendFromISR+0x5c>
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
    1a9c:	e9 81       	ldd	r30, Y+1	; 0x01
    1a9e:	fa 81       	ldd	r31, Y+2	; 0x02
    1aa0:	81 89       	ldd	r24, Z+17	; 0x11
    1aa2:	88 23       	and	r24, r24
    1aa4:	51 f0       	breq	.+20     	; 0x1aba <xQueueCRSendFromISR+0x5c>
			{
				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1aa6:	89 81       	ldd	r24, Y+1	; 0x01
    1aa8:	9a 81       	ldd	r25, Y+2	; 0x02
    1aaa:	41 96       	adiw	r24, 0x11	; 17
    1aac:	0e 94 d6 05 	call	0xbac	; 0xbac <xCoRoutineRemoveFromEventList>
    1ab0:	88 23       	and	r24, r24
    1ab2:	19 f0       	breq	.+6      	; 0x1aba <xQueueCRSendFromISR+0x5c>
				{
					return pdTRUE;
    1ab4:	81 e0       	ldi	r24, 0x01	; 1
    1ab6:	8e 83       	std	Y+6, r24	; 0x06
    1ab8:	02 c0       	rjmp	.+4      	; 0x1abe <xQueueCRSendFromISR+0x60>
				}
			}
		}
	}

	return xCoRoutinePreviouslyWoken;
    1aba:	8d 81       	ldd	r24, Y+5	; 0x05
    1abc:	8e 83       	std	Y+6, r24	; 0x06
    1abe:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1ac0:	26 96       	adiw	r28, 0x06	; 6
    1ac2:	0f b6       	in	r0, 0x3f	; 63
    1ac4:	f8 94       	cli
    1ac6:	de bf       	out	0x3e, r29	; 62
    1ac8:	0f be       	out	0x3f, r0	; 63
    1aca:	cd bf       	out	0x3d, r28	; 61
    1acc:	cf 91       	pop	r28
    1ace:	df 91       	pop	r29
    1ad0:	08 95       	ret

00001ad2 <xQueueCRReceiveFromISR>:
#endif
/*-----------------------------------------------------------*/

#if configUSE_CO_ROUTINES == 1
signed portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle pxQueue, void *pvBuffer, signed portBASE_TYPE *pxCoRoutineWoken )
{
    1ad2:	df 93       	push	r29
    1ad4:	cf 93       	push	r28
    1ad6:	cd b7       	in	r28, 0x3d	; 61
    1ad8:	de b7       	in	r29, 0x3e	; 62
    1ada:	27 97       	sbiw	r28, 0x07	; 7
    1adc:	0f b6       	in	r0, 0x3f	; 63
    1ade:	f8 94       	cli
    1ae0:	de bf       	out	0x3e, r29	; 62
    1ae2:	0f be       	out	0x3f, r0	; 63
    1ae4:	cd bf       	out	0x3d, r28	; 61
    1ae6:	9b 83       	std	Y+3, r25	; 0x03
    1ae8:	8a 83       	std	Y+2, r24	; 0x02
    1aea:	7d 83       	std	Y+5, r23	; 0x05
    1aec:	6c 83       	std	Y+4, r22	; 0x04
    1aee:	5f 83       	std	Y+7, r21	; 0x07
    1af0:	4e 83       	std	Y+6, r20	; 0x06
signed portBASE_TYPE xReturn;

	/* We cannot block from an ISR, so check there is data available. If
	not then just leave without doing anything. */
	if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1af2:	ea 81       	ldd	r30, Y+2	; 0x02
    1af4:	fb 81       	ldd	r31, Y+3	; 0x03
    1af6:	82 8d       	ldd	r24, Z+26	; 0x1a
    1af8:	88 23       	and	r24, r24
    1afa:	09 f4       	brne	.+2      	; 0x1afe <xQueueCRReceiveFromISR+0x2c>
    1afc:	50 c0       	rjmp	.+160    	; 0x1b9e <xQueueCRReceiveFromISR+0xcc>
	{
		/* Copy the data from the queue. */
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    1afe:	ea 81       	ldd	r30, Y+2	; 0x02
    1b00:	fb 81       	ldd	r31, Y+3	; 0x03
    1b02:	26 81       	ldd	r18, Z+6	; 0x06
    1b04:	37 81       	ldd	r19, Z+7	; 0x07
    1b06:	ea 81       	ldd	r30, Y+2	; 0x02
    1b08:	fb 81       	ldd	r31, Y+3	; 0x03
    1b0a:	84 8d       	ldd	r24, Z+28	; 0x1c
    1b0c:	88 2f       	mov	r24, r24
    1b0e:	90 e0       	ldi	r25, 0x00	; 0
    1b10:	82 0f       	add	r24, r18
    1b12:	93 1f       	adc	r25, r19
    1b14:	ea 81       	ldd	r30, Y+2	; 0x02
    1b16:	fb 81       	ldd	r31, Y+3	; 0x03
    1b18:	97 83       	std	Z+7, r25	; 0x07
    1b1a:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    1b1c:	ea 81       	ldd	r30, Y+2	; 0x02
    1b1e:	fb 81       	ldd	r31, Y+3	; 0x03
    1b20:	26 81       	ldd	r18, Z+6	; 0x06
    1b22:	37 81       	ldd	r19, Z+7	; 0x07
    1b24:	ea 81       	ldd	r30, Y+2	; 0x02
    1b26:	fb 81       	ldd	r31, Y+3	; 0x03
    1b28:	82 81       	ldd	r24, Z+2	; 0x02
    1b2a:	93 81       	ldd	r25, Z+3	; 0x03
    1b2c:	28 17       	cp	r18, r24
    1b2e:	39 07       	cpc	r19, r25
    1b30:	40 f0       	brcs	.+16     	; 0x1b42 <xQueueCRReceiveFromISR+0x70>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    1b32:	ea 81       	ldd	r30, Y+2	; 0x02
    1b34:	fb 81       	ldd	r31, Y+3	; 0x03
    1b36:	80 81       	ld	r24, Z
    1b38:	91 81       	ldd	r25, Z+1	; 0x01
    1b3a:	ea 81       	ldd	r30, Y+2	; 0x02
    1b3c:	fb 81       	ldd	r31, Y+3	; 0x03
    1b3e:	97 83       	std	Z+7, r25	; 0x07
    1b40:	86 83       	std	Z+6, r24	; 0x06
		}
		--( pxQueue->uxMessagesWaiting );
    1b42:	ea 81       	ldd	r30, Y+2	; 0x02
    1b44:	fb 81       	ldd	r31, Y+3	; 0x03
    1b46:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b48:	81 50       	subi	r24, 0x01	; 1
    1b4a:	ea 81       	ldd	r30, Y+2	; 0x02
    1b4c:	fb 81       	ldd	r31, Y+3	; 0x03
    1b4e:	82 8f       	std	Z+26, r24	; 0x1a
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1b50:	ea 81       	ldd	r30, Y+2	; 0x02
    1b52:	fb 81       	ldd	r31, Y+3	; 0x03
    1b54:	46 81       	ldd	r20, Z+6	; 0x06
    1b56:	57 81       	ldd	r21, Z+7	; 0x07
    1b58:	ea 81       	ldd	r30, Y+2	; 0x02
    1b5a:	fb 81       	ldd	r31, Y+3	; 0x03
    1b5c:	84 8d       	ldd	r24, Z+28	; 0x1c
    1b5e:	28 2f       	mov	r18, r24
    1b60:	30 e0       	ldi	r19, 0x00	; 0
    1b62:	8c 81       	ldd	r24, Y+4	; 0x04
    1b64:	9d 81       	ldd	r25, Y+5	; 0x05
    1b66:	ba 01       	movw	r22, r20
    1b68:	a9 01       	movw	r20, r18
    1b6a:	0e 94 76 16 	call	0x2cec	; 0x2cec <memcpy>

		if( !( *pxCoRoutineWoken ) )
    1b6e:	ee 81       	ldd	r30, Y+6	; 0x06
    1b70:	ff 81       	ldd	r31, Y+7	; 0x07
    1b72:	80 81       	ld	r24, Z
    1b74:	88 23       	and	r24, r24
    1b76:	81 f4       	brne	.+32     	; 0x1b98 <xQueueCRReceiveFromISR+0xc6>
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
    1b78:	ea 81       	ldd	r30, Y+2	; 0x02
    1b7a:	fb 81       	ldd	r31, Y+3	; 0x03
    1b7c:	80 85       	ldd	r24, Z+8	; 0x08
    1b7e:	88 23       	and	r24, r24
    1b80:	59 f0       	breq	.+22     	; 0x1b98 <xQueueCRReceiveFromISR+0xc6>
			{
				if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1b82:	8a 81       	ldd	r24, Y+2	; 0x02
    1b84:	9b 81       	ldd	r25, Y+3	; 0x03
    1b86:	08 96       	adiw	r24, 0x08	; 8
    1b88:	0e 94 d6 05 	call	0xbac	; 0xbac <xCoRoutineRemoveFromEventList>
    1b8c:	88 23       	and	r24, r24
    1b8e:	21 f0       	breq	.+8      	; 0x1b98 <xQueueCRReceiveFromISR+0xc6>
				{
					*pxCoRoutineWoken = pdTRUE;
    1b90:	ee 81       	ldd	r30, Y+6	; 0x06
    1b92:	ff 81       	ldd	r31, Y+7	; 0x07
    1b94:	81 e0       	ldi	r24, 0x01	; 1
    1b96:	80 83       	st	Z, r24
				}
			}
		}

		xReturn = pdPASS;
    1b98:	81 e0       	ldi	r24, 0x01	; 1
    1b9a:	89 83       	std	Y+1, r24	; 0x01
    1b9c:	01 c0       	rjmp	.+2      	; 0x1ba0 <xQueueCRReceiveFromISR+0xce>
	}
	else
	{
		xReturn = pdFAIL;
    1b9e:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    1ba0:	89 81       	ldd	r24, Y+1	; 0x01
}
    1ba2:	27 96       	adiw	r28, 0x07	; 7
    1ba4:	0f b6       	in	r0, 0x3f	; 63
    1ba6:	f8 94       	cli
    1ba8:	de bf       	out	0x3e, r29	; 62
    1baa:	0f be       	out	0x3f, r0	; 63
    1bac:	cd bf       	out	0x3d, r28	; 61
    1bae:	cf 91       	pop	r28
    1bb0:	df 91       	pop	r29
    1bb2:	08 95       	ret

00001bb4 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    1bb4:	af 92       	push	r10
    1bb6:	bf 92       	push	r11
    1bb8:	cf 92       	push	r12
    1bba:	df 92       	push	r13
    1bbc:	ef 92       	push	r14
    1bbe:	ff 92       	push	r15
    1bc0:	0f 93       	push	r16
    1bc2:	1f 93       	push	r17
    1bc4:	df 93       	push	r29
    1bc6:	cf 93       	push	r28
    1bc8:	cd b7       	in	r28, 0x3d	; 61
    1bca:	de b7       	in	r29, 0x3e	; 62
    1bcc:	64 97       	sbiw	r28, 0x14	; 20
    1bce:	0f b6       	in	r0, 0x3f	; 63
    1bd0:	f8 94       	cli
    1bd2:	de bf       	out	0x3e, r29	; 62
    1bd4:	0f be       	out	0x3f, r0	; 63
    1bd6:	cd bf       	out	0x3d, r28	; 61
    1bd8:	9f 83       	std	Y+7, r25	; 0x07
    1bda:	8e 83       	std	Y+6, r24	; 0x06
    1bdc:	79 87       	std	Y+9, r23	; 0x09
    1bde:	68 87       	std	Y+8, r22	; 0x08
    1be0:	5b 87       	std	Y+11, r21	; 0x0b
    1be2:	4a 87       	std	Y+10, r20	; 0x0a
    1be4:	3d 87       	std	Y+13, r19	; 0x0d
    1be6:	2c 87       	std	Y+12, r18	; 0x0c
    1be8:	0e 87       	std	Y+14, r16	; 0x0e
    1bea:	f8 8a       	std	Y+16, r15	; 0x10
    1bec:	ef 86       	std	Y+15, r14	; 0x0f
    1bee:	da 8a       	std	Y+18, r13	; 0x12
    1bf0:	c9 8a       	std	Y+17, r12	; 0x11
    1bf2:	bc 8a       	std	Y+20, r11	; 0x14
    1bf4:	ab 8a       	std	Y+19, r10	; 0x13
signed portBASE_TYPE xReturn;
tskTCB * pxNewTCB;

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    1bf6:	8a 85       	ldd	r24, Y+10	; 0x0a
    1bf8:	9b 85       	ldd	r25, Y+11	; 0x0b
    1bfa:	29 89       	ldd	r18, Y+17	; 0x11
    1bfc:	3a 89       	ldd	r19, Y+18	; 0x12
    1bfe:	b9 01       	movw	r22, r18
    1c00:	0e 94 c8 12 	call	0x2590	; 0x2590 <prvAllocateTCBAndStack>
    1c04:	9c 83       	std	Y+4, r25	; 0x04
    1c06:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    1c08:	8b 81       	ldd	r24, Y+3	; 0x03
    1c0a:	9c 81       	ldd	r25, Y+4	; 0x04
    1c0c:	00 97       	sbiw	r24, 0x00	; 0
    1c0e:	09 f4       	brne	.+2      	; 0x1c12 <xTaskGenericCreate+0x5e>
    1c10:	89 c0       	rjmp	.+274    	; 0x1d24 <xTaskGenericCreate+0x170>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
    1c12:	eb 81       	ldd	r30, Y+3	; 0x03
    1c14:	fc 81       	ldd	r31, Y+4	; 0x04
    1c16:	27 89       	ldd	r18, Z+23	; 0x17
    1c18:	30 8d       	ldd	r19, Z+24	; 0x18
    1c1a:	8a 85       	ldd	r24, Y+10	; 0x0a
    1c1c:	9b 85       	ldd	r25, Y+11	; 0x0b
    1c1e:	01 97       	sbiw	r24, 0x01	; 1
    1c20:	82 0f       	add	r24, r18
    1c22:	93 1f       	adc	r25, r19
    1c24:	9a 83       	std	Y+2, r25	; 0x02
    1c26:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    1c28:	8b 81       	ldd	r24, Y+3	; 0x03
    1c2a:	9c 81       	ldd	r25, Y+4	; 0x04
    1c2c:	28 85       	ldd	r18, Y+8	; 0x08
    1c2e:	39 85       	ldd	r19, Y+9	; 0x09
    1c30:	eb 89       	ldd	r30, Y+19	; 0x13
    1c32:	fc 89       	ldd	r31, Y+20	; 0x14
    1c34:	aa 85       	ldd	r26, Y+10	; 0x0a
    1c36:	bb 85       	ldd	r27, Y+11	; 0x0b
    1c38:	b9 01       	movw	r22, r18
    1c3a:	4e 85       	ldd	r20, Y+14	; 0x0e
    1c3c:	9f 01       	movw	r18, r30
    1c3e:	8d 01       	movw	r16, r26
    1c40:	0e 94 32 12 	call	0x2464	; 0x2464 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1c44:	89 81       	ldd	r24, Y+1	; 0x01
    1c46:	9a 81       	ldd	r25, Y+2	; 0x02
    1c48:	2e 81       	ldd	r18, Y+6	; 0x06
    1c4a:	3f 81       	ldd	r19, Y+7	; 0x07
    1c4c:	4c 85       	ldd	r20, Y+12	; 0x0c
    1c4e:	5d 85       	ldd	r21, Y+13	; 0x0d
    1c50:	b9 01       	movw	r22, r18
    1c52:	0e 94 49 00 	call	0x92	; 0x92 <pxPortInitialiseStack>
    1c56:	eb 81       	ldd	r30, Y+3	; 0x03
    1c58:	fc 81       	ldd	r31, Y+4	; 0x04
    1c5a:	91 83       	std	Z+1, r25	; 0x01
    1c5c:	80 83       	st	Z, r24
		}
		#endif

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		portENTER_CRITICAL();
    1c5e:	0f b6       	in	r0, 0x3f	; 63
    1c60:	f8 94       	cli
    1c62:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    1c64:	80 91 01 03 	lds	r24, 0x0301
    1c68:	8f 5f       	subi	r24, 0xFF	; 255
    1c6a:	80 93 01 03 	sts	0x0301, r24
			if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    1c6e:	80 91 01 03 	lds	r24, 0x0301
    1c72:	81 30       	cpi	r24, 0x01	; 1
    1c74:	49 f4       	brne	.+18     	; 0x1c88 <xTaskGenericCreate+0xd4>
			{
				/* As this is the first task it must also be the current task. */
				pxCurrentTCB =  pxNewTCB;
    1c76:	8b 81       	ldd	r24, Y+3	; 0x03
    1c78:	9c 81       	ldd	r25, Y+4	; 0x04
    1c7a:	90 93 00 03 	sts	0x0300, r25
    1c7e:	80 93 ff 02 	sts	0x02FF, r24

				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    1c82:	0e 94 88 12 	call	0x2510	; 0x2510 <prvInitialiseTaskLists>
    1c86:	12 c0       	rjmp	.+36     	; 0x1cac <xTaskGenericCreate+0xf8>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    1c88:	80 91 06 03 	lds	r24, 0x0306
    1c8c:	88 23       	and	r24, r24
    1c8e:	71 f4       	brne	.+28     	; 0x1cac <xTaskGenericCreate+0xf8>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    1c90:	e0 91 ff 02 	lds	r30, 0x02FF
    1c94:	f0 91 00 03 	lds	r31, 0x0300
    1c98:	96 89       	ldd	r25, Z+22	; 0x16
    1c9a:	8e 85       	ldd	r24, Y+14	; 0x0e
    1c9c:	89 17       	cp	r24, r25
    1c9e:	30 f0       	brcs	.+12     	; 0x1cac <xTaskGenericCreate+0xf8>
					{
						pxCurrentTCB = pxNewTCB;
    1ca0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ca2:	9c 81       	ldd	r25, Y+4	; 0x04
    1ca4:	90 93 00 03 	sts	0x0300, r25
    1ca8:	80 93 ff 02 	sts	0x02FF, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    1cac:	eb 81       	ldd	r30, Y+3	; 0x03
    1cae:	fc 81       	ldd	r31, Y+4	; 0x04
    1cb0:	96 89       	ldd	r25, Z+22	; 0x16
    1cb2:	80 91 04 03 	lds	r24, 0x0304
    1cb6:	89 17       	cp	r24, r25
    1cb8:	28 f4       	brcc	.+10     	; 0x1cc4 <xTaskGenericCreate+0x110>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    1cba:	eb 81       	ldd	r30, Y+3	; 0x03
    1cbc:	fc 81       	ldd	r31, Y+4	; 0x04
    1cbe:	86 89       	ldd	r24, Z+22	; 0x16
    1cc0:	80 93 04 03 	sts	0x0304, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    1cc4:	80 91 0b 03 	lds	r24, 0x030B
    1cc8:	8f 5f       	subi	r24, 0xFF	; 255
    1cca:	80 93 0b 03 	sts	0x030B, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    1cce:	eb 81       	ldd	r30, Y+3	; 0x03
    1cd0:	fc 81       	ldd	r31, Y+4	; 0x04
    1cd2:	96 89       	ldd	r25, Z+22	; 0x16
    1cd4:	80 91 05 03 	lds	r24, 0x0305
    1cd8:	89 17       	cp	r24, r25
    1cda:	28 f4       	brcc	.+10     	; 0x1ce6 <xTaskGenericCreate+0x132>
    1cdc:	eb 81       	ldd	r30, Y+3	; 0x03
    1cde:	fc 81       	ldd	r31, Y+4	; 0x04
    1ce0:	86 89       	ldd	r24, Z+22	; 0x16
    1ce2:	80 93 05 03 	sts	0x0305, r24
    1ce6:	eb 81       	ldd	r30, Y+3	; 0x03
    1ce8:	fc 81       	ldd	r31, Y+4	; 0x04
    1cea:	86 89       	ldd	r24, Z+22	; 0x16
    1cec:	28 2f       	mov	r18, r24
    1cee:	30 e0       	ldi	r19, 0x00	; 0
    1cf0:	c9 01       	movw	r24, r18
    1cf2:	88 0f       	add	r24, r24
    1cf4:	99 1f       	adc	r25, r25
    1cf6:	88 0f       	add	r24, r24
    1cf8:	99 1f       	adc	r25, r25
    1cfa:	88 0f       	add	r24, r24
    1cfc:	99 1f       	adc	r25, r25
    1cfe:	82 0f       	add	r24, r18
    1d00:	93 1f       	adc	r25, r19
    1d02:	ac 01       	movw	r20, r24
    1d04:	44 5f       	subi	r20, 0xF4	; 244
    1d06:	5c 4f       	sbci	r21, 0xFC	; 252
    1d08:	8b 81       	ldd	r24, Y+3	; 0x03
    1d0a:	9c 81       	ldd	r25, Y+4	; 0x04
    1d0c:	9c 01       	movw	r18, r24
    1d0e:	2e 5f       	subi	r18, 0xFE	; 254
    1d10:	3f 4f       	sbci	r19, 0xFF	; 255
    1d12:	ca 01       	movw	r24, r20
    1d14:	b9 01       	movw	r22, r18
    1d16:	0e 94 58 06 	call	0xcb0	; 0xcb0 <vListInsertEnd>

			xReturn = pdPASS;
    1d1a:	81 e0       	ldi	r24, 0x01	; 1
    1d1c:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		portEXIT_CRITICAL();
    1d1e:	0f 90       	pop	r0
    1d20:	0f be       	out	0x3f, r0	; 63
    1d22:	02 c0       	rjmp	.+4      	; 0x1d28 <xTaskGenericCreate+0x174>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1d24:	8f ef       	ldi	r24, 0xFF	; 255
    1d26:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED( pxNewTCB );
	}

	if( xReturn == pdPASS )
    1d28:	8d 81       	ldd	r24, Y+5	; 0x05
    1d2a:	81 30       	cpi	r24, 0x01	; 1
    1d2c:	c1 f4       	brne	.+48     	; 0x1d5e <xTaskGenericCreate+0x1aa>
	{
		if( ( void * ) pxCreatedTask != NULL )
    1d2e:	8f 85       	ldd	r24, Y+15	; 0x0f
    1d30:	98 89       	ldd	r25, Y+16	; 0x10
    1d32:	00 97       	sbiw	r24, 0x00	; 0
    1d34:	31 f0       	breq	.+12     	; 0x1d42 <xTaskGenericCreate+0x18e>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    1d36:	ef 85       	ldd	r30, Y+15	; 0x0f
    1d38:	f8 89       	ldd	r31, Y+16	; 0x10
    1d3a:	8b 81       	ldd	r24, Y+3	; 0x03
    1d3c:	9c 81       	ldd	r25, Y+4	; 0x04
    1d3e:	91 83       	std	Z+1, r25	; 0x01
    1d40:	80 83       	st	Z, r24
		}

		if( xSchedulerRunning != pdFALSE )
    1d42:	80 91 06 03 	lds	r24, 0x0306
    1d46:	88 23       	and	r24, r24
    1d48:	51 f0       	breq	.+20     	; 0x1d5e <xTaskGenericCreate+0x1aa>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1d4a:	e0 91 ff 02 	lds	r30, 0x02FF
    1d4e:	f0 91 00 03 	lds	r31, 0x0300
    1d52:	96 89       	ldd	r25, Z+22	; 0x16
    1d54:	8e 85       	ldd	r24, Y+14	; 0x0e
    1d56:	98 17       	cp	r25, r24
    1d58:	10 f4       	brcc	.+4      	; 0x1d5e <xTaskGenericCreate+0x1aa>
			{
				portYIELD_WITHIN_API();
    1d5a:	0e 94 08 02 	call	0x410	; 0x410 <vPortYield>
			}
		}
	}

	return xReturn;
    1d5e:	8d 81       	ldd	r24, Y+5	; 0x05
}
    1d60:	64 96       	adiw	r28, 0x14	; 20
    1d62:	0f b6       	in	r0, 0x3f	; 63
    1d64:	f8 94       	cli
    1d66:	de bf       	out	0x3e, r29	; 62
    1d68:	0f be       	out	0x3f, r0	; 63
    1d6a:	cd bf       	out	0x3d, r28	; 61
    1d6c:	cf 91       	pop	r28
    1d6e:	df 91       	pop	r29
    1d70:	1f 91       	pop	r17
    1d72:	0f 91       	pop	r16
    1d74:	ff 90       	pop	r15
    1d76:	ef 90       	pop	r14
    1d78:	df 90       	pop	r13
    1d7a:	cf 90       	pop	r12
    1d7c:	bf 90       	pop	r11
    1d7e:	af 90       	pop	r10
    1d80:	08 95       	ret

00001d82 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    1d82:	af 92       	push	r10
    1d84:	bf 92       	push	r11
    1d86:	cf 92       	push	r12
    1d88:	df 92       	push	r13
    1d8a:	ef 92       	push	r14
    1d8c:	ff 92       	push	r15
    1d8e:	0f 93       	push	r16
    1d90:	df 93       	push	r29
    1d92:	cf 93       	push	r28
    1d94:	0f 92       	push	r0
    1d96:	cd b7       	in	r28, 0x3d	; 61
    1d98:	de b7       	in	r29, 0x3e	; 62
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
    1d9a:	86 e2       	ldi	r24, 0x26	; 38
    1d9c:	92 e1       	ldi	r25, 0x12	; 18
    1d9e:	20 e6       	ldi	r18, 0x60	; 96
    1da0:	30 e0       	ldi	r19, 0x00	; 0
    1da2:	b9 01       	movw	r22, r18
    1da4:	4e e5       	ldi	r20, 0x5E	; 94
    1da6:	51 e0       	ldi	r21, 0x01	; 1
    1da8:	20 e0       	ldi	r18, 0x00	; 0
    1daa:	30 e0       	ldi	r19, 0x00	; 0
    1dac:	00 e0       	ldi	r16, 0x00	; 0
    1dae:	ee 24       	eor	r14, r14
    1db0:	ff 24       	eor	r15, r15
    1db2:	cc 24       	eor	r12, r12
    1db4:	dd 24       	eor	r13, r13
    1db6:	aa 24       	eor	r10, r10
    1db8:	bb 24       	eor	r11, r11
    1dba:	0e 94 da 0d 	call	0x1bb4	; 0x1bb4 <xTaskGenericCreate>
    1dbe:	89 83       	std	Y+1, r24	; 0x01

	if( xReturn == pdPASS )
    1dc0:	89 81       	ldd	r24, Y+1	; 0x01
    1dc2:	81 30       	cpi	r24, 0x01	; 1
    1dc4:	51 f4       	brne	.+20     	; 0x1dda <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    1dc6:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    1dc8:	81 e0       	ldi	r24, 0x01	; 1
    1dca:	80 93 06 03 	sts	0x0306, r24
		xTickCount = ( portTickType ) 0;
    1dce:	10 92 03 03 	sts	0x0303, r1
    1dd2:	10 92 02 03 	sts	0x0302, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
    1dd6:	0e 94 cc 01 	call	0x398	; 0x398 <xPortStartScheduler>
		else
		{
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}
}
    1dda:	0f 90       	pop	r0
    1ddc:	cf 91       	pop	r28
    1dde:	df 91       	pop	r29
    1de0:	0f 91       	pop	r16
    1de2:	ff 90       	pop	r15
    1de4:	ef 90       	pop	r14
    1de6:	df 90       	pop	r13
    1de8:	cf 90       	pop	r12
    1dea:	bf 90       	pop	r11
    1dec:	af 90       	pop	r10
    1dee:	08 95       	ret

00001df0 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    1df0:	df 93       	push	r29
    1df2:	cf 93       	push	r28
    1df4:	cd b7       	in	r28, 0x3d	; 61
    1df6:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1df8:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    1dfa:	10 92 06 03 	sts	0x0306, r1
	vPortEndScheduler();
    1dfe:	0e 94 01 02 	call	0x402	; 0x402 <vPortEndScheduler>
}
    1e02:	cf 91       	pop	r28
    1e04:	df 91       	pop	r29
    1e06:	08 95       	ret

00001e08 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    1e08:	df 93       	push	r29
    1e0a:	cf 93       	push	r28
    1e0c:	cd b7       	in	r28, 0x3d	; 61
    1e0e:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    1e10:	80 91 07 03 	lds	r24, 0x0307
    1e14:	8f 5f       	subi	r24, 0xFF	; 255
    1e16:	80 93 07 03 	sts	0x0307, r24
}
    1e1a:	cf 91       	pop	r28
    1e1c:	df 91       	pop	r29
    1e1e:	08 95       	ret

00001e20 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    1e20:	df 93       	push	r29
    1e22:	cf 93       	push	r28
    1e24:	00 d0       	rcall	.+0      	; 0x1e26 <xTaskResumeAll+0x6>
    1e26:	00 d0       	rcall	.+0      	; 0x1e28 <xTaskResumeAll+0x8>
    1e28:	00 d0       	rcall	.+0      	; 0x1e2a <xTaskResumeAll+0xa>
    1e2a:	cd b7       	in	r28, 0x3d	; 61
    1e2c:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    1e2e:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	portENTER_CRITICAL();
    1e30:	0f b6       	in	r0, 0x3f	; 63
    1e32:	f8 94       	cli
    1e34:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1e36:	80 91 07 03 	lds	r24, 0x0307
    1e3a:	81 50       	subi	r24, 0x01	; 1
    1e3c:	80 93 07 03 	sts	0x0307, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1e40:	80 91 07 03 	lds	r24, 0x0307
    1e44:	88 23       	and	r24, r24
    1e46:	09 f0       	breq	.+2      	; 0x1e4a <xTaskResumeAll+0x2a>
    1e48:	77 c0       	rjmp	.+238    	; 0x1f38 <xTaskResumeAll+0x118>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
    1e4a:	80 91 01 03 	lds	r24, 0x0301
    1e4e:	88 23       	and	r24, r24
    1e50:	09 f4       	brne	.+2      	; 0x1e54 <xTaskResumeAll+0x34>
    1e52:	72 c0       	rjmp	.+228    	; 0x1f38 <xTaskResumeAll+0x118>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    1e54:	19 82       	std	Y+1, r1	; 0x01
    1e56:	39 c0       	rjmp	.+114    	; 0x1eca <xTaskResumeAll+0xaa>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
				{
					vListRemove( &( pxTCB->xEventListItem ) );
    1e58:	8b 81       	ldd	r24, Y+3	; 0x03
    1e5a:	9c 81       	ldd	r25, Y+4	; 0x04
    1e5c:	0c 96       	adiw	r24, 0x0c	; 12
    1e5e:	0e 94 10 07 	call	0xe20	; 0xe20 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    1e62:	8b 81       	ldd	r24, Y+3	; 0x03
    1e64:	9c 81       	ldd	r25, Y+4	; 0x04
    1e66:	02 96       	adiw	r24, 0x02	; 2
    1e68:	0e 94 10 07 	call	0xe20	; 0xe20 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    1e6c:	eb 81       	ldd	r30, Y+3	; 0x03
    1e6e:	fc 81       	ldd	r31, Y+4	; 0x04
    1e70:	96 89       	ldd	r25, Z+22	; 0x16
    1e72:	80 91 05 03 	lds	r24, 0x0305
    1e76:	89 17       	cp	r24, r25
    1e78:	28 f4       	brcc	.+10     	; 0x1e84 <xTaskResumeAll+0x64>
    1e7a:	eb 81       	ldd	r30, Y+3	; 0x03
    1e7c:	fc 81       	ldd	r31, Y+4	; 0x04
    1e7e:	86 89       	ldd	r24, Z+22	; 0x16
    1e80:	80 93 05 03 	sts	0x0305, r24
    1e84:	eb 81       	ldd	r30, Y+3	; 0x03
    1e86:	fc 81       	ldd	r31, Y+4	; 0x04
    1e88:	86 89       	ldd	r24, Z+22	; 0x16
    1e8a:	28 2f       	mov	r18, r24
    1e8c:	30 e0       	ldi	r19, 0x00	; 0
    1e8e:	c9 01       	movw	r24, r18
    1e90:	88 0f       	add	r24, r24
    1e92:	99 1f       	adc	r25, r25
    1e94:	88 0f       	add	r24, r24
    1e96:	99 1f       	adc	r25, r25
    1e98:	88 0f       	add	r24, r24
    1e9a:	99 1f       	adc	r25, r25
    1e9c:	82 0f       	add	r24, r18
    1e9e:	93 1f       	adc	r25, r19
    1ea0:	84 5f       	subi	r24, 0xF4	; 244
    1ea2:	9c 4f       	sbci	r25, 0xFC	; 252
    1ea4:	2b 81       	ldd	r18, Y+3	; 0x03
    1ea6:	3c 81       	ldd	r19, Y+4	; 0x04
    1ea8:	2e 5f       	subi	r18, 0xFE	; 254
    1eaa:	3f 4f       	sbci	r19, 0xFF	; 255
    1eac:	b9 01       	movw	r22, r18
    1eae:	0e 94 58 06 	call	0xcb0	; 0xcb0 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1eb2:	eb 81       	ldd	r30, Y+3	; 0x03
    1eb4:	fc 81       	ldd	r31, Y+4	; 0x04
    1eb6:	96 89       	ldd	r25, Z+22	; 0x16
    1eb8:	e0 91 ff 02 	lds	r30, 0x02FF
    1ebc:	f0 91 00 03 	lds	r31, 0x0300
    1ec0:	86 89       	ldd	r24, Z+22	; 0x16
    1ec2:	98 17       	cp	r25, r24
    1ec4:	10 f0       	brcs	.+4      	; 0x1eca <xTaskResumeAll+0xaa>
					{
						xYieldRequired = pdTRUE;
    1ec6:	81 e0       	ldi	r24, 0x01	; 1
    1ec8:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
    1eca:	80 91 2b 03 	lds	r24, 0x032B
    1ece:	88 23       	and	r24, r24
    1ed0:	49 f0       	breq	.+18     	; 0x1ee4 <xTaskResumeAll+0xc4>
    1ed2:	e0 91 30 03 	lds	r30, 0x0330
    1ed6:	f0 91 31 03 	lds	r31, 0x0331
    1eda:	86 81       	ldd	r24, Z+6	; 0x06
    1edc:	97 81       	ldd	r25, Z+7	; 0x07
    1ede:	9e 83       	std	Y+6, r25	; 0x06
    1ee0:	8d 83       	std	Y+5, r24	; 0x05
    1ee2:	02 c0       	rjmp	.+4      	; 0x1ee8 <xTaskResumeAll+0xc8>
    1ee4:	1e 82       	std	Y+6, r1	; 0x06
    1ee6:	1d 82       	std	Y+5, r1	; 0x05
    1ee8:	8d 81       	ldd	r24, Y+5	; 0x05
    1eea:	9e 81       	ldd	r25, Y+6	; 0x06
    1eec:	9c 83       	std	Y+4, r25	; 0x04
    1eee:	8b 83       	std	Y+3, r24	; 0x03
    1ef0:	eb 81       	ldd	r30, Y+3	; 0x03
    1ef2:	fc 81       	ldd	r31, Y+4	; 0x04
    1ef4:	30 97       	sbiw	r30, 0x00	; 0
    1ef6:	09 f0       	breq	.+2      	; 0x1efa <xTaskResumeAll+0xda>
    1ef8:	af cf       	rjmp	.-162    	; 0x1e58 <xTaskResumeAll+0x38>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    1efa:	80 91 08 03 	lds	r24, 0x0308
    1efe:	88 23       	and	r24, r24
    1f00:	71 f0       	breq	.+28     	; 0x1f1e <xTaskResumeAll+0xfe>
    1f02:	07 c0       	rjmp	.+14     	; 0x1f12 <xTaskResumeAll+0xf2>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
					{
						vTaskIncrementTick();
    1f04:	0e 94 c8 0f 	call	0x1f90	; 0x1f90 <vTaskIncrementTick>
						--uxMissedTicks;
    1f08:	80 91 08 03 	lds	r24, 0x0308
    1f0c:	81 50       	subi	r24, 0x01	; 1
    1f0e:	80 93 08 03 	sts	0x0308, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
    1f12:	80 91 08 03 	lds	r24, 0x0308
    1f16:	88 23       	and	r24, r24
    1f18:	a9 f7       	brne	.-22     	; 0x1f04 <xTaskResumeAll+0xe4>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    1f1a:	81 e0       	ldi	r24, 0x01	; 1
    1f1c:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    1f1e:	89 81       	ldd	r24, Y+1	; 0x01
    1f20:	81 30       	cpi	r24, 0x01	; 1
    1f22:	21 f0       	breq	.+8      	; 0x1f2c <xTaskResumeAll+0x10c>
    1f24:	80 91 09 03 	lds	r24, 0x0309
    1f28:	81 30       	cpi	r24, 0x01	; 1
    1f2a:	31 f4       	brne	.+12     	; 0x1f38 <xTaskResumeAll+0x118>
				{
					xAlreadyYielded = pdTRUE;
    1f2c:	81 e0       	ldi	r24, 0x01	; 1
    1f2e:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    1f30:	10 92 09 03 	sts	0x0309, r1
					portYIELD_WITHIN_API();
    1f34:	0e 94 08 02 	call	0x410	; 0x410 <vPortYield>
				}
			}
		}
	}
	portEXIT_CRITICAL();
    1f38:	0f 90       	pop	r0
    1f3a:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    1f3c:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1f3e:	26 96       	adiw	r28, 0x06	; 6
    1f40:	0f b6       	in	r0, 0x3f	; 63
    1f42:	f8 94       	cli
    1f44:	de bf       	out	0x3e, r29	; 62
    1f46:	0f be       	out	0x3f, r0	; 63
    1f48:	cd bf       	out	0x3d, r28	; 61
    1f4a:	cf 91       	pop	r28
    1f4c:	df 91       	pop	r29
    1f4e:	08 95       	ret

00001f50 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    1f50:	df 93       	push	r29
    1f52:	cf 93       	push	r28
    1f54:	00 d0       	rcall	.+0      	; 0x1f56 <xTaskGetTickCount+0x6>
    1f56:	cd b7       	in	r28, 0x3d	; 61
    1f58:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portENTER_CRITICAL();
    1f5a:	0f b6       	in	r0, 0x3f	; 63
    1f5c:	f8 94       	cli
    1f5e:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    1f60:	80 91 02 03 	lds	r24, 0x0302
    1f64:	90 91 03 03 	lds	r25, 0x0303
    1f68:	9a 83       	std	Y+2, r25	; 0x02
    1f6a:	89 83       	std	Y+1, r24	; 0x01
	}
	portEXIT_CRITICAL();
    1f6c:	0f 90       	pop	r0
    1f6e:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    1f70:	89 81       	ldd	r24, Y+1	; 0x01
    1f72:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1f74:	0f 90       	pop	r0
    1f76:	0f 90       	pop	r0
    1f78:	cf 91       	pop	r28
    1f7a:	df 91       	pop	r29
    1f7c:	08 95       	ret

00001f7e <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    1f7e:	df 93       	push	r29
    1f80:	cf 93       	push	r28
    1f82:	cd b7       	in	r28, 0x3d	; 61
    1f84:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    1f86:	80 91 01 03 	lds	r24, 0x0301
}
    1f8a:	cf 91       	pop	r28
    1f8c:	df 91       	pop	r29
    1f8e:	08 95       	ret

00001f90 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
    1f90:	df 93       	push	r29
    1f92:	cf 93       	push	r28
    1f94:	00 d0       	rcall	.+0      	; 0x1f96 <vTaskIncrementTick+0x6>
    1f96:	00 d0       	rcall	.+0      	; 0x1f98 <vTaskIncrementTick+0x8>
    1f98:	00 d0       	rcall	.+0      	; 0x1f9a <vTaskIncrementTick+0xa>
    1f9a:	cd b7       	in	r28, 0x3d	; 61
    1f9c:	de b7       	in	r29, 0x3e	; 62
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1f9e:	80 91 07 03 	lds	r24, 0x0307
    1fa2:	88 23       	and	r24, r24
    1fa4:	09 f0       	breq	.+2      	; 0x1fa8 <vTaskIncrementTick+0x18>
    1fa6:	88 c0       	rjmp	.+272    	; 0x20b8 <vTaskIncrementTick+0x128>
	{
		++xTickCount;
    1fa8:	80 91 02 03 	lds	r24, 0x0302
    1fac:	90 91 03 03 	lds	r25, 0x0303
    1fb0:	01 96       	adiw	r24, 0x01	; 1
    1fb2:	90 93 03 03 	sts	0x0303, r25
    1fb6:	80 93 02 03 	sts	0x0302, r24
		if( xTickCount == ( portTickType ) 0 )
    1fba:	80 91 02 03 	lds	r24, 0x0302
    1fbe:	90 91 03 03 	lds	r25, 0x0303
    1fc2:	00 97       	sbiw	r24, 0x00	; 0
    1fc4:	09 f0       	breq	.+2      	; 0x1fc8 <vTaskIncrementTick+0x38>
    1fc6:	59 c0       	rjmp	.+178    	; 0x207a <vTaskIncrementTick+0xea>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
    1fc8:	80 91 27 03 	lds	r24, 0x0327
    1fcc:	90 91 28 03 	lds	r25, 0x0328
    1fd0:	9a 83       	std	Y+2, r25	; 0x02
    1fd2:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    1fd4:	80 91 29 03 	lds	r24, 0x0329
    1fd8:	90 91 2a 03 	lds	r25, 0x032A
    1fdc:	90 93 28 03 	sts	0x0328, r25
    1fe0:	80 93 27 03 	sts	0x0327, r24
			pxOverflowDelayedTaskList = pxTemp;
    1fe4:	89 81       	ldd	r24, Y+1	; 0x01
    1fe6:	9a 81       	ldd	r25, Y+2	; 0x02
    1fe8:	90 93 2a 03 	sts	0x032A, r25
    1fec:	80 93 29 03 	sts	0x0329, r24
			xNumOfOverflows++;
    1ff0:	80 91 0a 03 	lds	r24, 0x030A
    1ff4:	8f 5f       	subi	r24, 0xFF	; 255
    1ff6:	80 93 0a 03 	sts	0x030A, r24
    1ffa:	3f c0       	rjmp	.+126    	; 0x207a <vTaskIncrementTick+0xea>
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    1ffc:	eb 81       	ldd	r30, Y+3	; 0x03
    1ffe:	fc 81       	ldd	r31, Y+4	; 0x04
    2000:	22 81       	ldd	r18, Z+2	; 0x02
    2002:	33 81       	ldd	r19, Z+3	; 0x03
    2004:	80 91 02 03 	lds	r24, 0x0302
    2008:	90 91 03 03 	lds	r25, 0x0303
    200c:	82 17       	cp	r24, r18
    200e:	93 07       	cpc	r25, r19
    2010:	08 f4       	brcc	.+2      	; 0x2014 <vTaskIncrementTick+0x84>
    2012:	57 c0       	rjmp	.+174    	; 0x20c2 <vTaskIncrementTick+0x132>
    2014:	8b 81       	ldd	r24, Y+3	; 0x03
    2016:	9c 81       	ldd	r25, Y+4	; 0x04
    2018:	02 96       	adiw	r24, 0x02	; 2
    201a:	0e 94 10 07 	call	0xe20	; 0xe20 <vListRemove>
    201e:	eb 81       	ldd	r30, Y+3	; 0x03
    2020:	fc 81       	ldd	r31, Y+4	; 0x04
    2022:	84 89       	ldd	r24, Z+20	; 0x14
    2024:	95 89       	ldd	r25, Z+21	; 0x15
    2026:	00 97       	sbiw	r24, 0x00	; 0
    2028:	29 f0       	breq	.+10     	; 0x2034 <vTaskIncrementTick+0xa4>
    202a:	8b 81       	ldd	r24, Y+3	; 0x03
    202c:	9c 81       	ldd	r25, Y+4	; 0x04
    202e:	0c 96       	adiw	r24, 0x0c	; 12
    2030:	0e 94 10 07 	call	0xe20	; 0xe20 <vListRemove>
    2034:	eb 81       	ldd	r30, Y+3	; 0x03
    2036:	fc 81       	ldd	r31, Y+4	; 0x04
    2038:	96 89       	ldd	r25, Z+22	; 0x16
    203a:	80 91 05 03 	lds	r24, 0x0305
    203e:	89 17       	cp	r24, r25
    2040:	28 f4       	brcc	.+10     	; 0x204c <vTaskIncrementTick+0xbc>
    2042:	eb 81       	ldd	r30, Y+3	; 0x03
    2044:	fc 81       	ldd	r31, Y+4	; 0x04
    2046:	86 89       	ldd	r24, Z+22	; 0x16
    2048:	80 93 05 03 	sts	0x0305, r24
    204c:	eb 81       	ldd	r30, Y+3	; 0x03
    204e:	fc 81       	ldd	r31, Y+4	; 0x04
    2050:	86 89       	ldd	r24, Z+22	; 0x16
    2052:	28 2f       	mov	r18, r24
    2054:	30 e0       	ldi	r19, 0x00	; 0
    2056:	c9 01       	movw	r24, r18
    2058:	88 0f       	add	r24, r24
    205a:	99 1f       	adc	r25, r25
    205c:	88 0f       	add	r24, r24
    205e:	99 1f       	adc	r25, r25
    2060:	88 0f       	add	r24, r24
    2062:	99 1f       	adc	r25, r25
    2064:	82 0f       	add	r24, r18
    2066:	93 1f       	adc	r25, r19
    2068:	84 5f       	subi	r24, 0xF4	; 244
    206a:	9c 4f       	sbci	r25, 0xFC	; 252
    206c:	2b 81       	ldd	r18, Y+3	; 0x03
    206e:	3c 81       	ldd	r19, Y+4	; 0x04
    2070:	2e 5f       	subi	r18, 0xFE	; 254
    2072:	3f 4f       	sbci	r19, 0xFF	; 255
    2074:	b9 01       	movw	r22, r18
    2076:	0e 94 58 06 	call	0xcb0	; 0xcb0 <vListInsertEnd>
    207a:	e0 91 27 03 	lds	r30, 0x0327
    207e:	f0 91 28 03 	lds	r31, 0x0328
    2082:	80 81       	ld	r24, Z
    2084:	88 23       	and	r24, r24
    2086:	61 f0       	breq	.+24     	; 0x20a0 <vTaskIncrementTick+0x110>
    2088:	e0 91 27 03 	lds	r30, 0x0327
    208c:	f0 91 28 03 	lds	r31, 0x0328
    2090:	05 80       	ldd	r0, Z+5	; 0x05
    2092:	f6 81       	ldd	r31, Z+6	; 0x06
    2094:	e0 2d       	mov	r30, r0
    2096:	86 81       	ldd	r24, Z+6	; 0x06
    2098:	97 81       	ldd	r25, Z+7	; 0x07
    209a:	9e 83       	std	Y+6, r25	; 0x06
    209c:	8d 83       	std	Y+5, r24	; 0x05
    209e:	02 c0       	rjmp	.+4      	; 0x20a4 <vTaskIncrementTick+0x114>
    20a0:	1e 82       	std	Y+6, r1	; 0x06
    20a2:	1d 82       	std	Y+5, r1	; 0x05
    20a4:	8d 81       	ldd	r24, Y+5	; 0x05
    20a6:	9e 81       	ldd	r25, Y+6	; 0x06
    20a8:	9c 83       	std	Y+4, r25	; 0x04
    20aa:	8b 83       	std	Y+3, r24	; 0x03
    20ac:	eb 81       	ldd	r30, Y+3	; 0x03
    20ae:	fc 81       	ldd	r31, Y+4	; 0x04
    20b0:	30 97       	sbiw	r30, 0x00	; 0
    20b2:	09 f0       	breq	.+2      	; 0x20b6 <vTaskIncrementTick+0x126>
    20b4:	a3 cf       	rjmp	.-186    	; 0x1ffc <vTaskIncrementTick+0x6c>
    20b6:	05 c0       	rjmp	.+10     	; 0x20c2 <vTaskIncrementTick+0x132>
	}
	else
	{
		++uxMissedTicks;
    20b8:	80 91 08 03 	lds	r24, 0x0308
    20bc:	8f 5f       	subi	r24, 0xFF	; 255
    20be:	80 93 08 03 	sts	0x0308, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    20c2:	26 96       	adiw	r28, 0x06	; 6
    20c4:	0f b6       	in	r0, 0x3f	; 63
    20c6:	f8 94       	cli
    20c8:	de bf       	out	0x3e, r29	; 62
    20ca:	0f be       	out	0x3f, r0	; 63
    20cc:	cd bf       	out	0x3d, r28	; 61
    20ce:	cf 91       	pop	r28
    20d0:	df 91       	pop	r29
    20d2:	08 95       	ret

000020d4 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    20d4:	df 93       	push	r29
    20d6:	cf 93       	push	r28
    20d8:	00 d0       	rcall	.+0      	; 0x20da <vTaskSwitchContext+0x6>
    20da:	cd b7       	in	r28, 0x3d	; 61
    20dc:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    20de:	80 91 07 03 	lds	r24, 0x0307
    20e2:	88 23       	and	r24, r24
    20e4:	49 f0       	breq	.+18     	; 0x20f8 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    20e6:	81 e0       	ldi	r24, 0x01	; 1
    20e8:	80 93 09 03 	sts	0x0309, r24
    20ec:	54 c0       	rjmp	.+168    	; 0x2196 <vTaskSwitchContext+0xc2>
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
	{
		--uxTopReadyPriority;
    20ee:	80 91 05 03 	lds	r24, 0x0305
    20f2:	81 50       	subi	r24, 0x01	; 1
    20f4:	80 93 05 03 	sts	0x0305, r24

	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    20f8:	80 91 05 03 	lds	r24, 0x0305
    20fc:	28 2f       	mov	r18, r24
    20fe:	30 e0       	ldi	r19, 0x00	; 0
    2100:	c9 01       	movw	r24, r18
    2102:	88 0f       	add	r24, r24
    2104:	99 1f       	adc	r25, r25
    2106:	88 0f       	add	r24, r24
    2108:	99 1f       	adc	r25, r25
    210a:	88 0f       	add	r24, r24
    210c:	99 1f       	adc	r25, r25
    210e:	82 0f       	add	r24, r18
    2110:	93 1f       	adc	r25, r19
    2112:	fc 01       	movw	r30, r24
    2114:	e4 5f       	subi	r30, 0xF4	; 244
    2116:	fc 4f       	sbci	r31, 0xFC	; 252
    2118:	80 81       	ld	r24, Z
    211a:	88 23       	and	r24, r24
    211c:	41 f3       	breq	.-48     	; 0x20ee <vTaskSwitchContext+0x1a>
		--uxTopReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    211e:	80 91 05 03 	lds	r24, 0x0305
    2122:	28 2f       	mov	r18, r24
    2124:	30 e0       	ldi	r19, 0x00	; 0
    2126:	c9 01       	movw	r24, r18
    2128:	88 0f       	add	r24, r24
    212a:	99 1f       	adc	r25, r25
    212c:	88 0f       	add	r24, r24
    212e:	99 1f       	adc	r25, r25
    2130:	88 0f       	add	r24, r24
    2132:	99 1f       	adc	r25, r25
    2134:	82 0f       	add	r24, r18
    2136:	93 1f       	adc	r25, r19
    2138:	84 5f       	subi	r24, 0xF4	; 244
    213a:	9c 4f       	sbci	r25, 0xFC	; 252
    213c:	9a 83       	std	Y+2, r25	; 0x02
    213e:	89 83       	std	Y+1, r24	; 0x01
    2140:	e9 81       	ldd	r30, Y+1	; 0x01
    2142:	fa 81       	ldd	r31, Y+2	; 0x02
    2144:	01 80       	ldd	r0, Z+1	; 0x01
    2146:	f2 81       	ldd	r31, Z+2	; 0x02
    2148:	e0 2d       	mov	r30, r0
    214a:	82 81       	ldd	r24, Z+2	; 0x02
    214c:	93 81       	ldd	r25, Z+3	; 0x03
    214e:	e9 81       	ldd	r30, Y+1	; 0x01
    2150:	fa 81       	ldd	r31, Y+2	; 0x02
    2152:	92 83       	std	Z+2, r25	; 0x02
    2154:	81 83       	std	Z+1, r24	; 0x01
    2156:	e9 81       	ldd	r30, Y+1	; 0x01
    2158:	fa 81       	ldd	r31, Y+2	; 0x02
    215a:	21 81       	ldd	r18, Z+1	; 0x01
    215c:	32 81       	ldd	r19, Z+2	; 0x02
    215e:	89 81       	ldd	r24, Y+1	; 0x01
    2160:	9a 81       	ldd	r25, Y+2	; 0x02
    2162:	03 96       	adiw	r24, 0x03	; 3
    2164:	28 17       	cp	r18, r24
    2166:	39 07       	cpc	r19, r25
    2168:	59 f4       	brne	.+22     	; 0x2180 <vTaskSwitchContext+0xac>
    216a:	e9 81       	ldd	r30, Y+1	; 0x01
    216c:	fa 81       	ldd	r31, Y+2	; 0x02
    216e:	01 80       	ldd	r0, Z+1	; 0x01
    2170:	f2 81       	ldd	r31, Z+2	; 0x02
    2172:	e0 2d       	mov	r30, r0
    2174:	82 81       	ldd	r24, Z+2	; 0x02
    2176:	93 81       	ldd	r25, Z+3	; 0x03
    2178:	e9 81       	ldd	r30, Y+1	; 0x01
    217a:	fa 81       	ldd	r31, Y+2	; 0x02
    217c:	92 83       	std	Z+2, r25	; 0x02
    217e:	81 83       	std	Z+1, r24	; 0x01
    2180:	e9 81       	ldd	r30, Y+1	; 0x01
    2182:	fa 81       	ldd	r31, Y+2	; 0x02
    2184:	01 80       	ldd	r0, Z+1	; 0x01
    2186:	f2 81       	ldd	r31, Z+2	; 0x02
    2188:	e0 2d       	mov	r30, r0
    218a:	86 81       	ldd	r24, Z+6	; 0x06
    218c:	97 81       	ldd	r25, Z+7	; 0x07
    218e:	90 93 00 03 	sts	0x0300, r25
    2192:	80 93 ff 02 	sts	0x02FF, r24

	traceTASK_SWITCHED_IN();
	vWriteTraceToBuffer();
}
    2196:	0f 90       	pop	r0
    2198:	0f 90       	pop	r0
    219a:	cf 91       	pop	r28
    219c:	df 91       	pop	r29
    219e:	08 95       	ret

000021a0 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    21a0:	df 93       	push	r29
    21a2:	cf 93       	push	r28
    21a4:	00 d0       	rcall	.+0      	; 0x21a6 <vTaskPlaceOnEventList+0x6>
    21a6:	00 d0       	rcall	.+0      	; 0x21a8 <vTaskPlaceOnEventList+0x8>
    21a8:	00 d0       	rcall	.+0      	; 0x21aa <vTaskPlaceOnEventList+0xa>
    21aa:	cd b7       	in	r28, 0x3d	; 61
    21ac:	de b7       	in	r29, 0x3e	; 62
    21ae:	9c 83       	std	Y+4, r25	; 0x04
    21b0:	8b 83       	std	Y+3, r24	; 0x03
    21b2:	7e 83       	std	Y+6, r23	; 0x06
    21b4:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    21b6:	4b 81       	ldd	r20, Y+3	; 0x03
    21b8:	5c 81       	ldd	r21, Y+4	; 0x04
    21ba:	80 91 ff 02 	lds	r24, 0x02FF
    21be:	90 91 00 03 	lds	r25, 0x0300
    21c2:	9c 01       	movw	r18, r24
    21c4:	24 5f       	subi	r18, 0xF4	; 244
    21c6:	3f 4f       	sbci	r19, 0xFF	; 255
    21c8:	ca 01       	movw	r24, r20
    21ca:	b9 01       	movw	r22, r18
    21cc:	0e 94 a4 06 	call	0xd48	; 0xd48 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    21d0:	80 91 ff 02 	lds	r24, 0x02FF
    21d4:	90 91 00 03 	lds	r25, 0x0300
    21d8:	02 96       	adiw	r24, 0x02	; 2
    21da:	0e 94 10 07 	call	0xe20	; 0xe20 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    21de:	20 91 02 03 	lds	r18, 0x0302
    21e2:	30 91 03 03 	lds	r19, 0x0303
    21e6:	8d 81       	ldd	r24, Y+5	; 0x05
    21e8:	9e 81       	ldd	r25, Y+6	; 0x06
    21ea:	82 0f       	add	r24, r18
    21ec:	93 1f       	adc	r25, r19
    21ee:	9a 83       	std	Y+2, r25	; 0x02
    21f0:	89 83       	std	Y+1, r24	; 0x01

			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    21f2:	e0 91 ff 02 	lds	r30, 0x02FF
    21f6:	f0 91 00 03 	lds	r31, 0x0300
    21fa:	89 81       	ldd	r24, Y+1	; 0x01
    21fc:	9a 81       	ldd	r25, Y+2	; 0x02
    21fe:	93 83       	std	Z+3, r25	; 0x03
    2200:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xTickCount )
    2202:	20 91 02 03 	lds	r18, 0x0302
    2206:	30 91 03 03 	lds	r19, 0x0303
    220a:	89 81       	ldd	r24, Y+1	; 0x01
    220c:	9a 81       	ldd	r25, Y+2	; 0x02
    220e:	82 17       	cp	r24, r18
    2210:	93 07       	cpc	r25, r19
    2212:	70 f4       	brcc	.+28     	; 0x2230 <vTaskPlaceOnEventList+0x90>
			{
				/* Wake time has overflowed.  Place this item in the overflow list. */
				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2214:	80 91 29 03 	lds	r24, 0x0329
    2218:	90 91 2a 03 	lds	r25, 0x032A
    221c:	20 91 ff 02 	lds	r18, 0x02FF
    2220:	30 91 00 03 	lds	r19, 0x0300
    2224:	2e 5f       	subi	r18, 0xFE	; 254
    2226:	3f 4f       	sbci	r19, 0xFF	; 255
    2228:	b9 01       	movw	r22, r18
    222a:	0e 94 a4 06 	call	0xd48	; 0xd48 <vListInsert>
    222e:	0d c0       	rjmp	.+26     	; 0x224a <vTaskPlaceOnEventList+0xaa>
			}
			else
			{
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2230:	80 91 27 03 	lds	r24, 0x0327
    2234:	90 91 28 03 	lds	r25, 0x0328
    2238:	20 91 ff 02 	lds	r18, 0x02FF
    223c:	30 91 00 03 	lds	r19, 0x0300
    2240:	2e 5f       	subi	r18, 0xFE	; 254
    2242:	3f 4f       	sbci	r19, 0xFF	; 255
    2244:	b9 01       	movw	r22, r18
    2246:	0e 94 a4 06 	call	0xd48	; 0xd48 <vListInsert>
			}
	}
	#endif
}
    224a:	26 96       	adiw	r28, 0x06	; 6
    224c:	0f b6       	in	r0, 0x3f	; 63
    224e:	f8 94       	cli
    2250:	de bf       	out	0x3e, r29	; 62
    2252:	0f be       	out	0x3f, r0	; 63
    2254:	cd bf       	out	0x3d, r28	; 61
    2256:	cf 91       	pop	r28
    2258:	df 91       	pop	r29
    225a:	08 95       	ret

0000225c <xTaskRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    225c:	df 93       	push	r29
    225e:	cf 93       	push	r28
    2260:	cd b7       	in	r28, 0x3d	; 61
    2262:	de b7       	in	r29, 0x3e	; 62
    2264:	27 97       	sbiw	r28, 0x07	; 7
    2266:	0f b6       	in	r0, 0x3f	; 63
    2268:	f8 94       	cli
    226a:	de bf       	out	0x3e, r29	; 62
    226c:	0f be       	out	0x3f, r0	; 63
    226e:	cd bf       	out	0x3d, r28	; 61
    2270:	9d 83       	std	Y+5, r25	; 0x05
    2272:	8c 83       	std	Y+4, r24	; 0x04
	it to the ready list.

	If an event is for a queue that is locked then this function will never
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2274:	ec 81       	ldd	r30, Y+4	; 0x04
    2276:	fd 81       	ldd	r31, Y+5	; 0x05
    2278:	80 81       	ld	r24, Z
    227a:	88 23       	and	r24, r24
    227c:	51 f0       	breq	.+20     	; 0x2292 <xTaskRemoveFromEventList+0x36>
    227e:	ec 81       	ldd	r30, Y+4	; 0x04
    2280:	fd 81       	ldd	r31, Y+5	; 0x05
    2282:	05 80       	ldd	r0, Z+5	; 0x05
    2284:	f6 81       	ldd	r31, Z+6	; 0x06
    2286:	e0 2d       	mov	r30, r0
    2288:	86 81       	ldd	r24, Z+6	; 0x06
    228a:	97 81       	ldd	r25, Z+7	; 0x07
    228c:	9f 83       	std	Y+7, r25	; 0x07
    228e:	8e 83       	std	Y+6, r24	; 0x06
    2290:	02 c0       	rjmp	.+4      	; 0x2296 <xTaskRemoveFromEventList+0x3a>
    2292:	1f 82       	std	Y+7, r1	; 0x07
    2294:	1e 82       	std	Y+6, r1	; 0x06
    2296:	8e 81       	ldd	r24, Y+6	; 0x06
    2298:	9f 81       	ldd	r25, Y+7	; 0x07
    229a:	9b 83       	std	Y+3, r25	; 0x03
    229c:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    229e:	8a 81       	ldd	r24, Y+2	; 0x02
    22a0:	9b 81       	ldd	r25, Y+3	; 0x03
    22a2:	0c 96       	adiw	r24, 0x0c	; 12
    22a4:	0e 94 10 07 	call	0xe20	; 0xe20 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    22a8:	80 91 07 03 	lds	r24, 0x0307
    22ac:	88 23       	and	r24, r24
    22ae:	61 f5       	brne	.+88     	; 0x2308 <xTaskRemoveFromEventList+0xac>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    22b0:	8a 81       	ldd	r24, Y+2	; 0x02
    22b2:	9b 81       	ldd	r25, Y+3	; 0x03
    22b4:	02 96       	adiw	r24, 0x02	; 2
    22b6:	0e 94 10 07 	call	0xe20	; 0xe20 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    22ba:	ea 81       	ldd	r30, Y+2	; 0x02
    22bc:	fb 81       	ldd	r31, Y+3	; 0x03
    22be:	96 89       	ldd	r25, Z+22	; 0x16
    22c0:	80 91 05 03 	lds	r24, 0x0305
    22c4:	89 17       	cp	r24, r25
    22c6:	28 f4       	brcc	.+10     	; 0x22d2 <xTaskRemoveFromEventList+0x76>
    22c8:	ea 81       	ldd	r30, Y+2	; 0x02
    22ca:	fb 81       	ldd	r31, Y+3	; 0x03
    22cc:	86 89       	ldd	r24, Z+22	; 0x16
    22ce:	80 93 05 03 	sts	0x0305, r24
    22d2:	ea 81       	ldd	r30, Y+2	; 0x02
    22d4:	fb 81       	ldd	r31, Y+3	; 0x03
    22d6:	86 89       	ldd	r24, Z+22	; 0x16
    22d8:	28 2f       	mov	r18, r24
    22da:	30 e0       	ldi	r19, 0x00	; 0
    22dc:	c9 01       	movw	r24, r18
    22de:	88 0f       	add	r24, r24
    22e0:	99 1f       	adc	r25, r25
    22e2:	88 0f       	add	r24, r24
    22e4:	99 1f       	adc	r25, r25
    22e6:	88 0f       	add	r24, r24
    22e8:	99 1f       	adc	r25, r25
    22ea:	82 0f       	add	r24, r18
    22ec:	93 1f       	adc	r25, r19
    22ee:	ac 01       	movw	r20, r24
    22f0:	44 5f       	subi	r20, 0xF4	; 244
    22f2:	5c 4f       	sbci	r21, 0xFC	; 252
    22f4:	8a 81       	ldd	r24, Y+2	; 0x02
    22f6:	9b 81       	ldd	r25, Y+3	; 0x03
    22f8:	9c 01       	movw	r18, r24
    22fa:	2e 5f       	subi	r18, 0xFE	; 254
    22fc:	3f 4f       	sbci	r19, 0xFF	; 255
    22fe:	ca 01       	movw	r24, r20
    2300:	b9 01       	movw	r22, r18
    2302:	0e 94 58 06 	call	0xcb0	; 0xcb0 <vListInsertEnd>
    2306:	0a c0       	rjmp	.+20     	; 0x231c <xTaskRemoveFromEventList+0xc0>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2308:	8a 81       	ldd	r24, Y+2	; 0x02
    230a:	9b 81       	ldd	r25, Y+3	; 0x03
    230c:	9c 01       	movw	r18, r24
    230e:	24 5f       	subi	r18, 0xF4	; 244
    2310:	3f 4f       	sbci	r19, 0xFF	; 255
    2312:	8b e2       	ldi	r24, 0x2B	; 43
    2314:	93 e0       	ldi	r25, 0x03	; 3
    2316:	b9 01       	movw	r22, r18
    2318:	0e 94 58 06 	call	0xcb0	; 0xcb0 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    231c:	ea 81       	ldd	r30, Y+2	; 0x02
    231e:	fb 81       	ldd	r31, Y+3	; 0x03
    2320:	96 89       	ldd	r25, Z+22	; 0x16
    2322:	e0 91 ff 02 	lds	r30, 0x02FF
    2326:	f0 91 00 03 	lds	r31, 0x0300
    232a:	86 89       	ldd	r24, Z+22	; 0x16
    232c:	98 17       	cp	r25, r24
    232e:	18 f0       	brcs	.+6      	; 0x2336 <xTaskRemoveFromEventList+0xda>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    2330:	81 e0       	ldi	r24, 0x01	; 1
    2332:	89 83       	std	Y+1, r24	; 0x01
    2334:	01 c0       	rjmp	.+2      	; 0x2338 <xTaskRemoveFromEventList+0xdc>
	}
	else
	{
		xReturn = pdFALSE;
    2336:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2338:	89 81       	ldd	r24, Y+1	; 0x01
}
    233a:	27 96       	adiw	r28, 0x07	; 7
    233c:	0f b6       	in	r0, 0x3f	; 63
    233e:	f8 94       	cli
    2340:	de bf       	out	0x3e, r29	; 62
    2342:	0f be       	out	0x3f, r0	; 63
    2344:	cd bf       	out	0x3d, r28	; 61
    2346:	cf 91       	pop	r28
    2348:	df 91       	pop	r29
    234a:	08 95       	ret

0000234c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    234c:	df 93       	push	r29
    234e:	cf 93       	push	r28
    2350:	00 d0       	rcall	.+0      	; 0x2352 <vTaskSetTimeOutState+0x6>
    2352:	cd b7       	in	r28, 0x3d	; 61
    2354:	de b7       	in	r29, 0x3e	; 62
    2356:	9a 83       	std	Y+2, r25	; 0x02
    2358:	89 83       	std	Y+1, r24	; 0x01
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    235a:	80 91 0a 03 	lds	r24, 0x030A
    235e:	e9 81       	ldd	r30, Y+1	; 0x01
    2360:	fa 81       	ldd	r31, Y+2	; 0x02
    2362:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    2364:	80 91 02 03 	lds	r24, 0x0302
    2368:	90 91 03 03 	lds	r25, 0x0303
    236c:	e9 81       	ldd	r30, Y+1	; 0x01
    236e:	fa 81       	ldd	r31, Y+2	; 0x02
    2370:	92 83       	std	Z+2, r25	; 0x02
    2372:	81 83       	std	Z+1, r24	; 0x01
}
    2374:	0f 90       	pop	r0
    2376:	0f 90       	pop	r0
    2378:	cf 91       	pop	r28
    237a:	df 91       	pop	r29
    237c:	08 95       	ret

0000237e <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    237e:	df 93       	push	r29
    2380:	cf 93       	push	r28
    2382:	00 d0       	rcall	.+0      	; 0x2384 <xTaskCheckForTimeOut+0x6>
    2384:	00 d0       	rcall	.+0      	; 0x2386 <xTaskCheckForTimeOut+0x8>
    2386:	0f 92       	push	r0
    2388:	cd b7       	in	r28, 0x3d	; 61
    238a:	de b7       	in	r29, 0x3e	; 62
    238c:	9b 83       	std	Y+3, r25	; 0x03
    238e:	8a 83       	std	Y+2, r24	; 0x02
    2390:	7d 83       	std	Y+5, r23	; 0x05
    2392:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	portENTER_CRITICAL();
    2394:	0f b6       	in	r0, 0x3f	; 63
    2396:	f8 94       	cli
    2398:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    239a:	ea 81       	ldd	r30, Y+2	; 0x02
    239c:	fb 81       	ldd	r31, Y+3	; 0x03
    239e:	90 81       	ld	r25, Z
    23a0:	80 91 0a 03 	lds	r24, 0x030A
    23a4:	98 17       	cp	r25, r24
    23a6:	71 f0       	breq	.+28     	; 0x23c4 <xTaskCheckForTimeOut+0x46>
    23a8:	ea 81       	ldd	r30, Y+2	; 0x02
    23aa:	fb 81       	ldd	r31, Y+3	; 0x03
    23ac:	21 81       	ldd	r18, Z+1	; 0x01
    23ae:	32 81       	ldd	r19, Z+2	; 0x02
    23b0:	80 91 02 03 	lds	r24, 0x0302
    23b4:	90 91 03 03 	lds	r25, 0x0303
    23b8:	82 17       	cp	r24, r18
    23ba:	93 07       	cpc	r25, r19
    23bc:	18 f0       	brcs	.+6      	; 0x23c4 <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    23be:	81 e0       	ldi	r24, 0x01	; 1
    23c0:	89 83       	std	Y+1, r24	; 0x01
    23c2:	2f c0       	rjmp	.+94     	; 0x2422 <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    23c4:	20 91 02 03 	lds	r18, 0x0302
    23c8:	30 91 03 03 	lds	r19, 0x0303
    23cc:	ea 81       	ldd	r30, Y+2	; 0x02
    23ce:	fb 81       	ldd	r31, Y+3	; 0x03
    23d0:	81 81       	ldd	r24, Z+1	; 0x01
    23d2:	92 81       	ldd	r25, Z+2	; 0x02
    23d4:	28 1b       	sub	r18, r24
    23d6:	39 0b       	sbc	r19, r25
    23d8:	ec 81       	ldd	r30, Y+4	; 0x04
    23da:	fd 81       	ldd	r31, Y+5	; 0x05
    23dc:	80 81       	ld	r24, Z
    23de:	91 81       	ldd	r25, Z+1	; 0x01
    23e0:	28 17       	cp	r18, r24
    23e2:	39 07       	cpc	r19, r25
    23e4:	e0 f4       	brcc	.+56     	; 0x241e <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    23e6:	ec 81       	ldd	r30, Y+4	; 0x04
    23e8:	fd 81       	ldd	r31, Y+5	; 0x05
    23ea:	40 81       	ld	r20, Z
    23ec:	51 81       	ldd	r21, Z+1	; 0x01
    23ee:	ea 81       	ldd	r30, Y+2	; 0x02
    23f0:	fb 81       	ldd	r31, Y+3	; 0x03
    23f2:	21 81       	ldd	r18, Z+1	; 0x01
    23f4:	32 81       	ldd	r19, Z+2	; 0x02
    23f6:	80 91 02 03 	lds	r24, 0x0302
    23fa:	90 91 03 03 	lds	r25, 0x0303
    23fe:	b9 01       	movw	r22, r18
    2400:	68 1b       	sub	r22, r24
    2402:	79 0b       	sbc	r23, r25
    2404:	cb 01       	movw	r24, r22
    2406:	84 0f       	add	r24, r20
    2408:	95 1f       	adc	r25, r21
    240a:	ec 81       	ldd	r30, Y+4	; 0x04
    240c:	fd 81       	ldd	r31, Y+5	; 0x05
    240e:	91 83       	std	Z+1, r25	; 0x01
    2410:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    2412:	8a 81       	ldd	r24, Y+2	; 0x02
    2414:	9b 81       	ldd	r25, Y+3	; 0x03
    2416:	0e 94 a6 11 	call	0x234c	; 0x234c <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    241a:	19 82       	std	Y+1, r1	; 0x01
    241c:	02 c0       	rjmp	.+4      	; 0x2422 <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    241e:	81 e0       	ldi	r24, 0x01	; 1
    2420:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	portEXIT_CRITICAL();
    2422:	0f 90       	pop	r0
    2424:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2426:	89 81       	ldd	r24, Y+1	; 0x01
}
    2428:	0f 90       	pop	r0
    242a:	0f 90       	pop	r0
    242c:	0f 90       	pop	r0
    242e:	0f 90       	pop	r0
    2430:	0f 90       	pop	r0
    2432:	cf 91       	pop	r28
    2434:	df 91       	pop	r29
    2436:	08 95       	ret

00002438 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    2438:	df 93       	push	r29
    243a:	cf 93       	push	r28
    243c:	cd b7       	in	r28, 0x3d	; 61
    243e:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    2440:	81 e0       	ldi	r24, 0x01	; 1
    2442:	80 93 09 03 	sts	0x0309, r24
}
    2446:	cf 91       	pop	r28
    2448:	df 91       	pop	r29
    244a:	08 95       	ret

0000244c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    244c:	df 93       	push	r29
    244e:	cf 93       	push	r28
    2450:	00 d0       	rcall	.+0      	; 0x2452 <prvIdleTask+0x6>
    2452:	cd b7       	in	r28, 0x3d	; 61
    2454:	de b7       	in	r29, 0x3e	; 62
    2456:	9a 83       	std	Y+2, r25	; 0x02
    2458:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    245a:	0e 94 c1 12 	call	0x2582	; 0x2582 <prvCheckTasksWaitingTermination>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
    245e:	0e 94 13 15 	call	0x2a26	; 0x2a26 <vApplicationIdleHook>
    2462:	fb cf       	rjmp	.-10     	; 0x245a <prvIdleTask+0xe>

00002464 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    2464:	0f 93       	push	r16
    2466:	1f 93       	push	r17
    2468:	df 93       	push	r29
    246a:	cf 93       	push	r28
    246c:	cd b7       	in	r28, 0x3d	; 61
    246e:	de b7       	in	r29, 0x3e	; 62
    2470:	29 97       	sbiw	r28, 0x09	; 9
    2472:	0f b6       	in	r0, 0x3f	; 63
    2474:	f8 94       	cli
    2476:	de bf       	out	0x3e, r29	; 62
    2478:	0f be       	out	0x3f, r0	; 63
    247a:	cd bf       	out	0x3d, r28	; 61
    247c:	9a 83       	std	Y+2, r25	; 0x02
    247e:	89 83       	std	Y+1, r24	; 0x01
    2480:	7c 83       	std	Y+4, r23	; 0x04
    2482:	6b 83       	std	Y+3, r22	; 0x03
    2484:	4d 83       	std	Y+5, r20	; 0x05
    2486:	3f 83       	std	Y+7, r19	; 0x07
    2488:	2e 83       	std	Y+6, r18	; 0x06
    248a:	19 87       	std	Y+9, r17	; 0x09
    248c:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    248e:	89 81       	ldd	r24, Y+1	; 0x01
    2490:	9a 81       	ldd	r25, Y+2	; 0x02
    2492:	49 96       	adiw	r24, 0x19	; 25
    2494:	2b 81       	ldd	r18, Y+3	; 0x03
    2496:	3c 81       	ldd	r19, Y+4	; 0x04
    2498:	b9 01       	movw	r22, r18
    249a:	42 e0       	ldi	r20, 0x02	; 2
    249c:	50 e0       	ldi	r21, 0x00	; 0
    249e:	0e 94 8f 16 	call	0x2d1e	; 0x2d1e <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
    24a2:	e9 81       	ldd	r30, Y+1	; 0x01
    24a4:	fa 81       	ldd	r31, Y+2	; 0x02
    24a6:	12 8e       	std	Z+26, r1	; 0x1a

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    24a8:	8d 81       	ldd	r24, Y+5	; 0x05
    24aa:	88 23       	and	r24, r24
    24ac:	09 f0       	breq	.+2      	; 0x24b0 <prvInitialiseTCBVariables+0x4c>
	{
		uxPriority = configMAX_PRIORITIES - 1;
    24ae:	1d 82       	std	Y+5, r1	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    24b0:	e9 81       	ldd	r30, Y+1	; 0x01
    24b2:	fa 81       	ldd	r31, Y+2	; 0x02
    24b4:	8d 81       	ldd	r24, Y+5	; 0x05
    24b6:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    24b8:	89 81       	ldd	r24, Y+1	; 0x01
    24ba:	9a 81       	ldd	r25, Y+2	; 0x02
    24bc:	02 96       	adiw	r24, 0x02	; 2
    24be:	0e 94 48 06 	call	0xc90	; 0xc90 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    24c2:	89 81       	ldd	r24, Y+1	; 0x01
    24c4:	9a 81       	ldd	r25, Y+2	; 0x02
    24c6:	0c 96       	adiw	r24, 0x0c	; 12
    24c8:	0e 94 48 06 	call	0xc90	; 0xc90 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    24cc:	e9 81       	ldd	r30, Y+1	; 0x01
    24ce:	fa 81       	ldd	r31, Y+2	; 0x02
    24d0:	89 81       	ldd	r24, Y+1	; 0x01
    24d2:	9a 81       	ldd	r25, Y+2	; 0x02
    24d4:	91 87       	std	Z+9, r25	; 0x09
    24d6:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    24d8:	8d 81       	ldd	r24, Y+5	; 0x05
    24da:	28 2f       	mov	r18, r24
    24dc:	30 e0       	ldi	r19, 0x00	; 0
    24de:	81 e0       	ldi	r24, 0x01	; 1
    24e0:	90 e0       	ldi	r25, 0x00	; 0
    24e2:	82 1b       	sub	r24, r18
    24e4:	93 0b       	sbc	r25, r19
    24e6:	e9 81       	ldd	r30, Y+1	; 0x01
    24e8:	fa 81       	ldd	r31, Y+2	; 0x02
    24ea:	95 87       	std	Z+13, r25	; 0x0d
    24ec:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    24ee:	e9 81       	ldd	r30, Y+1	; 0x01
    24f0:	fa 81       	ldd	r31, Y+2	; 0x02
    24f2:	89 81       	ldd	r24, Y+1	; 0x01
    24f4:	9a 81       	ldd	r25, Y+2	; 0x02
    24f6:	93 8b       	std	Z+19, r25	; 0x13
    24f8:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    24fa:	29 96       	adiw	r28, 0x09	; 9
    24fc:	0f b6       	in	r0, 0x3f	; 63
    24fe:	f8 94       	cli
    2500:	de bf       	out	0x3e, r29	; 62
    2502:	0f be       	out	0x3f, r0	; 63
    2504:	cd bf       	out	0x3d, r28	; 61
    2506:	cf 91       	pop	r28
    2508:	df 91       	pop	r29
    250a:	1f 91       	pop	r17
    250c:	0f 91       	pop	r16
    250e:	08 95       	ret

00002510 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    2510:	df 93       	push	r29
    2512:	cf 93       	push	r28
    2514:	0f 92       	push	r0
    2516:	cd b7       	in	r28, 0x3d	; 61
    2518:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    251a:	19 82       	std	Y+1, r1	; 0x01
    251c:	13 c0       	rjmp	.+38     	; 0x2544 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    251e:	89 81       	ldd	r24, Y+1	; 0x01
    2520:	28 2f       	mov	r18, r24
    2522:	30 e0       	ldi	r19, 0x00	; 0
    2524:	c9 01       	movw	r24, r18
    2526:	88 0f       	add	r24, r24
    2528:	99 1f       	adc	r25, r25
    252a:	88 0f       	add	r24, r24
    252c:	99 1f       	adc	r25, r25
    252e:	88 0f       	add	r24, r24
    2530:	99 1f       	adc	r25, r25
    2532:	82 0f       	add	r24, r18
    2534:	93 1f       	adc	r25, r19
    2536:	84 5f       	subi	r24, 0xF4	; 244
    2538:	9c 4f       	sbci	r25, 0xFC	; 252
    253a:	0e 94 1e 06 	call	0xc3c	; 0xc3c <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    253e:	89 81       	ldd	r24, Y+1	; 0x01
    2540:	8f 5f       	subi	r24, 0xFF	; 255
    2542:	89 83       	std	Y+1, r24	; 0x01
    2544:	89 81       	ldd	r24, Y+1	; 0x01
    2546:	88 23       	and	r24, r24
    2548:	51 f3       	breq	.-44     	; 0x251e <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    254a:	85 e1       	ldi	r24, 0x15	; 21
    254c:	93 e0       	ldi	r25, 0x03	; 3
    254e:	0e 94 1e 06 	call	0xc3c	; 0xc3c <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    2552:	8e e1       	ldi	r24, 0x1E	; 30
    2554:	93 e0       	ldi	r25, 0x03	; 3
    2556:	0e 94 1e 06 	call	0xc3c	; 0xc3c <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    255a:	8b e2       	ldi	r24, 0x2B	; 43
    255c:	93 e0       	ldi	r25, 0x03	; 3
    255e:	0e 94 1e 06 	call	0xc3c	; 0xc3c <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    2562:	85 e1       	ldi	r24, 0x15	; 21
    2564:	93 e0       	ldi	r25, 0x03	; 3
    2566:	90 93 28 03 	sts	0x0328, r25
    256a:	80 93 27 03 	sts	0x0327, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    256e:	8e e1       	ldi	r24, 0x1E	; 30
    2570:	93 e0       	ldi	r25, 0x03	; 3
    2572:	90 93 2a 03 	sts	0x032A, r25
    2576:	80 93 29 03 	sts	0x0329, r24
}
    257a:	0f 90       	pop	r0
    257c:	cf 91       	pop	r28
    257e:	df 91       	pop	r29
    2580:	08 95       	ret

00002582 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    2582:	df 93       	push	r29
    2584:	cf 93       	push	r28
    2586:	cd b7       	in	r28, 0x3d	; 61
    2588:	de b7       	in	r29, 0x3e	; 62
				prvDeleteTCB( pxTCB );
			}
		}
	}
	#endif
}
    258a:	cf 91       	pop	r28
    258c:	df 91       	pop	r29
    258e:	08 95       	ret

00002590 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    2590:	df 93       	push	r29
    2592:	cf 93       	push	r28
    2594:	cd b7       	in	r28, 0x3d	; 61
    2596:	de b7       	in	r29, 0x3e	; 62
    2598:	28 97       	sbiw	r28, 0x08	; 8
    259a:	0f b6       	in	r0, 0x3f	; 63
    259c:	f8 94       	cli
    259e:	de bf       	out	0x3e, r29	; 62
    25a0:	0f be       	out	0x3f, r0	; 63
    25a2:	cd bf       	out	0x3d, r28	; 61
    25a4:	9c 83       	std	Y+4, r25	; 0x04
    25a6:	8b 83       	std	Y+3, r24	; 0x03
    25a8:	7e 83       	std	Y+6, r23	; 0x06
    25aa:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    25ac:	8b e1       	ldi	r24, 0x1B	; 27
    25ae:	90 e0       	ldi	r25, 0x00	; 0
    25b0:	0e 94 59 07 	call	0xeb2	; 0xeb2 <pvPortMalloc>
    25b4:	9a 83       	std	Y+2, r25	; 0x02
    25b6:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    25b8:	89 81       	ldd	r24, Y+1	; 0x01
    25ba:	9a 81       	ldd	r25, Y+2	; 0x02
    25bc:	00 97       	sbiw	r24, 0x00	; 0
    25be:	69 f1       	breq	.+90     	; 0x261a <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    25c0:	8d 81       	ldd	r24, Y+5	; 0x05
    25c2:	9e 81       	ldd	r25, Y+6	; 0x06
    25c4:	00 97       	sbiw	r24, 0x00	; 0
    25c6:	39 f4       	brne	.+14     	; 0x25d6 <prvAllocateTCBAndStack+0x46>
    25c8:	8b 81       	ldd	r24, Y+3	; 0x03
    25ca:	9c 81       	ldd	r25, Y+4	; 0x04
    25cc:	0e 94 59 07 	call	0xeb2	; 0xeb2 <pvPortMalloc>
    25d0:	98 87       	std	Y+8, r25	; 0x08
    25d2:	8f 83       	std	Y+7, r24	; 0x07
    25d4:	04 c0       	rjmp	.+8      	; 0x25de <prvAllocateTCBAndStack+0x4e>
    25d6:	8d 81       	ldd	r24, Y+5	; 0x05
    25d8:	9e 81       	ldd	r25, Y+6	; 0x06
    25da:	98 87       	std	Y+8, r25	; 0x08
    25dc:	8f 83       	std	Y+7, r24	; 0x07
    25de:	e9 81       	ldd	r30, Y+1	; 0x01
    25e0:	fa 81       	ldd	r31, Y+2	; 0x02
    25e2:	8f 81       	ldd	r24, Y+7	; 0x07
    25e4:	98 85       	ldd	r25, Y+8	; 0x08
    25e6:	90 8f       	std	Z+24, r25	; 0x18
    25e8:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    25ea:	e9 81       	ldd	r30, Y+1	; 0x01
    25ec:	fa 81       	ldd	r31, Y+2	; 0x02
    25ee:	87 89       	ldd	r24, Z+23	; 0x17
    25f0:	90 8d       	ldd	r25, Z+24	; 0x18
    25f2:	00 97       	sbiw	r24, 0x00	; 0
    25f4:	39 f4       	brne	.+14     	; 0x2604 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    25f6:	89 81       	ldd	r24, Y+1	; 0x01
    25f8:	9a 81       	ldd	r25, Y+2	; 0x02
    25fa:	0e 94 9f 07 	call	0xf3e	; 0xf3e <vPortFree>
			pxNewTCB = NULL;
    25fe:	1a 82       	std	Y+2, r1	; 0x02
    2600:	19 82       	std	Y+1, r1	; 0x01
    2602:	0b c0       	rjmp	.+22     	; 0x261a <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
    2604:	e9 81       	ldd	r30, Y+1	; 0x01
    2606:	fa 81       	ldd	r31, Y+2	; 0x02
    2608:	87 89       	ldd	r24, Z+23	; 0x17
    260a:	90 8d       	ldd	r25, Z+24	; 0x18
    260c:	2b 81       	ldd	r18, Y+3	; 0x03
    260e:	3c 81       	ldd	r19, Y+4	; 0x04
    2610:	65 ea       	ldi	r22, 0xA5	; 165
    2612:	70 e0       	ldi	r23, 0x00	; 0
    2614:	a9 01       	movw	r20, r18
    2616:	0e 94 7f 16 	call	0x2cfe	; 0x2cfe <memset>
		}
	}

	return pxNewTCB;
    261a:	89 81       	ldd	r24, Y+1	; 0x01
    261c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    261e:	28 96       	adiw	r28, 0x08	; 8
    2620:	0f b6       	in	r0, 0x3f	; 63
    2622:	f8 94       	cli
    2624:	de bf       	out	0x3e, r29	; 62
    2626:	0f be       	out	0x3f, r0	; 63
    2628:	cd bf       	out	0x3d, r28	; 61
    262a:	cf 91       	pop	r28
    262c:	df 91       	pop	r29
    262e:	08 95       	ret

00002630 <ioStructInit>:

static void procDbg( const char * args );
static void procSetMotors( const char * args );

void ioStructInit( struct TIOStr * st )
{
    2630:	df 93       	push	r29
    2632:	cf 93       	push	r28
    2634:	00 d0       	rcall	.+0      	; 0x2636 <ioStructInit+0x6>
    2636:	cd b7       	in	r28, 0x3d	; 61
    2638:	de b7       	in	r29, 0x3e	; 62
    263a:	9a 83       	std	Y+2, r25	; 0x02
    263c:	89 83       	std	Y+1, r24	; 0x01
    st->crc = 0;
    263e:	e9 81       	ldd	r30, Y+1	; 0x01
    2640:	fa 81       	ldd	r31, Y+2	; 0x02
    2642:	10 82       	st	Z, r1
}
    2644:	0f 90       	pop	r0
    2646:	0f 90       	pop	r0
    2648:	cf 91       	pop	r28
    264a:	df 91       	pop	r29
    264c:	08 95       	ret

0000264e <encodeWord>:

char encodeWord( const char * stri, char * res )
{
    264e:	df 93       	push	r29
    2650:	cf 93       	push	r28
    2652:	cd b7       	in	r28, 0x3d	; 61
    2654:	de b7       	in	r29, 0x3e	; 62
    2656:	28 97       	sbiw	r28, 0x08	; 8
    2658:	0f b6       	in	r0, 0x3f	; 63
    265a:	f8 94       	cli
    265c:	de bf       	out	0x3e, r29	; 62
    265e:	0f be       	out	0x3f, r0	; 63
    2660:	cd bf       	out	0x3d, r28	; 61
    2662:	9d 83       	std	Y+5, r25	; 0x05
    2664:	8c 83       	std	Y+4, r24	; 0x04
    2666:	7f 83       	std	Y+7, r23	; 0x07
    2668:	6e 83       	std	Y+6, r22	; 0x06
    char srcInd;
    char resInd;
    char ch;
    srcInd = resInd = 0;
    266a:	1a 82       	std	Y+2, r1	; 0x02
    266c:	8a 81       	ldd	r24, Y+2	; 0x02
    266e:	8b 83       	std	Y+3, r24	; 0x03
    2670:	12 c0       	rjmp	.+36     	; 0x2696 <encodeWord+0x48>
    // Пропускаем все пробелы перед словом.
    while ( srcInd < CMD_LEN )
    {
        ch = stri[ srcInd ];
    2672:	8b 81       	ldd	r24, Y+3	; 0x03
    2674:	28 2f       	mov	r18, r24
    2676:	33 27       	eor	r19, r19
    2678:	27 fd       	sbrc	r18, 7
    267a:	30 95       	com	r19
    267c:	8c 81       	ldd	r24, Y+4	; 0x04
    267e:	9d 81       	ldd	r25, Y+5	; 0x05
    2680:	fc 01       	movw	r30, r24
    2682:	e2 0f       	add	r30, r18
    2684:	f3 1f       	adc	r31, r19
    2686:	80 81       	ld	r24, Z
    2688:	89 83       	std	Y+1, r24	; 0x01
        if ( ch != ' ' )
    268a:	89 81       	ldd	r24, Y+1	; 0x01
    268c:	80 32       	cpi	r24, 0x20	; 32
    268e:	31 f4       	brne	.+12     	; 0x269c <encodeWord+0x4e>
            break;
        srcInd++;
    2690:	8b 81       	ldd	r24, Y+3	; 0x03
    2692:	8f 5f       	subi	r24, 0xFF	; 255
    2694:	8b 83       	std	Y+3, r24	; 0x03
    char srcInd;
    char resInd;
    char ch;
    srcInd = resInd = 0;
    // Пропускаем все пробелы перед словом.
    while ( srcInd < CMD_LEN )
    2696:	8b 81       	ldd	r24, Y+3	; 0x03
    2698:	80 34       	cpi	r24, 0x40	; 64
    269a:	5c f3       	brlt	.-42     	; 0x2672 <encodeWord+0x24>
        if ( ch != ' ' )
            break;
        srcInd++;
    }
    // Если вдруг это уже конец, делаем на всякий случай результат пустой строкой.
    res[0] = '\0';
    269c:	ee 81       	ldd	r30, Y+6	; 0x06
    269e:	ff 81       	ldd	r31, Y+7	; 0x07
    26a0:	10 82       	st	Z, r1
    26a2:	33 c0       	rjmp	.+102    	; 0x270a <encodeWord+0xbc>
    // Добавляем символы до пробела или конца строки.
    while ( srcInd < CMD_LEN )
    {
        ch = stri[srcInd];
    26a4:	8b 81       	ldd	r24, Y+3	; 0x03
    26a6:	28 2f       	mov	r18, r24
    26a8:	33 27       	eor	r19, r19
    26aa:	27 fd       	sbrc	r18, 7
    26ac:	30 95       	com	r19
    26ae:	8c 81       	ldd	r24, Y+4	; 0x04
    26b0:	9d 81       	ldd	r25, Y+5	; 0x05
    26b2:	fc 01       	movw	r30, r24
    26b4:	e2 0f       	add	r30, r18
    26b6:	f3 1f       	adc	r31, r19
    26b8:	80 81       	ld	r24, Z
    26ba:	89 83       	std	Y+1, r24	; 0x01
        if ( ( ch != ' ' ) && ( ch != '\0' ) )
    26bc:	89 81       	ldd	r24, Y+1	; 0x01
    26be:	80 32       	cpi	r24, 0x20	; 32
    26c0:	b1 f0       	breq	.+44     	; 0x26ee <encodeWord+0xa0>
    26c2:	89 81       	ldd	r24, Y+1	; 0x01
    26c4:	88 23       	and	r24, r24
    26c6:	99 f0       	breq	.+38     	; 0x26ee <encodeWord+0xa0>
            res[resInd] = ch;
    26c8:	8a 81       	ldd	r24, Y+2	; 0x02
    26ca:	28 2f       	mov	r18, r24
    26cc:	33 27       	eor	r19, r19
    26ce:	27 fd       	sbrc	r18, 7
    26d0:	30 95       	com	r19
    26d2:	8e 81       	ldd	r24, Y+6	; 0x06
    26d4:	9f 81       	ldd	r25, Y+7	; 0x07
    26d6:	fc 01       	movw	r30, r24
    26d8:	e2 0f       	add	r30, r18
    26da:	f3 1f       	adc	r31, r19
    26dc:	89 81       	ldd	r24, Y+1	; 0x01
    26de:	80 83       	st	Z, r24
        else
        {
            res[resInd] = '\0';
            return srcInd;
        }
        srcInd++;
    26e0:	8b 81       	ldd	r24, Y+3	; 0x03
    26e2:	8f 5f       	subi	r24, 0xFF	; 255
    26e4:	8b 83       	std	Y+3, r24	; 0x03
        resInd++;
    26e6:	8a 81       	ldd	r24, Y+2	; 0x02
    26e8:	8f 5f       	subi	r24, 0xFF	; 255
    26ea:	8a 83       	std	Y+2, r24	; 0x02
    26ec:	0e c0       	rjmp	.+28     	; 0x270a <encodeWord+0xbc>
        ch = stri[srcInd];
        if ( ( ch != ' ' ) && ( ch != '\0' ) )
            res[resInd] = ch;
        else
        {
            res[resInd] = '\0';
    26ee:	8a 81       	ldd	r24, Y+2	; 0x02
    26f0:	28 2f       	mov	r18, r24
    26f2:	33 27       	eor	r19, r19
    26f4:	27 fd       	sbrc	r18, 7
    26f6:	30 95       	com	r19
    26f8:	8e 81       	ldd	r24, Y+6	; 0x06
    26fa:	9f 81       	ldd	r25, Y+7	; 0x07
    26fc:	fc 01       	movw	r30, r24
    26fe:	e2 0f       	add	r30, r18
    2700:	f3 1f       	adc	r31, r19
    2702:	10 82       	st	Z, r1
            return srcInd;
    2704:	8b 81       	ldd	r24, Y+3	; 0x03
    2706:	88 87       	std	Y+8, r24	; 0x08
    2708:	05 c0       	rjmp	.+10     	; 0x2714 <encodeWord+0xc6>
        srcInd++;
    }
    // Если вдруг это уже конец, делаем на всякий случай результат пустой строкой.
    res[0] = '\0';
    // Добавляем символы до пробела или конца строки.
    while ( srcInd < CMD_LEN )
    270a:	8b 81       	ldd	r24, Y+3	; 0x03
    270c:	80 34       	cpi	r24, 0x40	; 64
    270e:	54 f2       	brlt	.-108    	; 0x26a4 <encodeWord+0x56>
            return srcInd;
        }
        srcInd++;
        resInd++;
    }
    return srcInd;
    2710:	8b 81       	ldd	r24, Y+3	; 0x03
    2712:	88 87       	std	Y+8, r24	; 0x08
    2714:	88 85       	ldd	r24, Y+8	; 0x08
}
    2716:	28 96       	adiw	r28, 0x08	; 8
    2718:	0f b6       	in	r0, 0x3f	; 63
    271a:	f8 94       	cli
    271c:	de bf       	out	0x3e, r29	; 62
    271e:	0f be       	out	0x3f, r0	; 63
    2720:	cd bf       	out	0x3d, r28	; 61
    2722:	cf 91       	pop	r28
    2724:	df 91       	pop	r29
    2726:	08 95       	ret

00002728 <parseCmd>:

void parseCmd( const char * cmd )
{
    2728:	df 93       	push	r29
    272a:	cf 93       	push	r28
    272c:	00 d0       	rcall	.+0      	; 0x272e <parseCmd+0x6>
    272e:	cd b7       	in	r28, 0x3d	; 61
    2730:	de b7       	in	r29, 0x3e	; 62
    2732:	9a 83       	std	Y+2, r25	; 0x02
    2734:	89 83       	std	Y+1, r24	; 0x01
    static char word[ CMD_LEN ];
    static char ind = 0;
    ind = encodeWord( cmd, (char *)word );
    2736:	89 81       	ldd	r24, Y+1	; 0x01
    2738:	9a 81       	ldd	r25, Y+2	; 0x02
    273a:	25 e3       	ldi	r18, 0x35	; 53
    273c:	33 e0       	ldi	r19, 0x03	; 3
    273e:	b9 01       	movw	r22, r18
    2740:	0e 94 27 13 	call	0x264e	; 0x264e <encodeWord>
    2744:	80 93 34 03 	sts	0x0334, r24

    if ( strcmp( word, "dbg" ) == 0 )
    2748:	85 e3       	ldi	r24, 0x35	; 53
    274a:	93 e0       	ldi	r25, 0x03	; 3
    274c:	25 e6       	ldi	r18, 0x65	; 101
    274e:	30 e0       	ldi	r19, 0x00	; 0
    2750:	b9 01       	movw	r22, r18
    2752:	0e 94 86 16 	call	0x2d0c	; 0x2d0c <strcmp>
    2756:	00 97       	sbiw	r24, 0x00	; 0
    2758:	69 f4       	brne	.+26     	; 0x2774 <parseCmd+0x4c>
    {
        procDbg( cmd+ind );
    275a:	80 91 34 03 	lds	r24, 0x0334
    275e:	28 2f       	mov	r18, r24
    2760:	33 27       	eor	r19, r19
    2762:	27 fd       	sbrc	r18, 7
    2764:	30 95       	com	r19
    2766:	89 81       	ldd	r24, Y+1	; 0x01
    2768:	9a 81       	ldd	r25, Y+2	; 0x02
    276a:	82 0f       	add	r24, r18
    276c:	93 1f       	adc	r25, r19
    276e:	0e 94 bc 14 	call	0x2978	; 0x2978 <procDbg>
    2772:	15 c0       	rjmp	.+42     	; 0x279e <parseCmd+0x76>
    }
    else if ( strcmp( word, "setMotors" ) == 0 )
    2774:	85 e3       	ldi	r24, 0x35	; 53
    2776:	93 e0       	ldi	r25, 0x03	; 3
    2778:	29 e6       	ldi	r18, 0x69	; 105
    277a:	30 e0       	ldi	r19, 0x00	; 0
    277c:	b9 01       	movw	r22, r18
    277e:	0e 94 86 16 	call	0x2d0c	; 0x2d0c <strcmp>
    2782:	00 97       	sbiw	r24, 0x00	; 0
    2784:	61 f4       	brne	.+24     	; 0x279e <parseCmd+0x76>
    {
        procSetMotors( cmd+ind );
    2786:	80 91 34 03 	lds	r24, 0x0334
    278a:	28 2f       	mov	r18, r24
    278c:	33 27       	eor	r19, r19
    278e:	27 fd       	sbrc	r18, 7
    2790:	30 95       	com	r19
    2792:	89 81       	ldd	r24, Y+1	; 0x01
    2794:	9a 81       	ldd	r25, Y+2	; 0x02
    2796:	82 0f       	add	r24, r18
    2798:	93 1f       	adc	r25, r19
    279a:	0e 94 e7 14 	call	0x29ce	; 0x29ce <procSetMotors>
    }
}
    279e:	0f 90       	pop	r0
    27a0:	0f 90       	pop	r0
    27a2:	cf 91       	pop	r28
    27a4:	df 91       	pop	r29
    27a6:	08 95       	ret

000027a8 <strLen>:

char strLen( const char * stri )
{
    27a8:	df 93       	push	r29
    27aa:	cf 93       	push	r28
    27ac:	00 d0       	rcall	.+0      	; 0x27ae <strLen+0x6>
    27ae:	0f 92       	push	r0
    27b0:	cd b7       	in	r28, 0x3d	; 61
    27b2:	de b7       	in	r29, 0x3e	; 62
    27b4:	9b 83       	std	Y+3, r25	; 0x03
    27b6:	8a 83       	std	Y+2, r24	; 0x02
    char ind = 0;
    27b8:	19 82       	std	Y+1, r1	; 0x01
    27ba:	0a c0       	rjmp	.+20     	; 0x27d0 <strLen+0x28>
    while ( stri[ ind ] != '\0' )
    {
        ind++;
    27bc:	89 81       	ldd	r24, Y+1	; 0x01
    27be:	8f 5f       	subi	r24, 0xFF	; 255
    27c0:	89 83       	std	Y+1, r24	; 0x01
        if ( ind == CMD_LEN )
    27c2:	89 81       	ldd	r24, Y+1	; 0x01
    27c4:	80 34       	cpi	r24, 0x40	; 64
    27c6:	21 f4       	brne	.+8      	; 0x27d0 <strLen+0x28>
        {
            ind--;
    27c8:	89 81       	ldd	r24, Y+1	; 0x01
    27ca:	81 50       	subi	r24, 0x01	; 1
    27cc:	89 83       	std	Y+1, r24	; 0x01
    27ce:	0d c0       	rjmp	.+26     	; 0x27ea <strLen+0x42>
}

char strLen( const char * stri )
{
    char ind = 0;
    while ( stri[ ind ] != '\0' )
    27d0:	89 81       	ldd	r24, Y+1	; 0x01
    27d2:	28 2f       	mov	r18, r24
    27d4:	33 27       	eor	r19, r19
    27d6:	27 fd       	sbrc	r18, 7
    27d8:	30 95       	com	r19
    27da:	8a 81       	ldd	r24, Y+2	; 0x02
    27dc:	9b 81       	ldd	r25, Y+3	; 0x03
    27de:	fc 01       	movw	r30, r24
    27e0:	e2 0f       	add	r30, r18
    27e2:	f3 1f       	adc	r31, r19
    27e4:	80 81       	ld	r24, Z
    27e6:	88 23       	and	r24, r24
    27e8:	49 f7       	brne	.-46     	; 0x27bc <strLen+0x14>
        {
            ind--;
            break;
        }
    }
    return ind;
    27ea:	89 81       	ldd	r24, Y+1	; 0x01
}
    27ec:	0f 90       	pop	r0
    27ee:	0f 90       	pop	r0
    27f0:	0f 90       	pop	r0
    27f2:	cf 91       	pop	r28
    27f4:	df 91       	pop	r29
    27f6:	08 95       	ret

000027f8 <strCmp>:

char strCmp( const char * a, const char * b )
{
    27f8:	df 93       	push	r29
    27fa:	cf 93       	push	r28
    27fc:	00 d0       	rcall	.+0      	; 0x27fe <strCmp+0x6>
    27fe:	00 d0       	rcall	.+0      	; 0x2800 <strCmp+0x8>
    2800:	00 d0       	rcall	.+0      	; 0x2802 <strCmp+0xa>
    2802:	cd b7       	in	r28, 0x3d	; 61
    2804:	de b7       	in	r29, 0x3e	; 62
    2806:	9b 83       	std	Y+3, r25	; 0x03
    2808:	8a 83       	std	Y+2, r24	; 0x02
    280a:	7d 83       	std	Y+5, r23	; 0x05
    280c:	6c 83       	std	Y+4, r22	; 0x04
    char ind = 0;
    280e:	19 82       	std	Y+1, r1	; 0x01
    2810:	17 c0       	rjmp	.+46     	; 0x2840 <strCmp+0x48>
    while ( a[ind] == b[ind] )
    {
        if ( a[ind] == '\0' )
    2812:	89 81       	ldd	r24, Y+1	; 0x01
    2814:	28 2f       	mov	r18, r24
    2816:	33 27       	eor	r19, r19
    2818:	27 fd       	sbrc	r18, 7
    281a:	30 95       	com	r19
    281c:	8a 81       	ldd	r24, Y+2	; 0x02
    281e:	9b 81       	ldd	r25, Y+3	; 0x03
    2820:	fc 01       	movw	r30, r24
    2822:	e2 0f       	add	r30, r18
    2824:	f3 1f       	adc	r31, r19
    2826:	80 81       	ld	r24, Z
    2828:	88 23       	and	r24, r24
    282a:	11 f4       	brne	.+4      	; 0x2830 <strCmp+0x38>
            return 0;
    282c:	1e 82       	std	Y+6, r1	; 0x06
    282e:	22 c0       	rjmp	.+68     	; 0x2874 <strCmp+0x7c>
        ind++;
    2830:	89 81       	ldd	r24, Y+1	; 0x01
    2832:	8f 5f       	subi	r24, 0xFF	; 255
    2834:	89 83       	std	Y+1, r24	; 0x01
        if ( ind == CMD_LEN )
    2836:	89 81       	ldd	r24, Y+1	; 0x01
    2838:	80 34       	cpi	r24, 0x40	; 64
    283a:	11 f4       	brne	.+4      	; 0x2840 <strCmp+0x48>
            return 0;
    283c:	1e 82       	std	Y+6, r1	; 0x06
    283e:	1a c0       	rjmp	.+52     	; 0x2874 <strCmp+0x7c>
}

char strCmp( const char * a, const char * b )
{
    char ind = 0;
    while ( a[ind] == b[ind] )
    2840:	89 81       	ldd	r24, Y+1	; 0x01
    2842:	28 2f       	mov	r18, r24
    2844:	33 27       	eor	r19, r19
    2846:	27 fd       	sbrc	r18, 7
    2848:	30 95       	com	r19
    284a:	8a 81       	ldd	r24, Y+2	; 0x02
    284c:	9b 81       	ldd	r25, Y+3	; 0x03
    284e:	fc 01       	movw	r30, r24
    2850:	e2 0f       	add	r30, r18
    2852:	f3 1f       	adc	r31, r19
    2854:	40 81       	ld	r20, Z
    2856:	89 81       	ldd	r24, Y+1	; 0x01
    2858:	28 2f       	mov	r18, r24
    285a:	33 27       	eor	r19, r19
    285c:	27 fd       	sbrc	r18, 7
    285e:	30 95       	com	r19
    2860:	8c 81       	ldd	r24, Y+4	; 0x04
    2862:	9d 81       	ldd	r25, Y+5	; 0x05
    2864:	fc 01       	movw	r30, r24
    2866:	e2 0f       	add	r30, r18
    2868:	f3 1f       	adc	r31, r19
    286a:	80 81       	ld	r24, Z
    286c:	48 17       	cp	r20, r24
    286e:	89 f2       	breq	.-94     	; 0x2812 <strCmp+0x1a>
            return 0;
        ind++;
        if ( ind == CMD_LEN )
            return 0;
    }
    return 1;
    2870:	81 e0       	ldi	r24, 0x01	; 1
    2872:	8e 83       	std	Y+6, r24	; 0x06
    2874:	8e 81       	ldd	r24, Y+6	; 0x06
}
    2876:	26 96       	adiw	r28, 0x06	; 6
    2878:	0f b6       	in	r0, 0x3f	; 63
    287a:	f8 94       	cli
    287c:	de bf       	out	0x3e, r29	; 62
    287e:	0f be       	out	0x3f, r0	; 63
    2880:	cd bf       	out	0x3d, r28	; 61
    2882:	cf 91       	pop	r28
    2884:	df 91       	pop	r29
    2886:	08 95       	ret

00002888 <str2ind>:

short str2ind( const char * stri )
{
    2888:	df 93       	push	r29
    288a:	cf 93       	push	r28
    288c:	cd b7       	in	r28, 0x3d	; 61
    288e:	de b7       	in	r29, 0x3e	; 62
    2890:	27 97       	sbiw	r28, 0x07	; 7
    2892:	0f b6       	in	r0, 0x3f	; 63
    2894:	f8 94       	cli
    2896:	de bf       	out	0x3e, r29	; 62
    2898:	0f be       	out	0x3f, r0	; 63
    289a:	cd bf       	out	0x3d, r28	; 61
    289c:	9f 83       	std	Y+7, r25	; 0x07
    289e:	8e 83       	std	Y+6, r24	; 0x06
    char ind = 0;
    28a0:	1d 82       	std	Y+5, r1	; 0x05
    char neg = ( stri[ind] == '-' ) ? 1 : 0;
    28a2:	8d 81       	ldd	r24, Y+5	; 0x05
    28a4:	28 2f       	mov	r18, r24
    28a6:	33 27       	eor	r19, r19
    28a8:	27 fd       	sbrc	r18, 7
    28aa:	30 95       	com	r19
    28ac:	8e 81       	ldd	r24, Y+6	; 0x06
    28ae:	9f 81       	ldd	r25, Y+7	; 0x07
    28b0:	fc 01       	movw	r30, r24
    28b2:	e2 0f       	add	r30, r18
    28b4:	f3 1f       	adc	r31, r19
    28b6:	80 81       	ld	r24, Z
    28b8:	1c 82       	std	Y+4, r1	; 0x04
    28ba:	8d 32       	cpi	r24, 0x2D	; 45
    28bc:	11 f4       	brne	.+4      	; 0x28c2 <str2ind+0x3a>
    28be:	81 e0       	ldi	r24, 0x01	; 1
    28c0:	8c 83       	std	Y+4, r24	; 0x04
    if ( neg )
    28c2:	8c 81       	ldd	r24, Y+4	; 0x04
    28c4:	88 23       	and	r24, r24
    28c6:	19 f0       	breq	.+6      	; 0x28ce <str2ind+0x46>
        ind++;
    28c8:	8d 81       	ldd	r24, Y+5	; 0x05
    28ca:	8f 5f       	subi	r24, 0xFF	; 255
    28cc:	8d 83       	std	Y+5, r24	; 0x05
    short res = 0;
    28ce:	1b 82       	std	Y+3, r1	; 0x03
    28d0:	1a 82       	std	Y+2, r1	; 0x02
    char val = stri[ ind ];
    28d2:	8d 81       	ldd	r24, Y+5	; 0x05
    28d4:	28 2f       	mov	r18, r24
    28d6:	33 27       	eor	r19, r19
    28d8:	27 fd       	sbrc	r18, 7
    28da:	30 95       	com	r19
    28dc:	8e 81       	ldd	r24, Y+6	; 0x06
    28de:	9f 81       	ldd	r25, Y+7	; 0x07
    28e0:	fc 01       	movw	r30, r24
    28e2:	e2 0f       	add	r30, r18
    28e4:	f3 1f       	adc	r31, r19
    28e6:	80 81       	ld	r24, Z
    28e8:	89 83       	std	Y+1, r24	; 0x01
    28ea:	2a c0       	rjmp	.+84     	; 0x2940 <str2ind+0xb8>
    while ( ( val >= '0' ) && ( val <= '9' ) && ( ind < CMD_LEN ) )
    {
        res *= 10;
    28ec:	8a 81       	ldd	r24, Y+2	; 0x02
    28ee:	9b 81       	ldd	r25, Y+3	; 0x03
    28f0:	9c 01       	movw	r18, r24
    28f2:	22 0f       	add	r18, r18
    28f4:	33 1f       	adc	r19, r19
    28f6:	c9 01       	movw	r24, r18
    28f8:	88 0f       	add	r24, r24
    28fa:	99 1f       	adc	r25, r25
    28fc:	88 0f       	add	r24, r24
    28fe:	99 1f       	adc	r25, r25
    2900:	82 0f       	add	r24, r18
    2902:	93 1f       	adc	r25, r19
    2904:	9b 83       	std	Y+3, r25	; 0x03
    2906:	8a 83       	std	Y+2, r24	; 0x02
        res += (short)( val-'0' );
    2908:	89 81       	ldd	r24, Y+1	; 0x01
    290a:	99 27       	eor	r25, r25
    290c:	87 fd       	sbrc	r24, 7
    290e:	90 95       	com	r25
    2910:	9c 01       	movw	r18, r24
    2912:	20 53       	subi	r18, 0x30	; 48
    2914:	30 40       	sbci	r19, 0x00	; 0
    2916:	8a 81       	ldd	r24, Y+2	; 0x02
    2918:	9b 81       	ldd	r25, Y+3	; 0x03
    291a:	82 0f       	add	r24, r18
    291c:	93 1f       	adc	r25, r19
    291e:	9b 83       	std	Y+3, r25	; 0x03
    2920:	8a 83       	std	Y+2, r24	; 0x02
        ind++;
    2922:	8d 81       	ldd	r24, Y+5	; 0x05
    2924:	8f 5f       	subi	r24, 0xFF	; 255
    2926:	8d 83       	std	Y+5, r24	; 0x05
        val = stri[ind];
    2928:	8d 81       	ldd	r24, Y+5	; 0x05
    292a:	28 2f       	mov	r18, r24
    292c:	33 27       	eor	r19, r19
    292e:	27 fd       	sbrc	r18, 7
    2930:	30 95       	com	r19
    2932:	8e 81       	ldd	r24, Y+6	; 0x06
    2934:	9f 81       	ldd	r25, Y+7	; 0x07
    2936:	fc 01       	movw	r30, r24
    2938:	e2 0f       	add	r30, r18
    293a:	f3 1f       	adc	r31, r19
    293c:	80 81       	ld	r24, Z
    293e:	89 83       	std	Y+1, r24	; 0x01
    char neg = ( stri[ind] == '-' ) ? 1 : 0;
    if ( neg )
        ind++;
    short res = 0;
    char val = stri[ ind ];
    while ( ( val >= '0' ) && ( val <= '9' ) && ( ind < CMD_LEN ) )
    2940:	89 81       	ldd	r24, Y+1	; 0x01
    2942:	80 33       	cpi	r24, 0x30	; 48
    2944:	34 f0       	brlt	.+12     	; 0x2952 <str2ind+0xca>
    2946:	89 81       	ldd	r24, Y+1	; 0x01
    2948:	8a 33       	cpi	r24, 0x3A	; 58
    294a:	1c f4       	brge	.+6      	; 0x2952 <str2ind+0xca>
    294c:	8d 81       	ldd	r24, Y+5	; 0x05
    294e:	80 34       	cpi	r24, 0x40	; 64
    2950:	6c f2       	brlt	.-102    	; 0x28ec <str2ind+0x64>
        res *= 10;
        res += (short)( val-'0' );
        ind++;
        val = stri[ind];
    }
    if ( neg )
    2952:	8c 81       	ldd	r24, Y+4	; 0x04
    2954:	88 23       	and	r24, r24
    2956:	19 f0       	breq	.+6      	; 0x295e <str2ind+0xd6>
        val = -val;
    2958:	89 81       	ldd	r24, Y+1	; 0x01
    295a:	81 95       	neg	r24
    295c:	89 83       	std	Y+1, r24	; 0x01
    return val;
    295e:	89 81       	ldd	r24, Y+1	; 0x01
    2960:	99 27       	eor	r25, r25
    2962:	87 fd       	sbrc	r24, 7
    2964:	90 95       	com	r25
}
    2966:	27 96       	adiw	r28, 0x07	; 7
    2968:	0f b6       	in	r0, 0x3f	; 63
    296a:	f8 94       	cli
    296c:	de bf       	out	0x3e, r29	; 62
    296e:	0f be       	out	0x3f, r0	; 63
    2970:	cd bf       	out	0x3d, r28	; 61
    2972:	cf 91       	pop	r28
    2974:	df 91       	pop	r29
    2976:	08 95       	ret

00002978 <procDbg>:

void procDbg( const char * args )
{
    2978:	df 93       	push	r29
    297a:	cf 93       	push	r28
    297c:	00 d0       	rcall	.+0      	; 0x297e <procDbg+0x6>
    297e:	0f 92       	push	r0
    2980:	cd b7       	in	r28, 0x3d	; 61
    2982:	de b7       	in	r29, 0x3e	; 62
    2984:	9b 83       	std	Y+3, r25	; 0x03
    2986:	8a 83       	std	Y+2, r24	; 0x02
    DDRD  |= (1<<3);
    2988:	a1 e3       	ldi	r26, 0x31	; 49
    298a:	b0 e0       	ldi	r27, 0x00	; 0
    298c:	e1 e3       	ldi	r30, 0x31	; 49
    298e:	f0 e0       	ldi	r31, 0x00	; 0
    2990:	80 81       	ld	r24, Z
    2992:	88 60       	ori	r24, 0x08	; 8
    2994:	8c 93       	st	X, r24
    unsigned char val = PIND;
    2996:	e0 e3       	ldi	r30, 0x30	; 48
    2998:	f0 e0       	ldi	r31, 0x00	; 0
    299a:	80 81       	ld	r24, Z
    299c:	89 83       	std	Y+1, r24	; 0x01
    if ( val & (1<<3) )
    299e:	89 81       	ldd	r24, Y+1	; 0x01
    29a0:	88 2f       	mov	r24, r24
    29a2:	90 e0       	ldi	r25, 0x00	; 0
    29a4:	88 70       	andi	r24, 0x08	; 8
    29a6:	90 70       	andi	r25, 0x00	; 0
    29a8:	00 97       	sbiw	r24, 0x00	; 0
    29aa:	31 f0       	breq	.+12     	; 0x29b8 <procDbg+0x40>
        PORTD = val & (~(1<<3) );
    29ac:	e2 e3       	ldi	r30, 0x32	; 50
    29ae:	f0 e0       	ldi	r31, 0x00	; 0
    29b0:	89 81       	ldd	r24, Y+1	; 0x01
    29b2:	87 7f       	andi	r24, 0xF7	; 247
    29b4:	80 83       	st	Z, r24
    29b6:	05 c0       	rjmp	.+10     	; 0x29c2 <procDbg+0x4a>
    else
        PORTD = val | (1<<3);
    29b8:	e2 e3       	ldi	r30, 0x32	; 50
    29ba:	f0 e0       	ldi	r31, 0x00	; 0
    29bc:	89 81       	ldd	r24, Y+1	; 0x01
    29be:	88 60       	ori	r24, 0x08	; 8
    29c0:	80 83       	st	Z, r24
}
    29c2:	0f 90       	pop	r0
    29c4:	0f 90       	pop	r0
    29c6:	0f 90       	pop	r0
    29c8:	cf 91       	pop	r28
    29ca:	df 91       	pop	r29
    29cc:	08 95       	ret

000029ce <procSetMotors>:

void procSetMotors( const char * args )
{
    29ce:	df 93       	push	r29
    29d0:	cf 93       	push	r28
    29d2:	00 d0       	rcall	.+0      	; 0x29d4 <procSetMotors+0x6>
    29d4:	cd b7       	in	r28, 0x3d	; 61
    29d6:	de b7       	in	r29, 0x3e	; 62
    29d8:	9a 83       	std	Y+2, r25	; 0x02
    29da:	89 83       	std	Y+1, r24	; 0x01
    // Set flag for another coroutine handling motors.
}
    29dc:	0f 90       	pop	r0
    29de:	0f 90       	pop	r0
    29e0:	cf 91       	pop	r28
    29e2:	df 91       	pop	r29
    29e4:	08 95       	ret

000029e6 <main>:
#include "task_dbg.h"

portBASE_TYPE g_res;

int __attribute__((noreturn)) main( void )
{
    29e6:	df 93       	push	r29
    29e8:	cf 93       	push	r28
    29ea:	00 d0       	rcall	.+0      	; 0x29ec <main+0x6>
    29ec:	0f 92       	push	r0
    29ee:	cd b7       	in	r28, 0x3d	; 61
    29f0:	de b7       	in	r29, 0x3e	; 62
    // Create the tasks defined within this file.
    g_res = xCoRoutineCreate( taskDbg, 0, 0 );
    29f2:	8a e1       	ldi	r24, 0x1A	; 26
    29f4:	95 e1       	ldi	r25, 0x15	; 21
    29f6:	60 e0       	ldi	r22, 0x00	; 0
    29f8:	40 e0       	ldi	r20, 0x00	; 0
    29fa:	0e 94 1b 03 	call	0x636	; 0x636 <xCoRoutineCreate>
    29fe:	80 93 b6 03 	sts	0x03B6, r24
    g_res = ( g_res == pdPASS ) ? 0 : 1;
    2a02:	80 91 b6 03 	lds	r24, 0x03B6
    2a06:	19 82       	std	Y+1, r1	; 0x01
    2a08:	81 30       	cpi	r24, 0x01	; 1
    2a0a:	11 f0       	breq	.+4      	; 0x2a10 <main+0x2a>
    2a0c:	81 e0       	ldi	r24, 0x01	; 1
    2a0e:	89 83       	std	Y+1, r24	; 0x01
    2a10:	89 81       	ldd	r24, Y+1	; 0x01
    2a12:	80 93 b6 03 	sts	0x03B6, r24

    vTaskStartScheduler();
    2a16:	0e 94 c1 0e 	call	0x1d82	; 0x1d82 <vTaskStartScheduler>
}
    2a1a:	0f 90       	pop	r0
    2a1c:	0f 90       	pop	r0
    2a1e:	0f 90       	pop	r0
    2a20:	cf 91       	pop	r28
    2a22:	df 91       	pop	r29
    2a24:	08 95       	ret

00002a26 <vApplicationIdleHook>:



void vApplicationIdleHook( void )
{
    2a26:	df 93       	push	r29
    2a28:	cf 93       	push	r28
    2a2a:	cd b7       	in	r28, 0x3d	; 61
    2a2c:	de b7       	in	r29, 0x3e	; 62
    for( ;; )
    {
        vCoRoutineSchedule();
    2a2e:	0e 94 23 05 	call	0xa46	; 0xa46 <vCoRoutineSchedule>
    2a32:	fd cf       	rjmp	.-6      	; 0x2a2e <vApplicationIdleHook+0x8>

00002a34 <taskDbg>:
#define MYUBRR F_CPU/2/BAUD-1

struct TIOStr st;

void taskDbg( xCoRoutineHandle xHandle, unsigned portBASE_TYPE uxIndex )
{
    2a34:	df 93       	push	r29
    2a36:	cf 93       	push	r28
    2a38:	00 d0       	rcall	.+0      	; 0x2a3a <taskDbg+0x6>
    2a3a:	00 d0       	rcall	.+0      	; 0x2a3c <taskDbg+0x8>
    2a3c:	0f 92       	push	r0
    2a3e:	cd b7       	in	r28, 0x3d	; 61
    2a40:	de b7       	in	r29, 0x3e	; 62
    2a42:	9a 83       	std	Y+2, r25	; 0x02
    2a44:	89 83       	std	Y+1, r24	; 0x01
    2a46:	6b 83       	std	Y+3, r22	; 0x03
    ioStructInit( &st );
    2a48:	87 eb       	ldi	r24, 0xB7	; 183
    2a4a:	93 e0       	ldi	r25, 0x03	; 3
    2a4c:	0e 94 18 13 	call	0x2630	; 0x2630 <ioStructInit>
    uartInit( MYUBRR );
    2a50:	80 e7       	ldi	r24, 0x70	; 112
    2a52:	92 e0       	ldi	r25, 0x02	; 2
    2a54:	0e 94 15 16 	call	0x2c2a	; 0x2c2a <uartInit>
    static char ind = 0;
    static char res = 'a';
    static char cmd[ CMD_LEN ];

DDRC |= 1;
    2a58:	a4 e3       	ldi	r26, 0x34	; 52
    2a5a:	b0 e0       	ldi	r27, 0x00	; 0
    2a5c:	e4 e3       	ldi	r30, 0x34	; 52
    2a5e:	f0 e0       	ldi	r31, 0x00	; 0
    2a60:	80 81       	ld	r24, Z
    2a62:	81 60       	ori	r24, 0x01	; 1
    2a64:	8c 93       	st	X, r24
    crSTART( xHandle );
    2a66:	e9 81       	ldd	r30, Y+1	; 0x01
    2a68:	fa 81       	ldd	r31, Y+2	; 0x02
    2a6a:	80 8d       	ldd	r24, Z+24	; 0x18
    2a6c:	91 8d       	ldd	r25, Z+25	; 0x19
    2a6e:	9d 83       	std	Y+5, r25	; 0x05
    2a70:	8c 83       	std	Y+4, r24	; 0x04
    2a72:	8c 81       	ldd	r24, Y+4	; 0x04
    2a74:	9d 81       	ldd	r25, Y+5	; 0x05
    2a76:	82 36       	cpi	r24, 0x62	; 98
    2a78:	91 05       	cpc	r25, r1
    2a7a:	09 f4       	brne	.+2      	; 0x2a7e <taskDbg+0x4a>
    2a7c:	9a c0       	rjmp	.+308    	; 0x2bb2 <taskDbg+0x17e>
    2a7e:	8c 81       	ldd	r24, Y+4	; 0x04
    2a80:	9d 81       	ldd	r25, Y+5	; 0x05
    2a82:	83 36       	cpi	r24, 0x63	; 99
    2a84:	91 05       	cpc	r25, r1
    2a86:	58 f4       	brcc	.+22     	; 0x2a9e <taskDbg+0x6a>
    2a88:	8c 81       	ldd	r24, Y+4	; 0x04
    2a8a:	9d 81       	ldd	r25, Y+5	; 0x05
    2a8c:	00 97       	sbiw	r24, 0x00	; 0
    2a8e:	71 f0       	breq	.+28     	; 0x2aac <taskDbg+0x78>
    2a90:	8c 81       	ldd	r24, Y+4	; 0x04
    2a92:	9d 81       	ldd	r25, Y+5	; 0x05
    2a94:	8a 35       	cpi	r24, 0x5A	; 90
    2a96:	91 05       	cpc	r25, r1
    2a98:	09 f4       	brne	.+2      	; 0x2a9c <taskDbg+0x68>
    2a9a:	76 c0       	rjmp	.+236    	; 0x2b88 <taskDbg+0x154>
    2a9c:	be c0       	rjmp	.+380    	; 0x2c1a <taskDbg+0x1e6>
    2a9e:	8c 81       	ldd	r24, Y+4	; 0x04
    2aa0:	9d 81       	ldd	r25, Y+5	; 0x05
    2aa2:	8e 36       	cpi	r24, 0x6E	; 110
    2aa4:	91 05       	cpc	r25, r1
    2aa6:	09 f4       	brne	.+2      	; 0x2aaa <taskDbg+0x76>
    2aa8:	9f c0       	rjmp	.+318    	; 0x2be8 <taskDbg+0x1b4>
    2aaa:	b7 c0       	rjmp	.+366    	; 0x2c1a <taskDbg+0x1e6>
    // Task loop
    for ( ;; )
    {
if ( PINC & 1 )
    2aac:	e3 e3       	ldi	r30, 0x33	; 51
    2aae:	f0 e0       	ldi	r31, 0x00	; 0
    2ab0:	80 81       	ld	r24, Z
    2ab2:	88 2f       	mov	r24, r24
    2ab4:	90 e0       	ldi	r25, 0x00	; 0
    2ab6:	81 70       	andi	r24, 0x01	; 1
    2ab8:	90 70       	andi	r25, 0x00	; 0
    2aba:	88 23       	and	r24, r24
    2abc:	41 f0       	breq	.+16     	; 0x2ace <taskDbg+0x9a>
    PORTC &= ~0x01;
    2abe:	a5 e3       	ldi	r26, 0x35	; 53
    2ac0:	b0 e0       	ldi	r27, 0x00	; 0
    2ac2:	e5 e3       	ldi	r30, 0x35	; 53
    2ac4:	f0 e0       	ldi	r31, 0x00	; 0
    2ac6:	80 81       	ld	r24, Z
    2ac8:	8e 7f       	andi	r24, 0xFE	; 254
    2aca:	8c 93       	st	X, r24
    2acc:	72 c0       	rjmp	.+228    	; 0x2bb2 <taskDbg+0x17e>
else
    PORTC |= 0x01;
    2ace:	a5 e3       	ldi	r26, 0x35	; 53
    2ad0:	b0 e0       	ldi	r27, 0x00	; 0
    2ad2:	e5 e3       	ldi	r30, 0x35	; 53
    2ad4:	f0 e0       	ldi	r31, 0x00	; 0
    2ad6:	80 81       	ld	r24, Z
    2ad8:	81 60       	ori	r24, 0x01	; 1
    2ada:	8c 93       	st	X, r24
    2adc:	6a c0       	rjmp	.+212    	; 0x2bb2 <taskDbg+0x17e>
        // Read command.
        while ( ( res != '\0' ) && ( ind < CMD_LEN ) )
        {
if ( PINC & 1 )
    2ade:	e3 e3       	ldi	r30, 0x33	; 51
    2ae0:	f0 e0       	ldi	r31, 0x00	; 0
    2ae2:	80 81       	ld	r24, Z
    2ae4:	88 2f       	mov	r24, r24
    2ae6:	90 e0       	ldi	r25, 0x00	; 0
    2ae8:	81 70       	andi	r24, 0x01	; 1
    2aea:	90 70       	andi	r25, 0x00	; 0
    2aec:	88 23       	and	r24, r24
    2aee:	41 f0       	breq	.+16     	; 0x2b00 <taskDbg+0xcc>
    PORTC &= ~0x01;
    2af0:	a5 e3       	ldi	r26, 0x35	; 53
    2af2:	b0 e0       	ldi	r27, 0x00	; 0
    2af4:	e5 e3       	ldi	r30, 0x35	; 53
    2af6:	f0 e0       	ldi	r31, 0x00	; 0
    2af8:	80 81       	ld	r24, Z
    2afa:	8e 7f       	andi	r24, 0xFE	; 254
    2afc:	8c 93       	st	X, r24
    2afe:	07 c0       	rjmp	.+14     	; 0x2b0e <taskDbg+0xda>
else
    PORTC |= 0x01;
    2b00:	a5 e3       	ldi	r26, 0x35	; 53
    2b02:	b0 e0       	ldi	r27, 0x00	; 0
    2b04:	e5 e3       	ldi	r30, 0x35	; 53
    2b06:	f0 e0       	ldi	r31, 0x00	; 0
    2b08:	80 81       	ld	r24, Z
    2b0a:	81 60       	ori	r24, 0x01	; 1
    2b0c:	8c 93       	st	X, r24
            if ( uartRead( (unsigned char *)(&res) ) == 0 )
    2b0e:	83 e7       	ldi	r24, 0x73	; 115
    2b10:	90 e0       	ldi	r25, 0x00	; 0
    2b12:	0e 94 58 16 	call	0x2cb0	; 0x2cb0 <uartRead>
    2b16:	88 23       	and	r24, r24
    2b18:	09 f0       	breq	.+2      	; 0x2b1c <taskDbg+0xe8>
    2b1a:	3e c0       	rjmp	.+124    	; 0x2b98 <taskDbg+0x164>
            {
                cmd[ ind++ ] = res;
    2b1c:	30 91 b5 03 	lds	r19, 0x03B5
    2b20:	83 2f       	mov	r24, r19
    2b22:	99 27       	eor	r25, r25
    2b24:	87 fd       	sbrc	r24, 7
    2b26:	90 95       	com	r25
    2b28:	20 91 73 00 	lds	r18, 0x0073
    2b2c:	fc 01       	movw	r30, r24
    2b2e:	eb 58       	subi	r30, 0x8B	; 139
    2b30:	fc 4f       	sbci	r31, 0xFC	; 252
    2b32:	20 83       	st	Z, r18
    2b34:	83 2f       	mov	r24, r19
    2b36:	8f 5f       	subi	r24, 0xFF	; 255
    2b38:	80 93 b5 03 	sts	0x03B5, r24
    2b3c:	25 c0       	rjmp	.+74     	; 0x2b88 <taskDbg+0x154>
                // Send result to sender to be sure it's been accepted.
                while ( uartWrite( *( (unsigned char *)(&res) ) ) )
                {
if ( PINC & 1 )
    2b3e:	e3 e3       	ldi	r30, 0x33	; 51
    2b40:	f0 e0       	ldi	r31, 0x00	; 0
    2b42:	80 81       	ld	r24, Z
    2b44:	88 2f       	mov	r24, r24
    2b46:	90 e0       	ldi	r25, 0x00	; 0
    2b48:	81 70       	andi	r24, 0x01	; 1
    2b4a:	90 70       	andi	r25, 0x00	; 0
    2b4c:	88 23       	and	r24, r24
    2b4e:	41 f0       	breq	.+16     	; 0x2b60 <taskDbg+0x12c>
    PORTC &= ~0x01;
    2b50:	a5 e3       	ldi	r26, 0x35	; 53
    2b52:	b0 e0       	ldi	r27, 0x00	; 0
    2b54:	e5 e3       	ldi	r30, 0x35	; 53
    2b56:	f0 e0       	ldi	r31, 0x00	; 0
    2b58:	80 81       	ld	r24, Z
    2b5a:	8e 7f       	andi	r24, 0xFE	; 254
    2b5c:	8c 93       	st	X, r24
    2b5e:	07 c0       	rjmp	.+14     	; 0x2b6e <taskDbg+0x13a>
else
    PORTC |= 0x01;
    2b60:	a5 e3       	ldi	r26, 0x35	; 53
    2b62:	b0 e0       	ldi	r27, 0x00	; 0
    2b64:	e5 e3       	ldi	r30, 0x35	; 53
    2b66:	f0 e0       	ldi	r31, 0x00	; 0
    2b68:	80 81       	ld	r24, Z
    2b6a:	81 60       	ori	r24, 0x01	; 1
    2b6c:	8c 93       	st	X, r24
                    crDELAY( xHandle, 1 );
    2b6e:	81 e0       	ldi	r24, 0x01	; 1
    2b70:	90 e0       	ldi	r25, 0x00	; 0
    2b72:	60 e0       	ldi	r22, 0x00	; 0
    2b74:	70 e0       	ldi	r23, 0x00	; 0
    2b76:	0e 94 ae 03 	call	0x75c	; 0x75c <vCoRoutineAddToDelayedList>
    2b7a:	e9 81       	ldd	r30, Y+1	; 0x01
    2b7c:	fa 81       	ldd	r31, Y+2	; 0x02
    2b7e:	8a e5       	ldi	r24, 0x5A	; 90
    2b80:	90 e0       	ldi	r25, 0x00	; 0
    2b82:	91 8f       	std	Z+25, r25	; 0x19
    2b84:	80 8f       	std	Z+24, r24	; 0x18
    2b86:	49 c0       	rjmp	.+146    	; 0x2c1a <taskDbg+0x1e6>
    PORTC |= 0x01;
            if ( uartRead( (unsigned char *)(&res) ) == 0 )
            {
                cmd[ ind++ ] = res;
                // Send result to sender to be sure it's been accepted.
                while ( uartWrite( *( (unsigned char *)(&res) ) ) )
    2b88:	e3 e7       	ldi	r30, 0x73	; 115
    2b8a:	f0 e0       	ldi	r31, 0x00	; 0
    2b8c:	80 81       	ld	r24, Z
    2b8e:	0e 94 3b 16 	call	0x2c76	; 0x2c76 <uartWrite>
    2b92:	88 23       	and	r24, r24
    2b94:	a1 f6       	brne	.-88     	; 0x2b3e <taskDbg+0x10a>
    2b96:	06 c0       	rjmp	.+12     	; 0x2ba4 <taskDbg+0x170>
    PORTC |= 0x01;
                    crDELAY( xHandle, 1 );
                }
            }
            else
                crDELAY( xHandle, 1 );
    2b98:	81 e0       	ldi	r24, 0x01	; 1
    2b9a:	90 e0       	ldi	r25, 0x00	; 0
    2b9c:	60 e0       	ldi	r22, 0x00	; 0
    2b9e:	70 e0       	ldi	r23, 0x00	; 0
    2ba0:	0e 94 ae 03 	call	0x75c	; 0x75c <vCoRoutineAddToDelayedList>
    2ba4:	e9 81       	ldd	r30, Y+1	; 0x01
    2ba6:	fa 81       	ldd	r31, Y+2	; 0x02
    2ba8:	82 e6       	ldi	r24, 0x62	; 98
    2baa:	90 e0       	ldi	r25, 0x00	; 0
    2bac:	91 8f       	std	Z+25, r25	; 0x19
    2bae:	80 8f       	std	Z+24, r24	; 0x18
    2bb0:	34 c0       	rjmp	.+104    	; 0x2c1a <taskDbg+0x1e6>
if ( PINC & 1 )
    PORTC &= ~0x01;
else
    PORTC |= 0x01;
        // Read command.
        while ( ( res != '\0' ) && ( ind < CMD_LEN ) )
    2bb2:	80 91 73 00 	lds	r24, 0x0073
    2bb6:	88 23       	and	r24, r24
    2bb8:	29 f0       	breq	.+10     	; 0x2bc4 <taskDbg+0x190>
    2bba:	80 91 b5 03 	lds	r24, 0x03B5
    2bbe:	80 34       	cpi	r24, 0x40	; 64
    2bc0:	0c f4       	brge	.+2      	; 0x2bc4 <taskDbg+0x190>
    2bc2:	8d cf       	rjmp	.-230    	; 0x2ade <taskDbg+0xaa>
                }
            }
            else
                crDELAY( xHandle, 1 );
        }
        ind = 0;
    2bc4:	10 92 b5 03 	sts	0x03B5, r1
        res = 'a';
    2bc8:	81 e6       	ldi	r24, 0x61	; 97
    2bca:	80 93 73 00 	sts	0x0073, r24
        // Parse command
        //parseCmd( cmd );
        crDELAY( xHandle, 1 );
    2bce:	81 e0       	ldi	r24, 0x01	; 1
    2bd0:	90 e0       	ldi	r25, 0x00	; 0
    2bd2:	60 e0       	ldi	r22, 0x00	; 0
    2bd4:	70 e0       	ldi	r23, 0x00	; 0
    2bd6:	0e 94 ae 03 	call	0x75c	; 0x75c <vCoRoutineAddToDelayedList>
    2bda:	e9 81       	ldd	r30, Y+1	; 0x01
    2bdc:	fa 81       	ldd	r31, Y+2	; 0x02
    2bde:	8e e6       	ldi	r24, 0x6E	; 110
    2be0:	90 e0       	ldi	r25, 0x00	; 0
    2be2:	91 8f       	std	Z+25, r25	; 0x19
    2be4:	80 8f       	std	Z+24, r24	; 0x18
    2be6:	19 c0       	rjmp	.+50     	; 0x2c1a <taskDbg+0x1e6>
if ( PINC & 1 )
    2be8:	e3 e3       	ldi	r30, 0x33	; 51
    2bea:	f0 e0       	ldi	r31, 0x00	; 0
    2bec:	80 81       	ld	r24, Z
    2bee:	88 2f       	mov	r24, r24
    2bf0:	90 e0       	ldi	r25, 0x00	; 0
    2bf2:	81 70       	andi	r24, 0x01	; 1
    2bf4:	90 70       	andi	r25, 0x00	; 0
    2bf6:	88 23       	and	r24, r24
    2bf8:	41 f0       	breq	.+16     	; 0x2c0a <taskDbg+0x1d6>
    PORTC &= ~0x01;
    2bfa:	a5 e3       	ldi	r26, 0x35	; 53
    2bfc:	b0 e0       	ldi	r27, 0x00	; 0
    2bfe:	e5 e3       	ldi	r30, 0x35	; 53
    2c00:	f0 e0       	ldi	r31, 0x00	; 0
    2c02:	80 81       	ld	r24, Z
    2c04:	8e 7f       	andi	r24, 0xFE	; 254
    2c06:	8c 93       	st	X, r24
    2c08:	51 cf       	rjmp	.-350    	; 0x2aac <taskDbg+0x78>
else
    PORTC |= 0x01;
    2c0a:	a5 e3       	ldi	r26, 0x35	; 53
    2c0c:	b0 e0       	ldi	r27, 0x00	; 0
    2c0e:	e5 e3       	ldi	r30, 0x35	; 53
    2c10:	f0 e0       	ldi	r31, 0x00	; 0
    2c12:	80 81       	ld	r24, Z
    2c14:	81 60       	ori	r24, 0x01	; 1
    2c16:	8c 93       	st	X, r24
    2c18:	49 cf       	rjmp	.-366    	; 0x2aac <taskDbg+0x78>
    }

    crEND();
}
    2c1a:	0f 90       	pop	r0
    2c1c:	0f 90       	pop	r0
    2c1e:	0f 90       	pop	r0
    2c20:	0f 90       	pop	r0
    2c22:	0f 90       	pop	r0
    2c24:	cf 91       	pop	r28
    2c26:	df 91       	pop	r29
    2c28:	08 95       	ret

00002c2a <uartInit>:
#include <avr/io.h>

#define DDR_XCK 0

void uartInit( unsigned short ubrr )
{
    2c2a:	df 93       	push	r29
    2c2c:	cf 93       	push	r28
    2c2e:	00 d0       	rcall	.+0      	; 0x2c30 <uartInit+0x6>
    2c30:	cd b7       	in	r28, 0x3d	; 61
    2c32:	de b7       	in	r29, 0x3e	; 62
    2c34:	9a 83       	std	Y+2, r25	; 0x02
    2c36:	89 83       	std	Y+1, r24	; 0x01
    // Set baud rate
    UBRRH = (unsigned char)( ubrr >> 8 );
    2c38:	e0 e4       	ldi	r30, 0x40	; 64
    2c3a:	f0 e0       	ldi	r31, 0x00	; 0
    2c3c:	89 81       	ldd	r24, Y+1	; 0x01
    2c3e:	9a 81       	ldd	r25, Y+2	; 0x02
    2c40:	89 2f       	mov	r24, r25
    2c42:	99 27       	eor	r25, r25
    2c44:	80 83       	st	Z, r24
    UBRRL = (unsigned char)(ubrr & 0xFF );
    2c46:	e9 e2       	ldi	r30, 0x29	; 41
    2c48:	f0 e0       	ldi	r31, 0x00	; 0
    2c4a:	89 81       	ldd	r24, Y+1	; 0x01
    2c4c:	80 83       	st	Z, r24
    // Enable receiver and transmitter
    UCSRB = (1<<RXEN)|(1<<TXEN);
    2c4e:	ea e2       	ldi	r30, 0x2A	; 42
    2c50:	f0 e0       	ldi	r31, 0x00	; 0
    2c52:	88 e1       	ldi	r24, 0x18	; 24
    2c54:	80 83       	st	Z, r24
    // Set frame format: 8data, 2stop bit, synchronous
    UCSRC = (1<<URSEL)|
    2c56:	e0 e4       	ldi	r30, 0x40	; 64
    2c58:	f0 e0       	ldi	r31, 0x00	; 0
    2c5a:	8e ec       	ldi	r24, 0xCE	; 206
    2c5c:	80 83       	st	Z, r24
            (1<<USBS)|(3<<UCSZ0)|(1<<UMSEL);
    // Set slave mode
    DDRB &= ~(1<<DDR_XCK);
    2c5e:	a7 e3       	ldi	r26, 0x37	; 55
    2c60:	b0 e0       	ldi	r27, 0x00	; 0
    2c62:	e7 e3       	ldi	r30, 0x37	; 55
    2c64:	f0 e0       	ldi	r31, 0x00	; 0
    2c66:	80 81       	ld	r24, Z
    2c68:	8e 7f       	andi	r24, 0xFE	; 254
    2c6a:	8c 93       	st	X, r24
}
    2c6c:	0f 90       	pop	r0
    2c6e:	0f 90       	pop	r0
    2c70:	cf 91       	pop	r28
    2c72:	df 91       	pop	r29
    2c74:	08 95       	ret

00002c76 <uartWrite>:

unsigned char uartWrite( unsigned char val )
{
    2c76:	df 93       	push	r29
    2c78:	cf 93       	push	r28
    2c7a:	00 d0       	rcall	.+0      	; 0x2c7c <uartWrite+0x6>
    2c7c:	cd b7       	in	r28, 0x3d	; 61
    2c7e:	de b7       	in	r29, 0x3e	; 62
    2c80:	89 83       	std	Y+1, r24	; 0x01
    // Wait for empty transmit buffer
    if ( !( UCSRA & (1<<UDRE)) )
    2c82:	eb e2       	ldi	r30, 0x2B	; 43
    2c84:	f0 e0       	ldi	r31, 0x00	; 0
    2c86:	80 81       	ld	r24, Z
    2c88:	88 2f       	mov	r24, r24
    2c8a:	90 e0       	ldi	r25, 0x00	; 0
    2c8c:	80 72       	andi	r24, 0x20	; 32
    2c8e:	90 70       	andi	r25, 0x00	; 0
    2c90:	00 97       	sbiw	r24, 0x00	; 0
    2c92:	19 f4       	brne	.+6      	; 0x2c9a <uartWrite+0x24>
        return 1;
    2c94:	81 e0       	ldi	r24, 0x01	; 1
    2c96:	8a 83       	std	Y+2, r24	; 0x02
    2c98:	05 c0       	rjmp	.+10     	; 0x2ca4 <uartWrite+0x2e>
    // Put data into buffer, sends the data
    UDR = val;
    2c9a:	ec e2       	ldi	r30, 0x2C	; 44
    2c9c:	f0 e0       	ldi	r31, 0x00	; 0
    2c9e:	89 81       	ldd	r24, Y+1	; 0x01
    2ca0:	80 83       	st	Z, r24
    return 0;
    2ca2:	1a 82       	std	Y+2, r1	; 0x02
    2ca4:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2ca6:	0f 90       	pop	r0
    2ca8:	0f 90       	pop	r0
    2caa:	cf 91       	pop	r28
    2cac:	df 91       	pop	r29
    2cae:	08 95       	ret

00002cb0 <uartRead>:

unsigned char uartRead( unsigned char * res )
{
    2cb0:	df 93       	push	r29
    2cb2:	cf 93       	push	r28
    2cb4:	00 d0       	rcall	.+0      	; 0x2cb6 <uartRead+0x6>
    2cb6:	0f 92       	push	r0
    2cb8:	cd b7       	in	r28, 0x3d	; 61
    2cba:	de b7       	in	r29, 0x3e	; 62
    2cbc:	9a 83       	std	Y+2, r25	; 0x02
    2cbe:	89 83       	std	Y+1, r24	; 0x01
    // Wait for data to be received
    if ( !(UCSRA & (1<<RXC)) )
    2cc0:	eb e2       	ldi	r30, 0x2B	; 43
    2cc2:	f0 e0       	ldi	r31, 0x00	; 0
    2cc4:	80 81       	ld	r24, Z
    2cc6:	88 23       	and	r24, r24
    2cc8:	1c f0       	brlt	.+6      	; 0x2cd0 <uartRead+0x20>
        return 1;
    2cca:	81 e0       	ldi	r24, 0x01	; 1
    2ccc:	8b 83       	std	Y+3, r24	; 0x03
    2cce:	07 c0       	rjmp	.+14     	; 0x2cde <uartRead+0x2e>
    // Get and return received data from buffer
    *res = UDR;
    2cd0:	ec e2       	ldi	r30, 0x2C	; 44
    2cd2:	f0 e0       	ldi	r31, 0x00	; 0
    2cd4:	80 81       	ld	r24, Z
    2cd6:	e9 81       	ldd	r30, Y+1	; 0x01
    2cd8:	fa 81       	ldd	r31, Y+2	; 0x02
    2cda:	80 83       	st	Z, r24
    return 0;
    2cdc:	1b 82       	std	Y+3, r1	; 0x03
    2cde:	8b 81       	ldd	r24, Y+3	; 0x03
}
    2ce0:	0f 90       	pop	r0
    2ce2:	0f 90       	pop	r0
    2ce4:	0f 90       	pop	r0
    2ce6:	cf 91       	pop	r28
    2ce8:	df 91       	pop	r29
    2cea:	08 95       	ret

00002cec <memcpy>:
    2cec:	fb 01       	movw	r30, r22
    2cee:	dc 01       	movw	r26, r24
    2cf0:	02 c0       	rjmp	.+4      	; 0x2cf6 <memcpy+0xa>
    2cf2:	01 90       	ld	r0, Z+
    2cf4:	0d 92       	st	X+, r0
    2cf6:	41 50       	subi	r20, 0x01	; 1
    2cf8:	50 40       	sbci	r21, 0x00	; 0
    2cfa:	d8 f7       	brcc	.-10     	; 0x2cf2 <memcpy+0x6>
    2cfc:	08 95       	ret

00002cfe <memset>:
    2cfe:	dc 01       	movw	r26, r24
    2d00:	01 c0       	rjmp	.+2      	; 0x2d04 <memset+0x6>
    2d02:	6d 93       	st	X+, r22
    2d04:	41 50       	subi	r20, 0x01	; 1
    2d06:	50 40       	sbci	r21, 0x00	; 0
    2d08:	e0 f7       	brcc	.-8      	; 0x2d02 <memset+0x4>
    2d0a:	08 95       	ret

00002d0c <strcmp>:
    2d0c:	fb 01       	movw	r30, r22
    2d0e:	dc 01       	movw	r26, r24
    2d10:	8d 91       	ld	r24, X+
    2d12:	01 90       	ld	r0, Z+
    2d14:	80 19       	sub	r24, r0
    2d16:	01 10       	cpse	r0, r1
    2d18:	d9 f3       	breq	.-10     	; 0x2d10 <strcmp+0x4>
    2d1a:	99 0b       	sbc	r25, r25
    2d1c:	08 95       	ret

00002d1e <strncpy>:
    2d1e:	fb 01       	movw	r30, r22
    2d20:	dc 01       	movw	r26, r24
    2d22:	41 50       	subi	r20, 0x01	; 1
    2d24:	50 40       	sbci	r21, 0x00	; 0
    2d26:	48 f0       	brcs	.+18     	; 0x2d3a <strncpy+0x1c>
    2d28:	01 90       	ld	r0, Z+
    2d2a:	0d 92       	st	X+, r0
    2d2c:	00 20       	and	r0, r0
    2d2e:	c9 f7       	brne	.-14     	; 0x2d22 <strncpy+0x4>
    2d30:	01 c0       	rjmp	.+2      	; 0x2d34 <strncpy+0x16>
    2d32:	1d 92       	st	X+, r1
    2d34:	41 50       	subi	r20, 0x01	; 1
    2d36:	50 40       	sbci	r21, 0x00	; 0
    2d38:	e0 f7       	brcc	.-8      	; 0x2d32 <strncpy+0x14>
    2d3a:	08 95       	ret

00002d3c <_exit>:
    2d3c:	f8 94       	cli

00002d3e <__stop_program>:
    2d3e:	ff cf       	rjmp	.-2      	; 0x2d3e <__stop_program>
